,Unnamed: 0,commit_id,diff,label,filename,LOC_MOD,PL,repo,partition
2548,12124,a67083ff4b8dcbb7ee2839da6338032030d712b0,"@@ -311,7 +311,10 @@ void updateHandshakeState(QuicServerConnectionState& conn) {
       conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);
     }
     QUIC_TRACE(fst_trace, conn, ""derived 1-rtt write cipher"");
-    CHECK(!conn.oneRttWriteCipher.get());
+    if (conn.oneRttWriteCipher) {
+      throw QuicTransportException(
+          ""Duplicate 1-rtt write cipher"", TransportErrorCode::CRYPTO_ERROR);
+    }
     conn.oneRttWriteCipher = std::move(oneRttWriteCipher);
 
     updatePacingOnKeyEstablished(conn);
",0,quic/server/state/ServerStateMachine.cpp,5,java,facebookincubator___mvfst,test
5551,26164,f887cf165db20f405cb8805c716bd363aaadf815,"@@ -1521,8 +1521,37 @@ gboolean vnc_client_io(QIOChannel *ioc G_GNUC_UNUSED,
 }
 
 
+/*
+ * Scale factor to apply to vs->throttle_output_offset when checking for
+ * hard limit. Worst case normal usage could be x2, if we have a complete
+ * incremental update and complete forced update in the output buffer.
+ * So x3 should be good enough, but we pick x5 to be conservative and thus
+ * (hopefully) never trigger incorrectly.
+ */
+#define VNC_THROTTLE_OUTPUT_LIMIT_SCALE 5
+
 void vnc_write(VncState *vs, const void *data, size_t len)
 {
+    if (vs->disconnecting) {
+        return;
+    }
+    /* Protection against malicious client/guest to prevent our output
+     * buffer growing without bound if client stops reading data. This
+     * should rarely trigger, because we have earlier throttling code
+     * which stops issuing framebuffer updates and drops audio data
+     * if the throttle_output_offset value is exceeded. So we only reach
+     * this higher level if a huge number of pseudo-encodings get
+     * triggered while data can't be sent on the socket.
+     *
+     * NB throttle_output_offset can be zero during early protocol
+     * handshake, or from the job thread's VncState clone
+     */
+    if (vs->throttle_output_offset != 0 &&
+        vs->output.offset > (vs->throttle_output_offset *
+                             VNC_THROTTLE_OUTPUT_LIMIT_SCALE)) {
+        vnc_disconnect_start(vs);
+        return;
+    }
     buffer_reserve(&vs->output, len);
 
     if (vs->ioc != NULL && buffer_empty(&vs->output)) {
",0,ui/vnc.c,29,java,qemu___qemu,test
7570,35718,afc39bea36fd436e54262f150c009e8d72db5014,"@@ -4409,51 +4409,6 @@ TEST_F(HttpConnectionManagerImplTest, DisableKeepAliveWhenOverloaded) {
   EXPECT_EQ(1U, stats_.named_.downstream_cx_overload_disable_keepalive_.value());
 }
 
-TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {
-  setup(false, """");
-
-  std::string response_code;
-  std::string response_body;
-  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {
-    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);
-    HeaderMapPtr headers{
-        new TestHeaderMapImpl{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}}};
-    headers->addCopy(LowerCaseString(""Foo""), std::string(60 * 1024, 'a'));
-
-    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))
-        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {
-          response_code = std::string(headers.Status()->value().getStringView());
-        }));
-    decoder->decodeHeaders(std::move(headers), true);
-    conn_manager_->newStream(response_encoder_);
-  }));
-
-  Buffer::OwnedImpl fake_input(""1234"");
-  conn_manager_->onData(fake_input, false); // kick off request
-
-  EXPECT_EQ(""431"", response_code);
-  EXPECT_EQ("""", response_body);
-}
-
-TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersAcceptedIfConfigured) {
-  max_request_headers_kb_ = 62;
-  setup(false, """");
-
-  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {
-    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);
-    HeaderMapPtr headers{
-        new TestHeaderMapImpl{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}}};
-    headers->addCopy(LowerCaseString(""Foo""), std::string(60 * 1024, 'a'));
-
-    EXPECT_CALL(response_encoder_, encodeHeaders(_, _)).Times(0);
-    decoder->decodeHeaders(std::move(headers), true);
-    conn_manager_->newStream(response_encoder_);
-  }));
-
-  Buffer::OwnedImpl fake_input(""1234"");
-  conn_manager_->onData(fake_input, false); // kick off request
-}
-
 TEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathFirstFilter) {
   setup(false, ""envoy-custom-server"", false);
   setUpEncoderAndDecoder(true, true);
",0,test/common/http/conn_manager_impl_test.cc,45,java,envoyproxy___envoy,test
4222,19826,40d373ede795443ae6f2f756e9fb1f4f4ae90bbe,"@@ -716,7 +716,6 @@ TEST(acm, wifi_channel_20ms_20pct_loss)
     EXPECT_LT( stats.avg_expand_rate, 25.0 );
 }
 
-#if 0
 TEST(acm, wifi_channel_20ms_20pct_loss_fec)
 {
     float cpu_load;
@@ -749,4 +748,3 @@ TEST(acm, wifi_channel_20ms_20pct_loss_fec)
     EXPECT_LT( stats.max_expand_rate, 10.0 );
     EXPECT_LT( stats.avg_expand_rate, 6.0 );
 }
-#endif
",0,test/test_acm.cpp,2,java,wireapp___wire-avs,test
4494,21104,98e8790326d732fc79f0c133d9658f4761ba9cb7,"@@ -643,6 +643,7 @@ static void baum_chr_open(Chardev *chr,
         error_setg(errp, ""brlapi__openConnection: %s"",
                    brlapi_strerror(brlapi_error_location()));
         g_free(handle);
+        baum->brlapi = NULL;
         return;
     }
     baum->deferred_init = 0;
",0,chardev/baum.c,1,java,qemu___qemu,test
6767,31832,0aca6bc05a263ea9eafee515fc6ba14da94c1964,"@@ -366,8 +366,42 @@ PermissionsData::AccessType PermissionsData::GetContentScriptAccess(
       tab_permissions ? &tab_permissions->scriptable_hosts() : nullptr, error);
 }
 
-bool PermissionsData::CanCaptureVisiblePage(int tab_id,
+bool PermissionsData::CanCaptureVisiblePage(const GURL& document_url,
+                                            const Extension* extension,
+                                            int tab_id,
                                             std::string* error) const {
+  bool has_active_tab = false;
+  {
+    base::AutoLock auto_lock(runtime_lock_);
+    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
+    has_active_tab = tab_permissions &&
+                     tab_permissions->HasAPIPermission(APIPermission::kTab);
+  }
+  // We check GetPageAccess() (in addition the the <all_urls> and activeTab
+  // checks below) for the case of URLs that can be conditionally granted (such
+  // as file:// URLs or chrome:// URLs for component extensions), and to respect
+  // policy restrictions, if any. If an extension has <all_urls>,
+  // GetPageAccess() will still (correctly) return false if, for instance, the
+  // URL is a file:// URL and the extension does not have file access.
+  // See https://crbug.com/810220.
+  if (GetPageAccess(extension, document_url, tab_id, error) != ACCESS_ALLOWED) {
+    if (!document_url.SchemeIs(content::kChromeUIScheme))
+      return false;
+
+    // Most extensions will not have (and cannot get) access to chrome:// URLs
+    // (which are restricted). However, allowing them to capture these URLs can
+    // be useful, such as in the case of capturing a screenshot. Allow
+    // extensions that have been explicitly invoked (and have the activeTab)
+    // permission to capture chrome:// URLs.
+    if (has_active_tab)
+      return true;
+
+    if (error)
+      *error = manifest_errors::kActiveTabPermissionNotGranted;
+
+    return false;
+  }
+
   const URLPattern all_urls(URLPattern::SCHEME_ALL,
                             URLPattern::kAllUrlsPattern);
 
@@ -375,15 +409,10 @@ bool PermissionsData::CanCaptureVisiblePage(int tab_id,
   if (active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls))
     return true;
 
-  if (tab_id >= 0) {
-    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
-    if (tab_permissions &&
-        tab_permissions->HasAPIPermission(APIPermission::kTab)) {
-      return true;
-    }
-    if (error)
-      *error = manifest_errors::kActiveTabPermissionNotGranted;
-    return false;
+  const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
+  if (tab_permissions &&
+      tab_permissions->HasAPIPermission(APIPermission::kTab)) {
+    return true;
   }
 
   if (error)
",0,extensions/common/permissions/permissions_data.cc,49,java,chromium___chromium,test
1363,6579,2ef0f392711445e173a56b2c073dedb021ae3783,"@@ -356,8 +356,9 @@ static int rac_get_model2_sym(RangeCoder *c, Model2 *m)
 
 static int rac_get_model_sym(RangeCoder *c, Model *m)
 {
-    int prob, prob2, helper, val;
+    int val;
     int end, end2;
+    unsigned prob, prob2, helper;
 
     prob       = 0;
     prob2      = c->range;
",0,libavcodec/mss3.c,3,java,ffmpeg___ffmpeg,test
1389,6700,6686aa8acc85ae9a03cecdedc7c9d8b090e2b97b,"@@ -8,10 +8,17 @@ namespace Envoy {
 namespace Config {
 namespace {
 
-class GrpcSubscriptionImplTest : public testing::Test, public GrpcSubscriptionTestHarness {};
+class GrpcSubscriptionImplTest : public testing::TestWithParam<LegacyOrUnified>,
+                                 public GrpcSubscriptionTestHarness {
+public:
+  GrpcSubscriptionImplTest() : GrpcSubscriptionTestHarness(GetParam()) {}
+};
+
+INSTANTIATE_TEST_SUITE_P(GrpcSubscriptionImplTest, GrpcSubscriptionImplTest,
+                         testing::ValuesIn({LegacyOrUnified::Legacy, LegacyOrUnified::Unified}));
 
 // Validate that stream creation results in a timer based retry and can recover.
-TEST_F(GrpcSubscriptionImplTest, StreamCreationFailure) {
+TEST_P(GrpcSubscriptionImplTest, StreamCreationFailure) {
   InSequence s;
   EXPECT_CALL(*async_client_, startRaw(_, _, _, _)).WillOnce(Return(nullptr));
 
@@ -37,7 +44,7 @@ TEST_F(GrpcSubscriptionImplTest, StreamCreationFailure) {
 }
 
 // Validate that the client can recover from a remote stream closure via retry.
-TEST_F(GrpcSubscriptionImplTest, RemoteStreamClose) {
+TEST_P(GrpcSubscriptionImplTest, RemoteStreamClose) {
   startSubscription({""cluster0"", ""cluster1""});
   EXPECT_TRUE(statsAre(1, 0, 0, 0, 0, 0, 0, """"));
   // onConfigUpdateFailed() should not be called for gRPC stream connection failure
@@ -46,7 +53,7 @@ TEST_F(GrpcSubscriptionImplTest, RemoteStreamClose) {
       .Times(0);
   EXPECT_CALL(*timer_, enableTimer(_, _));
   EXPECT_CALL(random_, random());
-  mux_->grpcStreamForTest().onRemoteClose(Grpc::Status::WellKnownGrpcStatus::Canceled, """");
+  onRemoteClose();
   EXPECT_TRUE(statsAre(2, 0, 0, 1, 0, 0, 0, """"));
   verifyControlPlaneStats(0);
 
@@ -59,7 +66,7 @@ TEST_F(GrpcSubscriptionImplTest, RemoteStreamClose) {
 
 // Validate that When the management server gets multiple requests for the same version, it can
 // ignore later ones. This allows the nonce to be used.
-TEST_F(GrpcSubscriptionImplTest, RepeatedNonce) {
+TEST_P(GrpcSubscriptionImplTest, RepeatedNonce) {
   InSequence s;
   startSubscription({""cluster0"", ""cluster1""});
   EXPECT_TRUE(statsAre(1, 0, 0, 0, 0, 0, 0, """"));
@@ -79,7 +86,7 @@ TEST_F(GrpcSubscriptionImplTest, RepeatedNonce) {
   EXPECT_TRUE(statsAre(7, 2, 2, 0, 0, TEST_TIME_MILLIS, 7919287270473417401, ""42""));
 }
 
-TEST_F(GrpcSubscriptionImplTest, UpdateTimeNotChangedOnUpdateReject) {
+TEST_P(GrpcSubscriptionImplTest, UpdateTimeNotChangedOnUpdateReject) {
   InSequence s;
   startSubscription({""cluster0"", ""cluster1""});
   EXPECT_TRUE(statsAre(1, 0, 0, 0, 0, 0, 0, """"));
@@ -87,7 +94,7 @@ TEST_F(GrpcSubscriptionImplTest, UpdateTimeNotChangedOnUpdateReject) {
   EXPECT_TRUE(statsAre(2, 0, 1, 0, 0, 0, 0, """"));
 }
 
-TEST_F(GrpcSubscriptionImplTest, UpdateTimeChangedOnUpdateSuccess) {
+TEST_P(GrpcSubscriptionImplTest, UpdateTimeChangedOnUpdateSuccess) {
   InSequence s;
   startSubscription({""cluster0"", ""cluster1""});
   EXPECT_TRUE(statsAre(1, 0, 0, 0, 0, 0, 0, """"));
",1,test/common/config/grpc_subscription_impl_test.cc,21,java,envoyproxy___envoy,test
1038,4902,10d059bb24eb88157e071a3db102ddd8f4937a00,"@@ -932,7 +932,7 @@ static const uint8_t dnxhd_1250_run[62] = {
     49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
 };
 
-const CIDEntry ff_dnxhd_cid_table[] = {
+static const CIDEntry dnxhd_cid_table[] = {
     { 1235, 1920, 1080, 917504, 917504,
       0, 6, 10, 4,
       dnxhd_1235_luma_weight, dnxhd_1235_chroma_weight,
@@ -1075,31 +1075,31 @@ const CIDEntry ff_dnxhd_cid_table[] = {
       { 0 }, { 5888, 255} },
 };
 
-int ff_dnxhd_get_cid_table(int cid)
+const CIDEntry *ff_dnxhd_get_cid_table(int cid)
 {
-    int i;
-    for (i = 0; i < FF_ARRAY_ELEMS(ff_dnxhd_cid_table); i++)
-        if (ff_dnxhd_cid_table[i].cid == cid)
-            return i;
-    return -1;
+    for (int i = 0; i < FF_ARRAY_ELEMS(dnxhd_cid_table); i++)
+        if (dnxhd_cid_table[i].cid == cid)
+            return &dnxhd_cid_table[i];
+    return NULL;
 }
 
 int avpriv_dnxhd_get_frame_size(int cid)
 {
-    int i = ff_dnxhd_get_cid_table(cid);
-    if (i<0)
-        return i;
-    return ff_dnxhd_cid_table[i].frame_size;
+    const CIDEntry *entry = ff_dnxhd_get_cid_table(cid);
+    if (!entry)
+        return -1;
+    return entry->frame_size;
 }
 
 int avpriv_dnxhd_get_hr_frame_size(int cid, int w, int h)
 {
-    int result, i = ff_dnxhd_get_cid_table(cid);
+    const CIDEntry *entry = ff_dnxhd_get_cid_table(cid);
+    int result;
 
-    if (i < 0)
-        return i;
+    if (!entry)
+        return -1;
 
-    result = ((h + 15) / 16) * ((w + 15) / 16) * (int64_t)ff_dnxhd_cid_table[i].packet_scale.num / ff_dnxhd_cid_table[i].packet_scale.den;
+    result = ((h + 15) / 16) * ((w + 15) / 16) * (int64_t)entry->packet_scale.num / entry->packet_scale.den;
     result = (result + 2048) / 4096 * 4096;
 
     return FFMAX(result, 8192);
@@ -1107,10 +1107,10 @@ int avpriv_dnxhd_get_hr_frame_size(int cid, int w, int h)
 
 int avpriv_dnxhd_get_interlaced(int cid)
 {
-    int i = ff_dnxhd_get_cid_table(cid);
-    if (i < 0)
-        return i;
-    return ff_dnxhd_cid_table[i].flags & DNXHD_INTERLACED ? 1 : 0;
+    const CIDEntry *entry = ff_dnxhd_get_cid_table(cid);
+    if (!entry)
+        return -1;
+    return entry->flags & DNXHD_INTERLACED ? 1 : 0;
 }
 
 static int dnxhd_find_hr_cid(AVCodecContext *avctx)
@@ -1140,8 +1140,8 @@ int ff_dnxhd_find_cid(AVCodecContext *avctx, int bit_depth)
 
     if (!mbs)
         return 0;
-    for (i = 0; i < FF_ARRAY_ELEMS(ff_dnxhd_cid_table); i++) {
-        const CIDEntry *cid = &ff_dnxhd_cid_table[i];
+    for (i = 0; i < FF_ARRAY_ELEMS(dnxhd_cid_table); i++) {
+        const CIDEntry *cid = &dnxhd_cid_table[i];
         int interlaced = cid->flags & DNXHD_INTERLACED ? 1 : 0;
         if (cid->width == avctx->width && cid->height == avctx->height &&
             interlaced == !!(avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) &&
@@ -1163,8 +1163,8 @@ int ff_dnxhd_find_cid(AVCodecContext *avctx, int bit_depth)
 void ff_dnxhd_print_profiles(AVCodecContext *avctx, int loglevel)
 {
     int i, j;
-    for (i = 0; i < FF_ARRAY_ELEMS(ff_dnxhd_cid_table); i++) {
-        const CIDEntry *cid = &ff_dnxhd_cid_table[i];
+    for (i = 0; i < FF_ARRAY_ELEMS(dnxhd_cid_table); i++) {
+        const CIDEntry *cid = &dnxhd_cid_table[i];
         for (j = 0; j < FF_ARRAY_ELEMS(cid->bit_rates); j++) {
             if (!cid->bit_rates[j])
                 break;
",1,libavcodec/dnxhddata.c,46,java,ffmpeg___ffmpeg,test
5680,26759,b8624931a990d00fa0b5582711fe088b9a1e9c70,"@@ -1934,8 +1934,8 @@ void RuntimeOption::Load(
                    ""Eval.Debugger.SignalTimeout"", 1);
       Config::Bind(DebuggerDefaultRpcPort, ini, config,
                    ""Eval.Debugger.RPC.DefaultPort"", 8083);
-      Config::Bind(DebuggerDefaultRpcAuth, ini, config,
-                   ""Eval.Debugger.RPC.DefaultAuth"");
+      DebuggerDefaultRpcAuth =
+        Config::GetString(ini, config, ""Eval.Debugger.RPC.DefaultAuth"");
       Config::Bind(DebuggerRpcHostDomain, ini, config,
                    ""Eval.Debugger.RPC.HostDomain"");
       Config::Bind(DebuggerDefaultRpcTimeout, ini, config,
@@ -2490,10 +2490,10 @@ void RuntimeOption::Load(
                  ""AdminServer.EnableSSLWithPlainText"", false);
     Config::Bind(AdminServerStatsNeedPassword, ini, config,
                  ""AdminServer.StatsNeedPassword"", AdminServerStatsNeedPassword);
-    Config::Bind(AdminPassword, ini, config, ""AdminServer.Password"");
-    Config::Bind(AdminPasswords, ini, config, ""AdminServer.Passwords"");
-    Config::Bind(HashedAdminPasswords, ini, config,
-                 ""AdminServer.HashedPasswords"");
+    AdminPassword = Config::GetString(ini, config, ""AdminServer.Password"");
+    AdminPasswords = Config::GetSet(ini, config, ""AdminServer.Passwords"");
+    HashedAdminPasswords =
+      Config::GetSet(ini, config, ""AdminServer.HashedPasswords"");
   }
   {
     // Proxy
",1,hphp/runtime/base/runtime-option.cpp,12,java,facebook___hhvm,test
5301,24975,28f785daa03e3c833484c47220785e4feccc9114,"@@ -22,7 +22,8 @@
 #include <grub/mm.h>
 #include <grub/partition.h>
 #include <grub/dl.h>
-
+#include <r_types.h>
+R_PACKED(
 struct grub_amiga_rdsk
 {
   /* ""RDSK"".  */
@@ -37,8 +38,9 @@ struct grub_amiga_rdsk
   grub_uint32_t fslst;
 
   /* The other information is not important for us.  */
-} __attribute__ ((packed));
+});
 
+R_PACKED(
 struct grub_amiga_partition
 {
   /* ""PART"".  */
@@ -63,7 +65,7 @@ struct grub_amiga_partition
   grub_uint32_t highcyl;
 
   grub_uint32_t firstcyl;
-} __attribute__ ((packed));
+});
 
 struct grub_partition_map grub_amiga_partition_map;
 
@@ -141,13 +143,3 @@ struct grub_partition_map grub_amiga_partition_map =
     .name = ""amiga"",
     .iterate = amiga_partition_map_iterate,
   };
-
-GRUB_MOD_INIT(part_amiga)
-{
-  grub_partition_map_register (&grub_amiga_partition_map);
-}
-
-GRUB_MOD_FINI(part_amiga)
-{
-  grub_partition_map_unregister (&grub_amiga_partition_map);
-}
",1,shlr/grub/partmap/amiga.c,18,java,radare___radare2,test
363,1746,b6b75a99dab760c902c3d355519e0dc2616872e1,"@@ -487,6 +487,10 @@ static inline void bitmap_directory_to_be(uint8_t *dir, size_t size)
 
 static void bitmap_free(Qcow2Bitmap *bm)
 {
+    if (bm == NULL) {
+        return;
+    }
+
     g_free(bm->name);
     g_free(bm);
 }
",0,block/qcow2-bitmap.c,4,java,qemu___qemu,test
5603,26404,77dd114513d7796e1e2b8aece214a380af26fbf4,"@@ -123,6 +123,11 @@ class LoadAndRemapMatrixOp : public OpKernel {
     // Processes the checkpoint source and the provided Tensor name.
     const Tensor* ckpt_path_t;
     OP_REQUIRES_OK(context, context->input(""ckpt_path"", &ckpt_path_t));
+    OP_REQUIRES(
+        context, ckpt_path_t->NumElements() == 1,
+        errors::InvalidArgument(""The `ckpt_path` tensor must have exactly one ""
+                                ""element, got tensor of shape "",
+                                ckpt_path_t->shape().DebugString()));
     const string& ckpt_path = ckpt_path_t->scalar<tstring>()();
     const Tensor* old_tensor_name_t;
     OP_REQUIRES_OK(context,
",0,tensorflow/core/kernels/load_and_remap_matrix_op.cc,5,java,tensorflow___tensorflow,test
9396,44706,04e8cd58f075bec5892e369c8deebca9c67e855c,"@@ -132,32 +132,32 @@ WORD32 ixheaacd_qmf_hbe_data_reinit(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,
             (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;
         ptr_hbe_txposer->analy_cos_sin_tab =
             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;
-        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
-        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
+        ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
+        ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
         break;
       case 8:
         ptr_hbe_txposer->synth_cos_tab =
             (FLOAT32 *)ixheaacd_synth_cos_table_kl_8;
         ptr_hbe_txposer->analy_cos_sin_tab =
             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_16;
-        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
-        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
+        ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
+        ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
         break;
       case 12:
         ptr_hbe_txposer->synth_cos_tab =
             (FLOAT32 *)ixheaacd_synth_cos_table_kl_12;
         ptr_hbe_txposer->analy_cos_sin_tab =
             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_24;
-        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;
-        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;
+        ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;
+        ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;
         break;
       case 16:
         ptr_hbe_txposer->synth_cos_tab =
             (FLOAT32 *)ixheaacd_synth_cos_table_kl_16;
         ptr_hbe_txposer->analy_cos_sin_tab =
             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_32;
-        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
-        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
+        ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
+        ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
         break;
       case 20:
         ptr_hbe_txposer->synth_cos_tab =
@@ -170,8 +170,8 @@ WORD32 ixheaacd_qmf_hbe_data_reinit(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,
             (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;
         ptr_hbe_txposer->analy_cos_sin_tab =
             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;
-        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
-        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
+        ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
+        ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
     }
 
     ptr_hbe_txposer->synth_wind_coeff = ixheaacd_map_prot_filter(synth_size);
@@ -213,9 +213,9 @@ WORD32 ixheaacd_qmf_hbe_data_reinit(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,
         break;
       }
     }
-  }
-  if (ptr_hbe_txposer->k_start < 0) {
-    return -1;
+    if (ptr_hbe_txposer->k_start < 0) {
+      return -1;
+    }
   }
   return 0;
 }
",0,decoder/ixheaacd_hbe_trans.c,26,java,platform___external___libxaac,test
2864,13637,4d74d8a00b07441cba090a02e0dd9ed385145bf4,"@@ -46,7 +46,8 @@ class SoftmaxXentWithLogitsOp : public OpKernel {
     TensorShape shape_in = logits_in.shape();
 
     BCast bcast(BCast::FromShape(logits_in.shape()),
-                BCast::FromShape(labels_in.shape()));
+                BCast::FromShape(labels_in.shape()),
+                /*fewer_dims_optimization=*/false);
     if (!logits_in.IsSameSize(labels_in)) {
       OP_REQUIRES(context, bcast.IsValid(),
                   errors::InvalidArgument(
@@ -88,20 +89,12 @@ class SoftmaxXentWithLogitsOp : public OpKernel {
                                 {0}, 1, shape_in, &back_out));
     if (shape_in.dim_size(0) > 0) {
       functor::XentFunctor<Device, T> functor;
-      if (logits_in.IsSameSize(labels_in)) {
-        functor(context->eigen_device<Device>(), shape_in.AsEigenDSizes<2>(),
-                Eigen::array<Eigen::DenseIndex, 2>{1, 1},
-                Eigen::array<Eigen::DenseIndex, 2>{1, 1}, logits_in.matrix<T>(),
-                labels_in.matrix<T>(), scratch.matrix<T>(), loss_out->vec<T>(),
-                back_out->matrix<T>());
-      } else {
-        functor(context->eigen_device<Device>(), shape_in.AsEigenDSizes<2>(),
-                BCast::ToIndexArray<2>(bcast.x_bcast()),
-                BCast::ToIndexArray<2>(bcast.y_bcast()),
-                logits_in.template shaped<T, 2>(bcast.x_reshape()),
-                labels_in.template shaped<T, 2>(bcast.y_reshape()),
-                scratch.matrix<T>(), loss_out->vec<T>(), back_out->matrix<T>());
-      }
+      functor(context->eigen_device<Device>(), shape_in.AsEigenDSizes<2>(),
+              BCast::ToIndexArray<2>(bcast.x_bcast()),
+              BCast::ToIndexArray<2>(bcast.y_bcast()),
+              logits_in.template shaped<T, 2>(bcast.x_reshape()),
+              labels_in.template shaped<T, 2>(bcast.y_reshape()),
+              scratch.matrix<T>(), loss_out->vec<T>(), back_out->matrix<T>());
     }
   }
 };
",0,tensorflow/core/kernels/xent_op.cc,23,java,tensorflow___tensorflow,test
8993,42766,f8593c2f492a514b67533a877b716a25d3770418,"@@ -244,6 +244,13 @@ static int vpx_decode(AVCodecContext *avctx,
          (img_alpha = vpx_codec_get_frame(&ctx->decoder_alpha, &iter_alpha)))) {
         uint8_t *planes[4];
         int linesizes[4];
+
+        if (img->d_w > img->w || img->d_h > img->h) {
+            av_log(avctx, AV_LOG_ERROR, ""Display dimensions %dx%d exceed storage %dx%d\n"",
+                   img->d_w, img->d_h, img->w, img->h);
+            return AVERROR_EXTERNAL;
+        }
+
         if ((ret = set_pix_fmt(avctx, img, ctx->has_alpha_channel)) < 0) {
 #ifdef VPX_IMG_FMT_HIGHBITDEPTH
             av_log(avctx, AV_LOG_ERROR, ""Unsupported output colorspace (%d) / bit_depth (%d)\n"",
",0,libavcodec/libvpxdec.c,7,java,ffmpeg___ffmpeg,test
8940,42479,35ec2bc6d467c218fb068a9aaf60b4aa2bea7b63,"@@ -10526,6 +10526,7 @@ static int rsa_pss_test(WC_RNG* rng, RsaKey* key)
 #ifdef RSA_PSS_TEST_WRONG_PARAMS
     int              k, l;
 #endif
+    int              len;
     byte*            plain;
     int              mgf[]   = {
 #ifndef NO_SHA
@@ -10722,6 +10723,11 @@ static int rsa_pss_test(WC_RNG* rng, RsaKey* key)
     /* Test bad salt lengths in various APIs. */
     digestSz = wc_HashGetDigestSize(hash[0]);
     outSz = RSA_TEST_BYTES;
+#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
+    len = -2;
+#else
+    len = -3;
+#endif
     do {
     #if defined(WOLFSSL_ASYNC_CRYPT)
         ret = wc_AsyncWait(ret, &key->asyncDev,
@@ -10729,7 +10735,7 @@ static int rsa_pss_test(WC_RNG* rng, RsaKey* key)
     #endif
         if (ret >= 0) {
             ret = wc_RsaPSS_Sign_ex(digest, digestSz, out, outSz, hash[0],
-                mgf[0], -2, key, rng);
+                mgf[0], len, key, rng);
         }
     } while (ret == WC_PENDING_E);
     if (ret != PSS_SALTLEN_E)
@@ -10777,21 +10783,31 @@ static int rsa_pss_test(WC_RNG* rng, RsaKey* key)
         ERROR_OUT(-6830, exit_rsa_pss);
     TEST_SLEEP();
 
+#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
+    len = -2;
+#else
+    len = -3;
+#endif
 #ifdef HAVE_SELFTEST
     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],
-                                    -2);
+                                    len);
 #else
     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],
-                                    -2, 0);
+                                    len, 0);
 #endif
     if (ret != PSS_SALTLEN_E)
         ERROR_OUT(-6831, exit_rsa_pss);
+#ifndef WOLFSSL_PSS_LONG_SALT
+    len = digestSz + 1;
+#else
+    len = plainSz - digestSz - 1;
+#endif
 #ifdef HAVE_SELFTEST
     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],
-                                    digestSz + 1);
+                                    len);
 #else
     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],
-                                    digestSz + 1, 0);
+                                    len, 0);
 #endif
     if (ret != PSS_SALTLEN_E)
         ERROR_OUT(-6832, exit_rsa_pss);
",1,wolfcrypt/test/test.c,26,java,wolfssl___wolfssl,test
6099,28744,eda079cd2c8ac1217574cd372c7bbcf6f651ccab,"@@ -1117,7 +1117,7 @@ static int whereIndexExprTransNode(Walker *p, Expr *pExpr){
     pExpr->op = TK_COLUMN;
     pExpr->iTable = pX->iIdxCur;
     pExpr->iColumn = pX->iIdxCol;
-    pExpr->pTab = 0;
+    pExpr->y.pTab = 0;
     return WRC_Prune;
   }else{
     return WRC_Continue;
",1,src/wherecode.c,2,java,sqlite___sqlite,test
1265,6120,2210cd92a6237a9ff82b58cfbe0c58da25ce1e11,"@@ -14,7 +14,7 @@ bool stream_callback(pb_istream_t *stream, uint8_t *buf, size_t count)
 {
     if (stream->state != NULL)
         return false; /* Simulate error */
-    
+
     if (buf != NULL)
         memset(buf, 'x', count);
     return true;
@@ -26,28 +26,28 @@ bool callback_check(pb_istream_t *stream, const pb_field_t *field, void **arg)
     int i;
     uint8_t byte;
     pb_bytes_array_t *ref = (pb_bytes_array_t*) *arg;
-    
+
     for (i = 0; i < ref->size; i++)
     {
         if (!pb_read(stream, &byte, 1))
             return false;
-        
+
         if (byte != ref->bytes[i])
             return false;
     }
-    
+
     return true;
 }
 
 int main()
 {
     int status = 0;
-    
+
     {
         uint8_t buffer1[] = ""foobartest1234"";
         uint8_t buffer2[sizeof(buffer1)];
         pb_istream_t stream = pb_istream_from_buffer(buffer1, sizeof(buffer1));
-        
+
         COMMENT(""Test pb_read and pb_istream_t"");
         TEST(pb_read(&stream, buffer2, 6))
         TEST(memcmp(buffer2, ""foobar"", 6) == 0)
@@ -57,11 +57,11 @@ int main()
         TEST(stream.bytes_left == 0)
         TEST(!pb_read(&stream, buffer2, 1))
     }
-    
+
     {
         uint8_t buffer[20];
         pb_istream_t stream = {&stream_callback, NULL, 20};
-        
+
         COMMENT(""Test pb_read with custom callback"");
         TEST(pb_read(&stream, buffer, 5))
         TEST(memcmp(buffer, ""xxxxx"", 5) == 0)
@@ -71,12 +71,12 @@ int main()
         stream.state = NULL;
         TEST(pb_read(&stream, buffer, 15))
     }
-    
+
     {
         pb_istream_t s;
         uint64_t u;
         int64_t i;
-        
+
         COMMENT(""Test pb_decode_varint"");
         TEST((s = S(""\x00""), pb_decode_varint(&s, &u) && u == 0));
         TEST((s = S(""\x01""), pb_decode_varint(&s, &u) && u == 1));
@@ -90,11 +90,11 @@ int main()
         TEST((s = S(""\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""),
               !pb_decode_varint(&s, &u)));
     }
-    
+
     {
         pb_istream_t s;
         uint32_t u;
-        
+
         COMMENT(""Test pb_decode_varint32"");
         TEST((s = S(""\x00""), pb_decode_varint32(&s, &u) && u == 0));
         TEST((s = S(""\x01""), pb_decode_varint32(&s, &u) && u == 1));
@@ -105,7 +105,7 @@ int main()
         TEST((s = S(""\xFF\xFF\xFF\xFF\x40""), !pb_decode_varint32(&s, &u)));
         TEST((s = S(""\xFF\xFF\xFF\xFF\xFF\x01""), !pb_decode_varint32(&s, &u)));
     }
-    
+
     {
         pb_istream_t s;
         COMMENT(""Test pb_skip_varint"");
@@ -115,7 +115,7 @@ int main()
               pb_skip_varint(&s) && s.bytes_left == 6))
         TEST((s = S(""\xFF""), !pb_skip_varint(&s)))
     }
-    
+
     {
         pb_istream_t s;
         COMMENT(""Test pb_skip_string"")
@@ -124,123 +124,164 @@ int main()
         TEST((s = S(""\x04""), !pb_skip_string(&s)))
         TEST((s = S(""\xFF""), !pb_skip_string(&s)))
     }
-    
+
     {
         pb_istream_t s = S(""\x01\x00"");
-        pb_field_t f = {1, PB_LTYPE_VARINT, 0, 0, 4, 0, 0};
+        pb_field_iter_t f;
         uint32_t d;
+
+        f.type = PB_LTYPE_VARINT;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
         COMMENT(""Test pb_dec_varint using uint32_t"")
-        TEST(pb_dec_varint(&s, &f, &d) && d == 1)
-        
+        TEST(pb_dec_varint(&s, &f) && d == 1)
+
         /* Verify that no more than data_size is written. */
         d = 0xFFFFFFFF;
         f.data_size = 1;
-        TEST(pb_dec_varint(&s, &f, &d) && (d == 0xFFFFFF00 || d == 0x00FFFFFF))
+        TEST(pb_dec_varint(&s, &f) && (d == 0xFFFFFF00 || d == 0x00FFFFFF))
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 4, 0, 0};
+        pb_field_iter_t f;
         int32_t d;
-        
-        COMMENT(""Test pb_dec_svarint using int32_t"")
-        TEST((s = S(""\x01""), pb_dec_svarint(&s, &f, &d) && d == -1))
-        TEST((s = S(""\x02""), pb_dec_svarint(&s, &f, &d) && d == 1))
-        TEST((s = S(""\xfe\xff\xff\xff\x0f""), pb_dec_svarint(&s, &f, &d) && d == INT32_MAX))
-        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_svarint(&s, &f, &d) && d == INT32_MIN))
+
+        f.type = PB_LTYPE_SVARINT;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
+        COMMENT(""Test pb_dec_varint using sint32_t"")
+        TEST((s = S(""\x01""), pb_dec_varint(&s, &f) && d == -1))
+        TEST((s = S(""\x02""), pb_dec_varint(&s, &f) && d == 1))
+        TEST((s = S(""\xfe\xff\xff\xff\x0f""), pb_dec_varint(&s, &f) && d == INT32_MAX))
+        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_varint(&s, &f) && d == INT32_MIN))
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 8, 0, 0};
+        pb_field_iter_t f;
         int64_t d;
-        
-        COMMENT(""Test pb_dec_svarint using int64_t"")
-        TEST((s = S(""\x01""), pb_dec_svarint(&s, &f, &d) && d == -1))
-        TEST((s = S(""\x02""), pb_dec_svarint(&s, &f, &d) && d == 1))
-        TEST((s = S(""\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""), pb_dec_svarint(&s, &f, &d) && d == INT64_MAX))
-        TEST((s = S(""\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""), pb_dec_svarint(&s, &f, &d) && d == INT64_MIN))
+
+        f.type = PB_LTYPE_SVARINT;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
+        COMMENT(""Test pb_dec_varint using sint64_t"")
+        TEST((s = S(""\x01""), pb_dec_varint(&s, &f) && d == -1))
+        TEST((s = S(""\x02""), pb_dec_varint(&s, &f) && d == 1))
+        TEST((s = S(""\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""), pb_dec_varint(&s, &f) && d == INT64_MAX))
+        TEST((s = S(""\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""), pb_dec_varint(&s, &f) && d == INT64_MIN))
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 4, 0, 0};
+        pb_field_iter_t f;
         int32_t d;
-        
-        COMMENT(""Test pb_dec_svarint overflow detection using int32_t"");
-        TEST((s = S(""\xfe\xff\xff\xff\x0f""), pb_dec_svarint(&s, &f, &d)));
-        TEST((s = S(""\xfe\xff\xff\xff\x10""), !pb_dec_svarint(&s, &f, &d)));
-        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_svarint(&s, &f, &d)));
-        TEST((s = S(""\xff\xff\xff\xff\x10""), !pb_dec_svarint(&s, &f, &d)));
+
+        f.type = PB_LTYPE_SVARINT;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
+        COMMENT(""Test pb_dec_varint overflow detection using sint32_t"");
+        TEST((s = S(""\xfe\xff\xff\xff\x0f""), pb_dec_varint(&s, &f)));
+        TEST((s = S(""\xfe\xff\xff\xff\x10""), !pb_dec_varint(&s, &f)));
+        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_varint(&s, &f)));
+        TEST((s = S(""\xff\xff\xff\xff\x10""), !pb_dec_varint(&s, &f)));
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 4, 0, 0};
+        pb_field_iter_t f;
         uint32_t d;
-        
-        COMMENT(""Test pb_dec_uvarint using uint32_t"")
-        TEST((s = S(""\x01""), pb_dec_uvarint(&s, &f, &d) && d == 1))
-        TEST((s = S(""\x02""), pb_dec_uvarint(&s, &f, &d) && d == 2))
-        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_uvarint(&s, &f, &d) && d == UINT32_MAX))
+
+        f.type = PB_LTYPE_UVARINT;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
+        COMMENT(""Test pb_dec_varint using uint32_t"")
+        TEST((s = S(""\x01""), pb_dec_varint(&s, &f) && d == 1))
+        TEST((s = S(""\x02""), pb_dec_varint(&s, &f) && d == 2))
+        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_varint(&s, &f) && d == UINT32_MAX))
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 8, 0, 0};
+        pb_field_iter_t f;
         uint64_t d;
-        
-        COMMENT(""Test pb_dec_uvarint using uint64_t"")
-        TEST((s = S(""\x01""), pb_dec_uvarint(&s, &f, &d) && d == 1))
-        TEST((s = S(""\x02""), pb_dec_uvarint(&s, &f, &d) && d == 2))
-        TEST((s = S(""\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""), pb_dec_uvarint(&s, &f, &d) && d == UINT64_MAX))
+
+        f.type = PB_LTYPE_UVARINT;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
+        COMMENT(""Test pb_dec_varint using uint64_t"")
+        TEST((s = S(""\x01""), pb_dec_varint(&s, &f) && d == 1))
+        TEST((s = S(""\x02""), pb_dec_varint(&s, &f) && d == 2))
+        TEST((s = S(""\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""), pb_dec_varint(&s, &f) && d == UINT64_MAX))
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 4, 0, 0};
+        pb_field_iter_t f;
         uint32_t d;
-        
-        COMMENT(""Test pb_dec_uvarint overflow detection using int32_t"");
-        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_uvarint(&s, &f, &d)));
-        TEST((s = S(""\xff\xff\xff\xff\x10""), !pb_dec_uvarint(&s, &f, &d)));
+
+        f.type = PB_LTYPE_UVARINT;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
+        COMMENT(""Test pb_dec_varint overflow detection using uint32_t"");
+        TEST((s = S(""\xff\xff\xff\xff\x0f""), pb_dec_varint(&s, &f)));
+        TEST((s = S(""\xff\xff\xff\xff\x10""), !pb_dec_varint(&s, &f)));
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_FIXED32, 0, 0, 4, 0, 0};
+        pb_field_iter_t f;
         float d;
-        
-        COMMENT(""Test pb_dec_fixed32 using float (failures here may be caused by imperfect rounding)"")
-        TEST((s = S(""\x00\x00\x00\x00""), pb_dec_fixed32(&s, &f, &d) && d == 0.0f))
-        TEST((s = S(""\x00\x00\xc6\x42""), pb_dec_fixed32(&s, &f, &d) && d == 99.0f))
-        TEST((s = S(""\x4e\x61\x3c\xcb""), pb_dec_fixed32(&s, &f, &d) && d == -12345678.0f))
+
+        f.type = PB_LTYPE_FIXED32;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
+        COMMENT(""Test pb_dec_fixed using float (failures here may be caused by imperfect rounding)"")
+        TEST((s = S(""\x00\x00\x00\x00""), pb_dec_fixed(&s, &f) && d == 0.0f))
+        TEST((s = S(""\x00\x00\xc6\x42""), pb_dec_fixed(&s, &f) && d == 99.0f))
+        TEST((s = S(""\x4e\x61\x3c\xcb""), pb_dec_fixed(&s, &f) && d == -12345678.0f))
         d = -12345678.0f;
-        TEST((s = S(""\x00""), !pb_dec_fixed32(&s, &f, &d) && d == -12345678.0f))
+        TEST((s = S(""\x00""), !pb_dec_fixed(&s, &f) && d == -12345678.0f))
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_FIXED64, 0, 0, 8, 0, 0};
+        pb_field_iter_t f;
         double d;
-        
+
+        f.type = PB_LTYPE_FIXED64;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
         COMMENT(""Test pb_dec_fixed64 using double (failures here may be caused by imperfect rounding)"")
-        TEST((s = S(""\x00\x00\x00\x00\x00\x00\x00\x00""), pb_dec_fixed64(&s, &f, &d) && d == 0.0))
-        TEST((s = S(""\x00\x00\x00\x00\x00\xc0\x58\x40""), pb_dec_fixed64(&s, &f, &d) && d == 99.0))
-        TEST((s = S(""\x00\x00\x00\xc0\x29\x8c\x67\xc1""), pb_dec_fixed64(&s, &f, &d) && d == -12345678.0f))
+        TEST((s = S(""\x00\x00\x00\x00\x00\x00\x00\x00""), pb_dec_fixed(&s, &f) && d == 0.0))
+        TEST((s = S(""\x00\x00\x00\x00\x00\xc0\x58\x40""), pb_dec_fixed(&s, &f) && d == 99.0))
+        TEST((s = S(""\x00\x00\x00\xc0\x29\x8c\x67\xc1""), pb_dec_fixed(&s, &f) && d == -12345678.0f))
     }
-    
+
     {
         pb_istream_t s;
         struct { pb_size_t size; uint8_t bytes[5]; } d;
-        pb_field_t f = {1, PB_LTYPE_BYTES, 0, 0, sizeof(d), 0, 0};
-        
+        pb_field_iter_t f;
+
+        f.type = PB_LTYPE_BYTES;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
         COMMENT(""Test pb_dec_bytes"")
-        TEST((s = S(""\x00""), pb_dec_bytes(&s, &f, &d) && d.size == 0))
-        TEST((s = S(""\x01\xFF""), pb_dec_bytes(&s, &f, &d) && d.size == 1 && d.bytes[0] == 0xFF))
-        TEST((s = S(""\x05xxxxx""), pb_dec_bytes(&s, &f, &d) && d.size == 5))
-        TEST((s = S(""\x05xxxx""), !pb_dec_bytes(&s, &f, &d)))
-        
+        TEST((s = S(""\x00""), pb_dec_bytes(&s, &f) && d.size == 0))
+        TEST((s = S(""\x01\xFF""), pb_dec_bytes(&s, &f) && d.size == 1 && d.bytes[0] == 0xFF))
+        TEST((s = S(""\x05xxxxx""), pb_dec_bytes(&s, &f) && d.size == 5))
+        TEST((s = S(""\x05xxxx""), !pb_dec_bytes(&s, &f)))
+
         /* Note: the size limit on bytes-fields is not strictly obeyed, as
          * the compiler may add some padding to the struct. Using this padding
          * is not a very good thing to do, but it is difficult to avoid when
@@ -248,24 +289,28 @@ int main()
          * Therefore this tests against a 10-byte string, while otherwise even
          * 6 bytes should error out.
          */
-        TEST((s = S(""\x10xxxxxxxxxx""), !pb_dec_bytes(&s, &f, &d)))
+        TEST((s = S(""\x10xxxxxxxxxx""), !pb_dec_bytes(&s, &f)))
     }
-    
+
     {
         pb_istream_t s;
-        pb_field_t f = {1, PB_LTYPE_STRING, 0, 0, 5, 0, 0};
+        pb_field_iter_t f;
         char d[5];
-        
+
+        f.type = PB_LTYPE_STRING;
+        f.data_size = sizeof(d);
+        f.pData = &d;
+
         COMMENT(""Test pb_dec_string"")
-        TEST((s = S(""\x00""), pb_dec_string(&s, &f, &d) && d[0] == '\0'))
-        TEST((s = S(""\x04xyzz""), pb_dec_string(&s, &f, &d) && strcmp(d, ""xyzz"") == 0))
-        TEST((s = S(""\x05xyzzy""), !pb_dec_string(&s, &f, &d)))
+        TEST((s = S(""\x00""), pb_dec_string(&s, &f) && d[0] == '\0'))
+        TEST((s = S(""\x04xyzz""), pb_dec_string(&s, &f) && strcmp(d, ""xyzz"") == 0))
+        TEST((s = S(""\x05xyzzy""), !pb_dec_string(&s, &f)))
     }
-    
+
     {
         pb_istream_t s;
         IntegerArray dest;
-        
+
         COMMENT(""Testing pb_decode with repeated int32 field"")
         TEST((s = S(""""), pb_decode(&s, IntegerArray_fields, &dest) && dest.data_count == 0))
         TEST((s = S(""\x08\x01\x08\x02""), pb_decode(&s, IntegerArray_fields, &dest)
@@ -275,11 +320,11 @@ int main()
         s = S(""\x08\x01\x08\x02\x08\x03\x08\x04\x08\x05\x08\x06\x08\x07\x08\x08\x08\x09\x08\x0A\x08\x0B"");
         TEST(!pb_decode(&s, IntegerArray_fields, &dest))
     }
-    
+
     {
         pb_istream_t s;
         IntegerArray dest;
-        
+
         COMMENT(""Testing pb_decode with packed int32 field"")
         TEST((s = S(""\x0A\x00""), pb_decode(&s, IntegerArray_fields, &dest)
             && dest.data_count == 0))
@@ -288,16 +333,16 @@ int main()
         TEST((s = S(""\x0A\x0A\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A""), pb_decode(&s, IntegerArray_fields, &dest)
             && dest.data_count == 10 && dest.data[0] == 1 && dest.data[9] == 10))
         TEST((s = S(""\x0A\x0B\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B""), !pb_decode(&s, IntegerArray_fields, &dest)))
-        
+
         /* Test invalid wire data */
         TEST((s = S(""\x0A\xFF""), !pb_decode(&s, IntegerArray_fields, &dest)))
         TEST((s = S(""\x0A\x01""), !pb_decode(&s, IntegerArray_fields, &dest)))
     }
-    
+
     {
         pb_istream_t s;
         IntegerArray dest;
-        
+
         COMMENT(""Testing pb_decode with unknown fields"")
         TEST((s = S(""\x18\x0F\x08\x01""), pb_decode(&s, IntegerArray_fields, &dest)
             && dest.data_count == 1 && dest.data[0] == 1))
@@ -309,14 +354,14 @@ int main()
         TEST((s = S(""\x1D\x00\x00\x00\x00\x08\x01""), pb_decode(&s, IntegerArray_fields, &dest)
             && dest.data_count == 1 && dest.data[0] == 1))
     }
-    
+
     {
         pb_istream_t s;
         CallbackArray dest;
         struct { pb_size_t size; uint8_t bytes[10]; } ref;
         dest.data.funcs.decode = &callback_check;
         dest.data.arg = &ref;
-        
+
         COMMENT(""Testing pb_decode with callbacks"")
         /* Single varint */
         ref.size = 1; ref.bytes[0] = 0x55;
@@ -335,16 +380,16 @@ int main()
         TEST((s = S(""\x09\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA""), pb_decode(&s, CallbackArray_fields, &dest)))
         /* Unsupported field type */
         TEST((s = S(""\x0B\x00""), !pb_decode(&s, CallbackArray_fields, &dest)))
-        
+
         /* Just make sure that our test function works */
         ref.size = 1; ref.bytes[0] = 0x56;
         TEST((s = S(""\x08\x55""), !pb_decode(&s, CallbackArray_fields, &dest)))
     }
-    
+
     {
         pb_istream_t s;
         IntegerArray dest;
-        
+
         COMMENT(""Testing pb_decode message termination"")
         TEST((s = S(""""), pb_decode(&s, IntegerArray_fields, &dest)))
         TEST((s = S(""\x00""), pb_decode(&s, IntegerArray_fields, &dest)))
@@ -352,49 +397,49 @@ int main()
         TEST((s = S(""\x08\x01\x00""), pb_decode(&s, IntegerArray_fields, &dest)))
         TEST((s = S(""\x08""), !pb_decode(&s, IntegerArray_fields, &dest)))
     }
-    
+
     {
         pb_istream_t s;
         IntegerArray dest;
-        
+
         COMMENT(""Testing pb_decode with invalid tag numbers"")
         TEST((s = S(""\x9f\xea""), !pb_decode(&s, IntegerArray_fields, &dest)));
     }
-    
+
     {
         pb_istream_t s;
         IntegerContainer dest = {{0}};
-        
+
         COMMENT(""Testing pb_decode_delimited"")
         TEST((s = S(""\x09\x0A\x07\x0A\x05\x01\x02\x03\x04\x05""),
               pb_decode_delimited(&s, IntegerContainer_fields, &dest)) &&
               dest.submsg.data_count == 5)
     }
-    
+
     {
         pb_istream_t s = {0};
         void *data = NULL;
-        
+
         COMMENT(""Testing allocate_field"")
         TEST(allocate_field(&s, &data, 10, 10) && data != NULL);
         TEST(allocate_field(&s, &data, 10, 20) && data != NULL);
-        
+
         {
             void *oldvalue = data;
             size_t very_big = (size_t)-1;
             size_t somewhat_big = very_big / 2 + 1;
             size_t not_so_big = (size_t)1 << (4 * sizeof(size_t));
-        
+
             TEST(!allocate_field(&s, &data, very_big, 2) && data == oldvalue);
             TEST(!allocate_field(&s, &data, somewhat_big, 2) && data == oldvalue);
             TEST(!allocate_field(&s, &data, not_so_big, not_so_big) && data == oldvalue);
         }
-        
+
         pb_free(data);
     }
-    
+
     if (status != 0)
         fprintf(stdout, ""\n\nSome tests FAILED!\n"");
-    
+
     return status;
 }
",1,tests/decode_unittests/decode_unittests.c,275,java,nanopb___nanopb,test
8543,40565,2d4bc93368f5a0ddb57c8c885cdad9c9b7a10ed5,"@@ -350,7 +350,7 @@ static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
 	return 0;
 
 invalid:
-	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL);
+	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL, NULL);
 	return 0;
 
 nla_put_failure:
@@ -432,7 +432,7 @@ static int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)
 	return 0;
 
 invalid:
-	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL);
+	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL, NULL);
 	return 0;
 
 nla_put_failure:
",1,net/hsr/hsr_netlink.c,4,java,torvalds___linux,test
5918,27894,673ce95d481ea9368c4d4d43ac756ba1d6d9e608,"@@ -47,8 +47,9 @@ void PdfCompositorClient::Composite(
   if (!compositor_)
     Connect(connector);
 
-  mojo::ScopedSharedBufferHandle buffer_handle =
-      mojo::WrapSharedMemoryHandle(handle, data_size, true);
+  mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(
+      handle, data_size,
+      mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);
 
   compositor_->CompositePdf(
       std::move(buffer_handle),
",0,components/printing/service/public/cpp/pdf_compositor_client.cc,5,java,chromium___chromium,test
4355,20424,172a736b155e0d7454a0642c7ed71c02b20711c9,"@@ -24,7 +24,6 @@ limitations under the License.
 #include <queue>
 #include <vector>
 
-#include ""third_party/eigen3/unsupported/Eigen/CXX11/Tensor""
 #include ""tensorflow/core/framework/bounds_check.h""
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/register_types.h""
@@ -33,6 +32,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/lib/core/status.h""
 #include ""tensorflow/core/platform/logging.h""
+#include ""third_party/eigen3/unsupported/Eigen/CXX11/Tensor""
 
 namespace tensorflow {
 namespace {
@@ -111,27 +111,28 @@ static inline void ParseAndCheckCombinedNMSBoxSizes(OpKernelContext* context,
 }
 // Return intersection-over-union overlap between boxes i and j
 template <typename T>
-static inline T IOU(typename TTypes<T, 2>::ConstTensor boxes, int i, int j) {
-  const T ymin_i = std::min<T>(boxes(i, 0), boxes(i, 2));
-  const T xmin_i = std::min<T>(boxes(i, 1), boxes(i, 3));
-  const T ymax_i = std::max<T>(boxes(i, 0), boxes(i, 2));
-  const T xmax_i = std::max<T>(boxes(i, 1), boxes(i, 3));
-  const T ymin_j = std::min<T>(boxes(j, 0), boxes(j, 2));
-  const T xmin_j = std::min<T>(boxes(j, 1), boxes(j, 3));
-  const T ymax_j = std::max<T>(boxes(j, 0), boxes(j, 2));
-  const T xmax_j = std::max<T>(boxes(j, 1), boxes(j, 3));
-  const T area_i = (ymax_i - ymin_i) * (xmax_i - xmin_i);
-  const T area_j = (ymax_j - ymin_j) * (xmax_j - xmin_j);
-  if (area_i <= static_cast<T>(0) || area_j <= static_cast<T>(0)) {
-    return static_cast<T>(0.0);
+static inline float IOU(typename TTypes<T, 2>::ConstTensor boxes, int i,
+                        int j) {
+  const float ymin_i = Eigen::numext::mini<float>(boxes(i, 0), boxes(i, 2));
+  const float xmin_i = Eigen::numext::mini<float>(boxes(i, 1), boxes(i, 3));
+  const float ymax_i = Eigen::numext::maxi<float>(boxes(i, 0), boxes(i, 2));
+  const float xmax_i = Eigen::numext::maxi<float>(boxes(i, 1), boxes(i, 3));
+  const float ymin_j = Eigen::numext::mini<float>(boxes(j, 0), boxes(j, 2));
+  const float xmin_j = Eigen::numext::mini<float>(boxes(j, 1), boxes(j, 3));
+  const float ymax_j = Eigen::numext::maxi<float>(boxes(j, 0), boxes(j, 2));
+  const float xmax_j = Eigen::numext::maxi<float>(boxes(j, 1), boxes(j, 3));
+  const float area_i = (ymax_i - ymin_i) * (xmax_i - xmin_i);
+  const float area_j = (ymax_j - ymin_j) * (xmax_j - xmin_j);
+  if (area_i <= 0 || area_j <= 0) {
+    return 0.0;
   }
-  const T intersection_ymin = std::max<T>(ymin_i, ymin_j);
-  const T intersection_xmin = std::max<T>(xmin_i, xmin_j);
-  const T intersection_ymax = std::min<T>(ymax_i, ymax_j);
-  const T intersection_xmax = std::min<T>(xmax_i, xmax_j);
-  const T intersection_area =
-      std::max<T>(intersection_ymax - intersection_ymin, static_cast<T>(0.0)) *
-      std::max<T>(intersection_xmax - intersection_xmin, static_cast<T>(0.0));
+  const float intersection_ymin = Eigen::numext::maxi<float>(ymin_i, ymin_j);
+  const float intersection_xmin = Eigen::numext::maxi<float>(xmin_i, xmin_j);
+  const float intersection_ymax = Eigen::numext::mini<float>(ymax_i, ymax_j);
+  const float intersection_xmax = Eigen::numext::mini<float>(xmax_i, xmax_j);
+  const float intersection_area =
+      Eigen::numext::maxi<float>(intersection_ymax - intersection_ymin, 0.0) *
+      Eigen::numext::maxi<float>(intersection_xmax - intersection_xmin, 0.0);
   return intersection_area / (area_i + area_j - intersection_area);
 }
 
@@ -142,7 +143,7 @@ static inline T Overlap(typename TTypes<T, 2>::ConstTensor overlaps, int i,
 }
 
 template <typename T>
-static inline std::function<T(int, int)> CreateIOUSimilarityFn(
+static inline std::function<float(int, int)> CreateIOUSimilarityFn(
     const Tensor& boxes) {
   typename TTypes<T, 2>::ConstTensor boxes_data = boxes.tensor<T, 2>();
   return std::bind(&IOU<T>, boxes_data, std::placeholders::_1,
@@ -163,7 +164,7 @@ void DoNonMaxSuppressionOp(OpKernelContext* context, const Tensor& scores,
                            int num_boxes, const Tensor& max_output_size,
                            const T similarity_threshold,
                            const T score_threshold, const T soft_nms_sigma,
-                           const std::function<T(int, int)>& similarity_fn,
+                           const std::function<float(int, int)>& similarity_fn,
                            bool return_scores_tensor = false,
                            bool pad_to_max_output_size = false,
                            int* ptr_num_valid_outputs = nullptr) {
@@ -199,15 +200,15 @@ void DoNonMaxSuppressionOp(OpKernelContext* context, const Tensor& scores,
 
   auto suppress_weight = [similarity_threshold, scale,
                           is_soft_nms](const T sim) {
-    const T weight =
-        static_cast<T>(std::exp(static_cast<float>(scale * sim * sim)));
+    const T weight = Eigen::numext::exp<T>(scale * sim * sim);
     return is_soft_nms || sim <= similarity_threshold ? weight
                                                       : static_cast<T>(0.0);
   };
 
   std::vector<int> selected;
   std::vector<T> selected_scores;
-  T similarity, original_score;
+  float similarity;
+  T original_score;
   Candidate next_candidate;
 
   while (selected.size() < output_size && !candidate_priority_queue.empty()) {
@@ -228,10 +229,10 @@ void DoNonMaxSuppressionOp(OpKernelContext* context, const Tensor& scores,
          j >= next_candidate.suppress_begin_index; --j) {
       similarity = similarity_fn(next_candidate.box_index, selected[j]);
 
-      next_candidate.score *= suppress_weight(similarity);
+      next_candidate.score *= suppress_weight(static_cast<T>(similarity));
 
       // First decide whether to perform hard suppression
-      if (!is_soft_nms && similarity > static_cast<T>(similarity_threshold)) {
+      if (!is_soft_nms && static_cast<T>(similarity) > similarity_threshold) {
         should_hard_suppress = true;
         break;
       }
",1,tensorflow/core/kernels/image/non_max_suppression_op.cc,57,java,tensorflow___tensorflow,test
2516,11994,eda40cc1686162dcd92a97debcbb0df74269651f,"@@ -219,7 +219,7 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
     }
 
     /* On a real system, the first 16k is a `secure boot rom' */
-    memory_region_init_rom_nomigrate(&s->secure_rom, NULL, ""imx31.secure_rom"",
+    memory_region_init_rom(&s->secure_rom, NULL, ""imx31.secure_rom"",
                            FSL_IMX31_SECURE_ROM_SIZE, &err);
     if (err) {
         error_propagate(errp, err);
@@ -229,7 +229,7 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
                                 &s->secure_rom);
 
     /* There is also a 16k ROM */
-    memory_region_init_rom_nomigrate(&s->rom, NULL, ""imx31.rom"",
+    memory_region_init_rom(&s->rom, NULL, ""imx31.rom"",
                            FSL_IMX31_ROM_SIZE, &err);
     if (err) {
         error_propagate(errp, err);
",0,hw/arm/fsl-imx31.c,4,java,qemu___qemu,test
5087,24022,3bb8a96f5348913ee130169504f3642f501b113e,"@@ -943,6 +943,51 @@ static inline void gen_bx(DisasContext *s, TCGv_i32 var)
     store_cpu_field(var, thumb);
 }
 
+/* Set PC and Thumb state from var. var is marked as dead.
+ * For M-profile CPUs, include logic to detect exception-return
+ * branches and handle them. This is needed for Thumb POP/LDM to PC, LDR to PC,
+ * and BX reg, and no others, and happens only for code in Handler mode.
+ */
+static inline void gen_bx_excret(DisasContext *s, TCGv_i32 var)
+{
+    /* Generate the same code here as for a simple bx, but flag via
+     * s->is_jmp that we need to do the rest of the work later.
+     */
+    gen_bx(s, var);
+    if (s->v7m_handler_mode && arm_dc_feature(s, ARM_FEATURE_M)) {
+        s->is_jmp = DISAS_BX_EXCRET;
+    }
+}
+
+static inline void gen_bx_excret_final_code(DisasContext *s)
+{
+    /* Generate the code to finish possible exception return and end the TB */
+    TCGLabel *excret_label = gen_new_label();
+
+    /* Is the new PC value in the magic range indicating exception return? */
+    tcg_gen_brcondi_i32(TCG_COND_GEU, cpu_R[15], 0xff000000, excret_label);
+    /* No: end the TB as we would for a DISAS_JMP */
+    if (is_singlestepping(s)) {
+        gen_singlestep_exception(s);
+    } else {
+        tcg_gen_exit_tb(0);
+    }
+    gen_set_label(excret_label);
+    /* Yes: this is an exception return.
+     * At this point in runtime env->regs[15] and env->thumb will hold
+     * the exception-return magic number, which do_v7m_exception_exit()
+     * will read. Nothing else will be able to see those values because
+     * the cpu-exec main loop guarantees that we will always go straight
+     * from raising the exception to the exception-handling code.
+     *
+     * gen_ss_advance(s) does nothing on M profile currently but
+     * calling it is conceptually the right thing as we have executed
+     * this instruction (compare SWI, HVC, SMC handling).
+     */
+    gen_ss_advance(s);
+    gen_exception_internal(EXCP_EXCEPTION_EXIT);
+}
+
 /* Variant of store_reg which uses branch&exchange logic when storing
    to r15 in ARM architecture v7 and above. The source must be a temporary
    and will be marked as dead. */
@@ -962,7 +1007,7 @@ static inline void store_reg_bx(DisasContext *s, int reg, TCGv_i32 var)
 static inline void store_reg_from_load(DisasContext *s, int reg, TCGv_i32 var)
 {
     if (reg == 15 && ENABLE_ARCH_5) {
-        gen_bx(s, var);
+        gen_bx_excret(s, var);
     } else {
         store_reg(s, reg, var);
     }
@@ -9881,7 +9926,7 @@ static int disas_thumb2_insn(CPUARMState *env, DisasContext *s, uint16_t insn_hw
                         tmp = tcg_temp_new_i32();
                         gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));
                         if (i == 15) {
-                            gen_bx(s, tmp);
+                            gen_bx_excret(s, tmp);
                         } else if (i == rn) {
                             loaded_var = tmp;
                             loaded_base = 1;
@@ -10913,7 +10958,7 @@ static int disas_thumb2_insn(CPUARMState *env, DisasContext *s, uint16_t insn_hw
                 goto illegal_op;
             }
             if (rs == 15) {
-                gen_bx(s, tmp);
+                gen_bx_excret(s, tmp);
             } else {
                 store_reg(s, rs, tmp);
             }
@@ -11103,9 +11148,11 @@ static void disas_thumb_insn(CPUARMState *env, DisasContext *s)
                     tmp2 = tcg_temp_new_i32();
                     tcg_gen_movi_i32(tmp2, val);
                     store_reg(s, 14, tmp2);
+                    gen_bx(s, tmp);
+                } else {
+                    /* Only BX works as exception-return, not BLX */
+                    gen_bx_excret(s, tmp);
                 }
-                /* already thumb, no need to check */
-                gen_bx(s, tmp);
                 break;
             }
             break;
@@ -12000,7 +12047,14 @@ void gen_intermediate_code(CPUARMState *env, TranslationBlock *tb)
        instruction was a conditional branch or trap, and the PC has
        already been written.  */
     gen_set_condexec(dc);
-    if (unlikely(is_singlestepping(dc))) {
+    if (dc->is_jmp == DISAS_BX_EXCRET) {
+        /* Exception return branches need some special case code at the
+         * end of the TB, which is complex enough that it has to
+         * handle the single-step vs not and the condition-failed
+         * insn codepath itself.
+         */
+        gen_bx_excret_final_code(dc);
+    } else if (unlikely(is_singlestepping(dc))) {
         /* Unconditional and ""condition passed"" instruction codepath. */
         switch (dc->is_jmp) {
         case DISAS_SWI:
",1,target/arm/translate.c,66,java,qemu___qemu,test
8273,39069,841b86f3289dbe858daeceec36423d4ea286fac2,"@@ -402,7 +402,7 @@ static int vbi_open(struct saa7146_dev *dev, struct file *file)
 			    sizeof(struct saa7146_buf),
 			    file, &dev->v4l2_lock);
 
-	vv->vbi_read_timeout.function = (TIMER_FUNC_TYPE)vbi_read_timeout;
+	vv->vbi_read_timeout.function = vbi_read_timeout;
 	vv->vbi_read_timeout_file = file;
 
 	/* initialize the brs */
",1,drivers/media/common/saa7146/saa7146_vbi.c,2,java,torvalds___linux,test
388,1873,afb308b9ccbe129608c9205cf3bb39bbefad90b9,"@@ -1187,8 +1187,11 @@ static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *
 {
     OPJ_UINT32 l_data_size;
 
-    /* The +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */
-    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *
+    /* +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */
+    /* and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982 */
+    /* TODO: is there a theoretical upper-bound for the compressed code */
+    /* block size ? */
+    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *
                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));
 
     if (l_data_size > p_code_block->data_size) {
",0,src/lib/openjp2/tcd.c,7,java,uclouvain___openjpeg,test
3706,17514,b25b387fa5928e516cb2c9e7fde68e958bd7e50a,"@@ -37,6 +37,9 @@
 #include ""qemu/option_int.h""
 #include ""qemu/cutils.h""
 #include ""qemu/bswap.h""
+#include ""qapi/opts-visitor.h""
+#include ""qapi-visit.h""
+#include ""block/crypto.h""
 
 /*
   Differences with QCOW:
@@ -461,6 +464,7 @@ static QemuOptsList qcow2_runtime_opts = {
             .type = QEMU_OPT_NUMBER,
             .help = ""Clean unused cache entries after this time (in seconds)"",
         },
+        BLOCK_CRYPTO_OPT_DEF_QCOW_KEY_SECRET(""encrypt.""),
         { /* end of list */ }
     },
 };
@@ -585,6 +589,7 @@ typedef struct Qcow2ReopenState {
     int overlap_check;
     bool discard_passthrough[QCOW2_DISCARD_MAX];
     uint64_t cache_clean_interval;
+    QCryptoBlockOpenOptions *crypto_opts; /* Disk encryption runtime options */
 } Qcow2ReopenState;
 
 static int qcow2_update_options_prepare(BlockDriverState *bs,
@@ -598,9 +603,14 @@ static int qcow2_update_options_prepare(BlockDriverState *bs,
     int overlap_check_template = 0;
     uint64_t l2_cache_size, refcount_cache_size;
     int i;
+    const char *encryptfmt;
+    QDict *encryptopts = NULL;
     Error *local_err = NULL;
     int ret;
 
+    qdict_extract_subqdict(options, &encryptopts, ""encrypt."");
+    encryptfmt = qdict_get_try_str(encryptopts, ""format"");
+
     opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);
     qemu_opts_absorb_qdict(opts, options, &local_err);
     if (local_err) {
@@ -751,8 +761,42 @@ static int qcow2_update_options_prepare(BlockDriverState *bs,
     r->discard_passthrough[QCOW2_DISCARD_OTHER] =
         qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);
 
+    switch (s->crypt_method_header) {
+    case QCOW_CRYPT_NONE:
+        if (encryptfmt) {
+            error_setg(errp, ""No encryption in image header, but options ""
+                       ""specified format '%s'"", encryptfmt);
+            ret = -EINVAL;
+            goto fail;
+        }
+        break;
+
+    case QCOW_CRYPT_AES:
+        if (encryptfmt && !g_str_equal(encryptfmt, ""aes"")) {
+            error_setg(errp,
+                       ""Header reported 'aes' encryption format but ""
+                       ""options specify '%s'"", encryptfmt);
+            ret = -EINVAL;
+            goto fail;
+        }
+        qdict_del(encryptopts, ""format"");
+        r->crypto_opts = block_crypto_open_opts_init(
+            Q_CRYPTO_BLOCK_FORMAT_QCOW, encryptopts, errp);
+        break;
+
+    default:
+        error_setg(errp, ""Unsupported encryption method %d"",
+                   s->crypt_method_header);
+        break;
+    }
+    if (s->crypt_method_header != QCOW_CRYPT_NONE && !r->crypto_opts) {
+        ret = -EINVAL;
+        goto fail;
+    }
+
     ret = 0;
 fail:
+    QDECREF(encryptopts);
     qemu_opts_del(opts);
     opts = NULL;
     return ret;
@@ -785,6 +829,9 @@ static void qcow2_update_options_commit(BlockDriverState *bs,
         s->cache_clean_interval = r->cache_clean_interval;
         cache_clean_timer_init(bs, bdrv_get_aio_context(bs));
     }
+
+    qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
+    s->crypto_opts = r->crypto_opts;
 }
 
 static void qcow2_update_options_abort(BlockDriverState *bs,
@@ -796,6 +843,7 @@ static void qcow2_update_options_abort(BlockDriverState *bs,
     if (r->refcount_block_cache) {
         qcow2_cache_destroy(bs, r->refcount_block_cache);
     }
+    qapi_free_QCryptoBlockOpenOptions(r->crypto_opts);
 }
 
 static int qcow2_update_options(BlockDriverState *bs, QDict *options,
@@ -967,12 +1015,6 @@ static int qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
         ret = -EINVAL;
         goto fail;
     }
-    if (!qcrypto_cipher_supports(QCRYPTO_CIPHER_ALG_AES_128,
-                                 QCRYPTO_CIPHER_MODE_CBC)) {
-        error_setg(errp, ""AES cipher not available"");
-        ret = -EINVAL;
-        goto fail;
-    }
     s->crypt_method_header = header.crypt_method;
     if (s->crypt_method_header) {
         if (bdrv_uses_whitelist() &&
@@ -990,6 +1032,7 @@ static int qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
         }
 
         bs->encrypted = true;
+        bs->valid_key = true;
     }
 
     s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */
@@ -1122,6 +1165,19 @@ static int qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
         goto fail;
     }
 
+    if (s->crypt_method_header == QCOW_CRYPT_AES) {
+        unsigned int cflags = 0;
+        if (flags & BDRV_O_NO_IO) {
+            cflags |= QCRYPTO_BLOCK_OPEN_NO_IO;
+        }
+        s->crypto = qcrypto_block_open(s->crypto_opts, NULL, NULL,
+                                       cflags, errp);
+        if (!s->crypto) {
+            ret = -EINVAL;
+            goto fail;
+        }
+    }
+
     /* read the backing file name */
     if (header.backing_file_offset != 0) {
         len = header.backing_file_size;
@@ -1202,6 +1258,8 @@ static int qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
     }
     g_free(s->cluster_cache);
     qemu_vfree(s->cluster_data);
+    qcrypto_block_free(s->crypto);
+    qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
     return ret;
 }
 
@@ -1229,41 +1287,6 @@ static void qcow2_refresh_limits(BlockDriverState *bs, Error **errp)
     bs->bl.pdiscard_alignment = s->cluster_size;
 }
 
-static int qcow2_set_key(BlockDriverState *bs, const char *key)
-{
-    BDRVQcow2State *s = bs->opaque;
-    uint8_t keybuf[16];
-    int len, i;
-    Error *err = NULL;
-
-    memset(keybuf, 0, 16);
-    len = strlen(key);
-    if (len > 16)
-        len = 16;
-    /* XXX: we could compress the chars to 7 bits to increase
-       entropy */
-    for(i = 0;i < len;i++) {
-        keybuf[i] = key[i];
-    }
-    assert(bs->encrypted);
-
-    qcrypto_cipher_free(s->cipher);
-    s->cipher = qcrypto_cipher_new(
-        QCRYPTO_CIPHER_ALG_AES_128,
-        QCRYPTO_CIPHER_MODE_CBC,
-        keybuf, G_N_ELEMENTS(keybuf),
-        &err);
-
-    if (!s->cipher) {
-        /* XXX would be nice if errors in this method could
-         * be properly propagate to the caller. Would need
-         * the bdrv_set_key() API signature to be fixed. */
-        error_free(err);
-        return -1;
-    }
-    return 0;
-}
-
 static int qcow2_reopen_prepare(BDRVReopenState *state,
                                 BlockReopenQueue *queue, Error **errp)
 {
@@ -1379,7 +1402,7 @@ static int64_t coroutine_fn qcow2_co_get_block_status(BlockDriverState *bs,
     *pnum = bytes >> BDRV_SECTOR_BITS;
 
     if (cluster_offset != 0 && ret != QCOW2_CLUSTER_COMPRESSED &&
-        !s->cipher) {
+        !s->crypto) {
         index_in_cluster = sector_num & (s->cluster_sectors - 1);
         cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);
         *file = bs->file->bs;
@@ -1436,7 +1459,7 @@ static coroutine_fn int qcow2_co_preadv(BlockDriverState *bs, uint64_t offset,
 
         /* prepare next request */
         cur_bytes = MIN(bytes, INT_MAX);
-        if (s->cipher) {
+        if (s->crypto) {
             cur_bytes = MIN(cur_bytes,
                             QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);
         }
@@ -1506,7 +1529,7 @@ static coroutine_fn int qcow2_co_preadv(BlockDriverState *bs, uint64_t offset,
             }
 
             if (bs->encrypted) {
-                assert(s->cipher);
+                assert(s->crypto);
 
                 /*
                  * For encrypted images, read everything into a temporary
@@ -1538,14 +1561,15 @@ static coroutine_fn int qcow2_co_preadv(BlockDriverState *bs, uint64_t offset,
                 goto fail;
             }
             if (bs->encrypted) {
-                assert(s->cipher);
+                assert(s->crypto);
                 assert((offset & (BDRV_SECTOR_SIZE - 1)) == 0);
                 assert((cur_bytes & (BDRV_SECTOR_SIZE - 1)) == 0);
                 Error *err = NULL;
-                if (qcow2_encrypt_sectors(s, offset >> BDRV_SECTOR_BITS,
+                if (qcrypto_block_decrypt(s->crypto,
+                                          offset >> BDRV_SECTOR_BITS,
                                           cluster_data,
-                                          cur_bytes >> BDRV_SECTOR_BITS,
-                                          false, &err) < 0) {
+                                          cur_bytes,
+                                          &err) < 0) {
                     error_free(err);
                     ret = -EIO;
                     goto fail;
@@ -1661,7 +1685,7 @@ static coroutine_fn int qcow2_co_pwritev(BlockDriverState *bs, uint64_t offset,
 
         if (bs->encrypted) {
             Error *err = NULL;
-            assert(s->cipher);
+            assert(s->crypto);
             if (!cluster_data) {
                 cluster_data = qemu_try_blockalign(bs->file->bs,
                                                    QCOW_MAX_CRYPT_CLUSTERS
@@ -1676,10 +1700,9 @@ static coroutine_fn int qcow2_co_pwritev(BlockDriverState *bs, uint64_t offset,
                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);
             qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);
 
-            if (qcow2_encrypt_sectors(s, offset >> BDRV_SECTOR_BITS,
+            if (qcrypto_block_encrypt(s->crypto, offset >> BDRV_SECTOR_BITS,
                                       cluster_data,
-                                      cur_bytes >>BDRV_SECTOR_BITS,
-                                      true, &err) < 0) {
+                                      cur_bytes, &err) < 0) {
                 error_free(err);
                 ret = -EIO;
                 goto fail;
@@ -1804,8 +1827,8 @@ static void qcow2_close(BlockDriverState *bs)
     qcow2_cache_destroy(bs, s->l2_table_cache);
     qcow2_cache_destroy(bs, s->refcount_block_cache);
 
-    qcrypto_cipher_free(s->cipher);
-    s->cipher = NULL;
+    qcrypto_block_free(s->crypto);
+    s->crypto = NULL;
 
     g_free(s->unknown_header_fields);
     cleanup_unknown_header_ext(bs);
@@ -1823,7 +1846,7 @@ static void qcow2_invalidate_cache(BlockDriverState *bs, Error **errp)
 {
     BDRVQcow2State *s = bs->opaque;
     int flags = s->flags;
-    QCryptoCipher *cipher = NULL;
+    QCryptoBlock *crypto = NULL;
     QDict *options;
     Error *local_err = NULL;
     int ret;
@@ -1833,8 +1856,8 @@ static void qcow2_invalidate_cache(BlockDriverState *bs, Error **errp)
      * that means we don't have to worry about reopening them here.
      */
 
-    cipher = s->cipher;
-    s->cipher = NULL;
+    crypto = s->crypto;
+    s->crypto = NULL;
 
     qcow2_close(bs);
 
@@ -1855,7 +1878,7 @@ static void qcow2_invalidate_cache(BlockDriverState *bs, Error **errp)
         return;
     }
 
-    s->cipher = cipher;
+    s->crypto = crypto;
 }
 
 static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
@@ -2079,6 +2102,56 @@ static int qcow2_change_backing_file(BlockDriverState *bs,
     return qcow2_update_header(bs);
 }
 
+
+static int qcow2_set_up_encryption(BlockDriverState *bs, const char *encryptfmt,
+                                   QemuOpts *opts, Error **errp)
+{
+    BDRVQcow2State *s = bs->opaque;
+    QCryptoBlockCreateOptions *cryptoopts = NULL;
+    QCryptoBlock *crypto = NULL;
+    int ret = -EINVAL;
+    QDict *options, *encryptopts;
+
+    options = qemu_opts_to_qdict(opts, NULL);
+    qdict_extract_subqdict(options, &encryptopts, ""encrypt."");
+    QDECREF(options);
+
+    if (!g_str_equal(encryptfmt, ""aes"")) {
+        error_setg(errp, ""Unknown encryption format '%s', expected 'aes'"",
+                   encryptfmt);
+        ret = -EINVAL;
+        goto out;
+    }
+    cryptoopts = block_crypto_create_opts_init(
+        Q_CRYPTO_BLOCK_FORMAT_QCOW, encryptopts, errp);
+    if (!cryptoopts) {
+        ret = -EINVAL;
+        goto out;
+    }
+    s->crypt_method_header = QCOW_CRYPT_AES;
+
+    crypto = qcrypto_block_create(cryptoopts,
+                                  NULL, NULL,
+                                  bs, errp);
+    if (!crypto) {
+        ret = -EINVAL;
+        goto out;
+    }
+
+    ret = qcow2_update_header(bs);
+    if (ret < 0) {
+        error_setg_errno(errp, -ret, ""Could not write encryption header"");
+        goto out;
+    }
+
+ out:
+    QDECREF(encryptopts);
+    qcrypto_block_free(crypto);
+    qapi_free_QCryptoBlockCreateOptions(cryptoopts);
+    return ret;
+}
+
+
 static int preallocate(BlockDriverState *bs)
 {
     uint64_t bytes;
@@ -2273,17 +2346,8 @@ static int qcow2_create2(const char *filename, int64_t total_size,
         .header_length              = cpu_to_be32(sizeof(*header)),
     };
 
-    if (encryptfmt) {
-        if (!g_str_equal(encryptfmt, ""aes"")) {
-            error_setg(errp, ""Unknown encryption format '%s', expected 'aes'"",
-                       encryptfmt);
-            ret = -EINVAL;
-            goto out;
-        }
-        header->crypt_method = cpu_to_be32(QCOW_CRYPT_AES);
-    } else {
-        header->crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
-    }
+    /* We'll update this to correct value later */
+    header->crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
 
     if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {
         header->compatible_features |=
@@ -2362,6 +2426,14 @@ static int qcow2_create2(const char *filename, int64_t total_size,
         }
     }
 
+    /* Want encryption? There you go. */
+    if (encryptfmt) {
+        ret = qcow2_set_up_encryption(blk_bs(blk), encryptfmt, opts, errp);
+        if (ret < 0) {
+            goto out;
+        }
+    }
+
     /* And if we're supposed to preallocate metadata, do that now */
     if (prealloc != PREALLOC_MODE_OFF) {
         BDRVQcow2State *s = blk_bs(blk)->opaque;
@@ -2377,11 +2449,17 @@ static int qcow2_create2(const char *filename, int64_t total_size,
     blk_unref(blk);
     blk = NULL;
 
-    /* Reopen the image without BDRV_O_NO_FLUSH to flush it before returning */
+    /* Reopen the image without BDRV_O_NO_FLUSH to flush it before returning.
+     * Using BDRV_O_NO_IO, since encryption is now setup we don't want to
+     * have to setup decryption context. We're not doing any I/O on the top
+     * level BlockDriverState, only lower layers, where BDRV_O_NO_IO does
+     * not have effect.
+     */
     options = qdict_new();
     qdict_put_str(options, ""driver"", ""qcow2"");
     blk = blk_new_open(filename, NULL, options,
-                       BDRV_O_RDWR | BDRV_O_NO_BACKING, &local_err);
+                       BDRV_O_RDWR | BDRV_O_NO_BACKING | BDRV_O_NO_IO,
+                       &local_err);
     if (blk == NULL) {
         error_propagate(errp, local_err);
         ret = -EIO;
@@ -3226,9 +3304,9 @@ static int qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,
             backing_format = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);
         } else if (!strcmp(desc->name, BLOCK_OPT_ENCRYPT)) {
             encrypt = qemu_opt_get_bool(opts, BLOCK_OPT_ENCRYPT,
-                                        !!s->cipher);
+                                        !!s->crypto);
 
-            if (encrypt != !!s->cipher) {
+            if (encrypt != !!s->crypto) {
                 error_report(""Changing the encryption flag is not supported"");
                 return -ENOTSUP;
             }
@@ -3454,6 +3532,7 @@ static QemuOptsList qcow2_create_opts = {
             .type = QEMU_OPT_STRING,
             .help = ""Encrypt the image, format choices: 'aes'"",
         },
+        BLOCK_CRYPTO_OPT_DEF_QCOW_KEY_SECRET(""encrypt.""),
         {
             .name = BLOCK_OPT_CLUSTER_SIZE,
             .type = QEMU_OPT_SIZE,
@@ -3496,7 +3575,6 @@ BlockDriver bdrv_qcow2 = {
     .bdrv_create        = qcow2_create,
     .bdrv_has_zero_init = bdrv_has_zero_init_1,
     .bdrv_co_get_block_status = qcow2_co_get_block_status,
-    .bdrv_set_key       = qcow2_set_key,
 
     .bdrv_co_preadv         = qcow2_co_preadv,
     .bdrv_co_pwritev        = qcow2_co_pwritev,
",1,block/qcow2.c,226,java,qemu___qemu,test
1216,5874,7ee6a39c6a1939b376545f030a5efd6f90913583,"@@ -2,7 +2,7 @@
 
 /*
 Maddy Mail Server - Composable all-in-one email server.
-Copyright  2019-2020 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server contributors
+Copyright  2019-2022 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server contributors
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -66,6 +66,19 @@ struct error_obj run_pam_auth(const char *username, char *password) {
         return ret_val;
     }
 
+    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);
+    if (status != PAM_SUCCESS) {
+        struct error_obj ret_val;
+        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {
+            ret_val.status = 1;
+        } else {
+            ret_val.status = 2;
+        }
+        ret_val.func_name = ""pam_acct_mgmt"";
+        ret_val.error_msg = pam_strerror(local_auth, status);
+        return ret_val;
+    }
+
     status = pam_end(local_auth, status);
     if (status != PAM_SUCCESS) {
         struct error_obj ret_val;
",0,internal/auth/pam/pam.c,15,java,foxcpp___maddy,test
6319,29780,3cde5ea211ead04997e2ecd7f8bdc831f84700e6,"@@ -174,7 +174,7 @@ static void net_socket_send(void *opaque)
         closesocket(s->fd);
 
         s->fd = -1;
-        net_socket_rs_init(&s->rs, net_socket_rs_finalize);
+        net_socket_rs_init(&s->rs, net_socket_rs_finalize, false);
         s->nc.link_down = true;
         memset(s->nc.info_str, 0, sizeof(s->nc.info_str));
 
@@ -366,7 +366,7 @@ static NetSocketState *net_socket_fd_init_dgram(NetClientState *peer,
     s->fd = fd;
     s->listen_fd = -1;
     s->send_fn = net_socket_send_dgram;
-    net_socket_rs_init(&s->rs, net_socket_rs_finalize);
+    net_socket_rs_init(&s->rs, net_socket_rs_finalize, false);
     net_socket_read_poll(s, true);
 
     /* mcast: save bound address as dst */
@@ -417,7 +417,7 @@ static NetSocketState *net_socket_fd_init_stream(NetClientState *peer,
 
     s->fd = fd;
     s->listen_fd = -1;
-    net_socket_rs_init(&s->rs, net_socket_rs_finalize);
+    net_socket_rs_init(&s->rs, net_socket_rs_finalize, false);
 
     /* Disable Nagle algorithm on TCP sockets to reduce latency */
     socket_set_nodelay(fd);
@@ -522,7 +522,7 @@ static int net_socket_listen_init(NetClientState *peer,
     s->fd = -1;
     s->listen_fd = fd;
     s->nc.link_down = true;
-    net_socket_rs_init(&s->rs, net_socket_rs_finalize);
+    net_socket_rs_init(&s->rs, net_socket_rs_finalize, false);
 
     qemu_set_fd_handler(s->listen_fd, net_socket_accept, NULL, s);
     return 0;
",1,net/socket.c,8,java,qemu___qemu,test
879,4152,f2c3931113eaafe9ef558faaddd48e00a6606235,"@@ -71,6 +71,15 @@ class ParallelConcatUpdate : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     auto value = ctx->input(0);
+    // Value should be at least rank 1. Also the 0th dimension should be
+    // at least loc_.
+    OP_REQUIRES(ctx, value.dims() >= 1,
+                errors::InvalidArgument(""value should be at least rank 1.""));
+    OP_REQUIRES(
+        ctx, value.dim_size(0) > loc_,
+        errors::InvalidArgument(""0th dimension of value = "", value.dim_size(0),
+                                "" is less than loc_="", loc_));
+
     auto update = ctx->input(1);
 
     OP_REQUIRES(
",0,tensorflow/core/kernels/inplace_ops.cc,9,java,tensorflow___tensorflow,test
7959,37526,f3ced3c59287dabc253f83f0c70aa4934470c15e,"@@ -346,7 +346,7 @@ struct CPUState {
 
     void *env_ptr; /* CPUArchState */
 
-    /* Writes protected by tb_lock, reads not thread-safe  */
+    /* Accessed in parallel; all accesses must be atomic */
     struct TranslationBlock *tb_jmp_cache[TB_JMP_CACHE_SIZE];
 
     struct GDBRegisterState *gdb_regs;
@@ -422,6 +422,15 @@ extern struct CPUTailQ cpus;
 
 extern __thread CPUState *current_cpu;
 
+static inline void cpu_tb_jmp_cache_clear(CPUState *cpu)
+{
+    unsigned int i;
+
+    for (i = 0; i < TB_JMP_CACHE_SIZE; i++) {
+        atomic_set(&cpu->tb_jmp_cache[i], NULL);
+    }
+}
+
 /**
  * qemu_tcg_mttcg_enabled:
  * Check whether we are running MultiThread TCG or not.
",0,include/qom/cpu.h,11,java,qemu___qemu,test
3825,18000,23878512c65834d12811b1107d19a001478eca5d,"@@ -319,6 +319,16 @@ int wc_SignatureGenerateHash(
     const byte* hash_data, word32 hash_len,
     byte* sig, word32 *sig_len,
     const void* key, word32 key_len, WC_RNG* rng)
+{
+    return wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data, hash_len,
+        sig, sig_len, key, key_len, rng, 1);
+}
+
+int wc_SignatureGenerateHash_ex(
+    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
+    const byte* hash_data, word32 hash_len,
+    byte* sig, word32 *sig_len,
+    const void* key, word32 key_len, WC_RNG* rng, int verify)
 {
     int ret;
 
@@ -393,6 +403,11 @@ int wc_SignatureGenerateHash(
             break;
     }
 
+    if (ret == 0 && verify) {
+        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data, hash_len,
+            sig, *sig_len, key, key_len);
+    }
+
     return ret;
 }
 
@@ -401,6 +416,16 @@ int wc_SignatureGenerate(
     const byte* data, word32 data_len,
     byte* sig, word32 *sig_len,
     const void* key, word32 key_len, WC_RNG* rng)
+{
+    return wc_SignatureGenerate_ex(hash_type, sig_type, data, data_len, sig,
+        sig_len, key, key_len, rng, 1);
+}
+
+int wc_SignatureGenerate_ex(
+    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
+    const byte* data, word32 data_len,
+    byte* sig, word32 *sig_len,
+    const void* key, word32 key_len, WC_RNG* rng, int verify)
 {
     int ret;
     word32 hash_len, hash_enc_len;
@@ -467,6 +492,11 @@ int wc_SignatureGenerate(
         }
     }
 
+    if (ret == 0 && verify) {
+        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data,
+            hash_enc_len, sig, *sig_len, key, key_len);
+    }
+
 #ifdef WOLFSSL_SMALL_STACK
     XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 #endif
",0,wolfcrypt/src/signature.c,30,java,wolfssl___wolfssl,test
8369,39637,576d1abc205fb1c135a7448df96bc9d47cb360dc,"@@ -0,0 +1,661 @@
+/*
+ * VMStateInfo's for basic typse
+ *
+ * Copyright (c) 2009-2017 Red Hat Inc
+ *
+ * Authors:
+ *  Juan Quintela <quintela@redhat.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ */
+
+#include ""qemu/osdep.h""
+#include ""qemu-common.h""
+#include ""migration/migration.h""
+#include ""migration/qemu-file.h""
+#include ""migration/vmstate.h""
+#include ""qemu/error-report.h""
+#include ""qemu/queue.h""
+#include ""trace.h""
+
+/* bool */
+
+static int get_bool(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    bool *v = pv;
+    *v = qemu_get_byte(f);
+    return 0;
+}
+
+static int put_bool(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                    QJSON *vmdesc)
+{
+    bool *v = pv;
+    qemu_put_byte(f, *v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_bool = {
+    .name = ""bool"",
+    .get  = get_bool,
+    .put  = put_bool,
+};
+
+/* 8 bit int */
+
+static int get_int8(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    int8_t *v = pv;
+    qemu_get_s8s(f, v);
+    return 0;
+}
+
+static int put_int8(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                     QJSON *vmdesc)
+{
+    int8_t *v = pv;
+    qemu_put_s8s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_int8 = {
+    .name = ""int8"",
+    .get  = get_int8,
+    .put  = put_int8,
+};
+
+/* 16 bit int */
+
+static int get_int16(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    int16_t *v = pv;
+    qemu_get_sbe16s(f, v);
+    return 0;
+}
+
+static int put_int16(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                     QJSON *vmdesc)
+{
+    int16_t *v = pv;
+    qemu_put_sbe16s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_int16 = {
+    .name = ""int16"",
+    .get  = get_int16,
+    .put  = put_int16,
+};
+
+/* 32 bit int */
+
+static int get_int32(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    int32_t *v = pv;
+    qemu_get_sbe32s(f, v);
+    return 0;
+}
+
+static int put_int32(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                     QJSON *vmdesc)
+{
+    int32_t *v = pv;
+    qemu_put_sbe32s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_int32 = {
+    .name = ""int32"",
+    .get  = get_int32,
+    .put  = put_int32,
+};
+
+/* 32 bit int. See that the received value is the same than the one
+   in the field */
+
+static int get_int32_equal(QEMUFile *f, void *pv, size_t size,
+                           VMStateField *field)
+{
+    int32_t *v = pv;
+    int32_t v2;
+    qemu_get_sbe32s(f, &v2);
+
+    if (*v == v2) {
+        return 0;
+    }
+    error_report(""%"" PRIx32 "" != %"" PRIx32, *v, v2);
+    return -EINVAL;
+}
+
+const VMStateInfo vmstate_info_int32_equal = {
+    .name = ""int32 equal"",
+    .get  = get_int32_equal,
+    .put  = put_int32,
+};
+
+/* 32 bit int. Check that the received value is non-negative
+ * and less than or equal to the one in the field.
+ */
+
+static int get_int32_le(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    int32_t *cur = pv;
+    int32_t loaded;
+    qemu_get_sbe32s(f, &loaded);
+
+    if (loaded >= 0 && loaded <= *cur) {
+        *cur = loaded;
+        return 0;
+    }
+    error_report(""Invalid value %"" PRId32
+                 "" expecting positive value <= %"" PRId32,
+                 loaded, *cur);
+    return -EINVAL;
+}
+
+const VMStateInfo vmstate_info_int32_le = {
+    .name = ""int32 le"",
+    .get  = get_int32_le,
+    .put  = put_int32,
+};
+
+/* 64 bit int */
+
+static int get_int64(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    int64_t *v = pv;
+    qemu_get_sbe64s(f, v);
+    return 0;
+}
+
+static int put_int64(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                      QJSON *vmdesc)
+{
+    int64_t *v = pv;
+    qemu_put_sbe64s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_int64 = {
+    .name = ""int64"",
+    .get  = get_int64,
+    .put  = put_int64,
+};
+
+/* 8 bit unsigned int */
+
+static int get_uint8(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    uint8_t *v = pv;
+    qemu_get_8s(f, v);
+    return 0;
+}
+
+static int put_uint8(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                     QJSON *vmdesc)
+{
+    uint8_t *v = pv;
+    qemu_put_8s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_uint8 = {
+    .name = ""uint8"",
+    .get  = get_uint8,
+    .put  = put_uint8,
+};
+
+/* 16 bit unsigned int */
+
+static int get_uint16(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    uint16_t *v = pv;
+    qemu_get_be16s(f, v);
+    return 0;
+}
+
+static int put_uint16(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                      QJSON *vmdesc)
+{
+    uint16_t *v = pv;
+    qemu_put_be16s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_uint16 = {
+    .name = ""uint16"",
+    .get  = get_uint16,
+    .put  = put_uint16,
+};
+
+/* 32 bit unsigned int */
+
+static int get_uint32(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    uint32_t *v = pv;
+    qemu_get_be32s(f, v);
+    return 0;
+}
+
+static int put_uint32(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                      QJSON *vmdesc)
+{
+    uint32_t *v = pv;
+    qemu_put_be32s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_uint32 = {
+    .name = ""uint32"",
+    .get  = get_uint32,
+    .put  = put_uint32,
+};
+
+/* 32 bit uint. See that the received value is the same than the one
+   in the field */
+
+static int get_uint32_equal(QEMUFile *f, void *pv, size_t size,
+                            VMStateField *field)
+{
+    uint32_t *v = pv;
+    uint32_t v2;
+    qemu_get_be32s(f, &v2);
+
+    if (*v == v2) {
+        return 0;
+    }
+    error_report(""%"" PRIx32 "" != %"" PRIx32, *v, v2);
+    return -EINVAL;
+}
+
+const VMStateInfo vmstate_info_uint32_equal = {
+    .name = ""uint32 equal"",
+    .get  = get_uint32_equal,
+    .put  = put_uint32,
+};
+
+/* 64 bit unsigned int */
+
+static int get_uint64(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    uint64_t *v = pv;
+    qemu_get_be64s(f, v);
+    return 0;
+}
+
+static int put_uint64(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                      QJSON *vmdesc)
+{
+    uint64_t *v = pv;
+    qemu_put_be64s(f, v);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_uint64 = {
+    .name = ""uint64"",
+    .get  = get_uint64,
+    .put  = put_uint64,
+};
+
+static int get_nullptr(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+
+{
+    if (qemu_get_byte(f) == VMS_NULLPTR_MARKER) {
+        return  0;
+    }
+    error_report(""vmstate: get_nullptr expected VMS_NULLPTR_MARKER"");
+    return -EINVAL;
+}
+
+static int put_nullptr(QEMUFile *f, void *pv, size_t size,
+                        VMStateField *field, QJSON *vmdesc)
+
+{
+    if (pv == NULL) {
+        qemu_put_byte(f, VMS_NULLPTR_MARKER);
+        return 0;
+    }
+    error_report(""vmstate: put_nullptr must be called with pv == NULL"");
+    return -EINVAL;
+}
+
+const VMStateInfo vmstate_info_nullptr = {
+    .name = ""uint64"",
+    .get  = get_nullptr,
+    .put  = put_nullptr,
+};
+
+/* 64 bit unsigned int. See that the received value is the same than the one
+   in the field */
+
+static int get_uint64_equal(QEMUFile *f, void *pv, size_t size,
+                            VMStateField *field)
+{
+    uint64_t *v = pv;
+    uint64_t v2;
+    qemu_get_be64s(f, &v2);
+
+    if (*v == v2) {
+        return 0;
+    }
+    error_report(""%"" PRIx64 "" != %"" PRIx64, *v, v2);
+    return -EINVAL;
+}
+
+const VMStateInfo vmstate_info_uint64_equal = {
+    .name = ""int64 equal"",
+    .get  = get_uint64_equal,
+    .put  = put_uint64,
+};
+
+/* 8 bit int. See that the received value is the same than the one
+   in the field */
+
+static int get_uint8_equal(QEMUFile *f, void *pv, size_t size,
+                           VMStateField *field)
+{
+    uint8_t *v = pv;
+    uint8_t v2;
+    qemu_get_8s(f, &v2);
+
+    if (*v == v2) {
+        return 0;
+    }
+    error_report(""%x != %x"", *v, v2);
+    return -EINVAL;
+}
+
+const VMStateInfo vmstate_info_uint8_equal = {
+    .name = ""uint8 equal"",
+    .get  = get_uint8_equal,
+    .put  = put_uint8,
+};
+
+/* 16 bit unsigned int int. See that the received value is the same than the one
+   in the field */
+
+static int get_uint16_equal(QEMUFile *f, void *pv, size_t size,
+                            VMStateField *field)
+{
+    uint16_t *v = pv;
+    uint16_t v2;
+    qemu_get_be16s(f, &v2);
+
+    if (*v == v2) {
+        return 0;
+    }
+    error_report(""%x != %x"", *v, v2);
+    return -EINVAL;
+}
+
+const VMStateInfo vmstate_info_uint16_equal = {
+    .name = ""uint16 equal"",
+    .get  = get_uint16_equal,
+    .put  = put_uint16,
+};
+
+/* floating point */
+
+static int get_float64(QEMUFile *f, void *pv, size_t size,
+                       VMStateField *field)
+{
+    float64 *v = pv;
+
+    *v = make_float64(qemu_get_be64(f));
+    return 0;
+}
+
+static int put_float64(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                       QJSON *vmdesc)
+{
+    uint64_t *v = pv;
+
+    qemu_put_be64(f, float64_val(*v));
+    return 0;
+}
+
+const VMStateInfo vmstate_info_float64 = {
+    .name = ""float64"",
+    .get  = get_float64,
+    .put  = put_float64,
+};
+
+/* CPU_DoubleU type */
+
+static int get_cpudouble(QEMUFile *f, void *pv, size_t size,
+                         VMStateField *field)
+{
+    CPU_DoubleU *v = pv;
+    qemu_get_be32s(f, &v->l.upper);
+    qemu_get_be32s(f, &v->l.lower);
+    return 0;
+}
+
+static int put_cpudouble(QEMUFile *f, void *pv, size_t size,
+                         VMStateField *field, QJSON *vmdesc)
+{
+    CPU_DoubleU *v = pv;
+    qemu_put_be32s(f, &v->l.upper);
+    qemu_put_be32s(f, &v->l.lower);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_cpudouble = {
+    .name = ""CPU_Double_U"",
+    .get  = get_cpudouble,
+    .put  = put_cpudouble,
+};
+
+/* uint8_t buffers */
+
+static int get_buffer(QEMUFile *f, void *pv, size_t size,
+                      VMStateField *field)
+{
+    uint8_t *v = pv;
+    qemu_get_buffer(f, v, size);
+    return 0;
+}
+
+static int put_buffer(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                      QJSON *vmdesc)
+{
+    uint8_t *v = pv;
+    qemu_put_buffer(f, v, size);
+    return 0;
+}
+
+const VMStateInfo vmstate_info_buffer = {
+    .name = ""buffer"",
+    .get  = get_buffer,
+    .put  = put_buffer,
+};
+
+/* unused buffers: space that was used for some fields that are
+   not useful anymore */
+
+static int get_unused_buffer(QEMUFile *f, void *pv, size_t size,
+                             VMStateField *field)
+{
+    uint8_t buf[1024];
+    int block_len;
+
+    while (size > 0) {
+        block_len = MIN(sizeof(buf), size);
+        size -= block_len;
+        qemu_get_buffer(f, buf, block_len);
+    }
+   return 0;
+}
+
+static int put_unused_buffer(QEMUFile *f, void *pv, size_t size,
+                             VMStateField *field, QJSON *vmdesc)
+{
+    static const uint8_t buf[1024];
+    int block_len;
+
+    while (size > 0) {
+        block_len = MIN(sizeof(buf), size);
+        size -= block_len;
+        qemu_put_buffer(f, buf, block_len);
+    }
+
+    return 0;
+}
+
+const VMStateInfo vmstate_info_unused_buffer = {
+    .name = ""unused_buffer"",
+    .get  = get_unused_buffer,
+    .put  = put_unused_buffer,
+};
+
+/* vmstate_info_tmp, see VMSTATE_WITH_TMP, the idea is that we allocate
+ * a temporary buffer and the pre_load/pre_save methods in the child vmsd
+ * copy stuff from the parent into the child and do calculations to fill
+ * in fields that don't really exist in the parent but need to be in the
+ * stream.
+ */
+static int get_tmp(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    int ret;
+    const VMStateDescription *vmsd = field->vmsd;
+    int version_id = field->version_id;
+    void *tmp = g_malloc(size);
+
+    /* Writes the parent field which is at the start of the tmp */
+    *(void **)tmp = pv;
+    ret = vmstate_load_state(f, vmsd, tmp, version_id);
+    g_free(tmp);
+    return ret;
+}
+
+static int put_tmp(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                    QJSON *vmdesc)
+{
+    const VMStateDescription *vmsd = field->vmsd;
+    void *tmp = g_malloc(size);
+
+    /* Writes the parent field which is at the start of the tmp */
+    *(void **)tmp = pv;
+    vmstate_save_state(f, vmsd, tmp, vmdesc);
+    g_free(tmp);
+
+    return 0;
+}
+
+const VMStateInfo vmstate_info_tmp = {
+    .name = ""tmp"",
+    .get = get_tmp,
+    .put = put_tmp,
+};
+
+/* bitmaps (as defined by bitmap.h). Note that size here is the size
+ * of the bitmap in bits. The on-the-wire format of a bitmap is 64
+ * bit words with the bits in big endian order. The in-memory format
+ * is an array of 'unsigned long', which may be either 32 or 64 bits.
+ */
+/* This is the number of 64 bit words sent over the wire */
+#define BITS_TO_U64S(nr) DIV_ROUND_UP(nr, 64)
+static int get_bitmap(QEMUFile *f, void *pv, size_t size, VMStateField *field)
+{
+    unsigned long *bmp = pv;
+    int i, idx = 0;
+    for (i = 0; i < BITS_TO_U64S(size); i++) {
+        uint64_t w = qemu_get_be64(f);
+        bmp[idx++] = w;
+        if (sizeof(unsigned long) == 4 && idx < BITS_TO_LONGS(size)) {
+            bmp[idx++] = w >> 32;
+        }
+    }
+    return 0;
+}
+
+static int put_bitmap(QEMUFile *f, void *pv, size_t size, VMStateField *field,
+                      QJSON *vmdesc)
+{
+    unsigned long *bmp = pv;
+    int i, idx = 0;
+    for (i = 0; i < BITS_TO_U64S(size); i++) {
+        uint64_t w = bmp[idx++];
+        if (sizeof(unsigned long) == 4 && idx < BITS_TO_LONGS(size)) {
+            w |= ((uint64_t)bmp[idx++]) << 32;
+        }
+        qemu_put_be64(f, w);
+    }
+
+    return 0;
+}
+
+const VMStateInfo vmstate_info_bitmap = {
+    .name = ""bitmap"",
+    .get = get_bitmap,
+    .put = put_bitmap,
+};
+
+/* get for QTAILQ
+ * meta data about the QTAILQ is encoded in a VMStateField structure
+ */
+static int get_qtailq(QEMUFile *f, void *pv, size_t unused_size,
+                      VMStateField *field)
+{
+    int ret = 0;
+    const VMStateDescription *vmsd = field->vmsd;
+    /* size of a QTAILQ element */
+    size_t size = field->size;
+    /* offset of the QTAILQ entry in a QTAILQ element */
+    size_t entry_offset = field->start;
+    int version_id = field->version_id;
+    void *elm;
+
+    trace_get_qtailq(vmsd->name, version_id);
+    if (version_id > vmsd->version_id) {
+        error_report(""%s %s"",  vmsd->name, ""too new"");
+        trace_get_qtailq_end(vmsd->name, ""too new"", -EINVAL);
+
+        return -EINVAL;
+    }
+    if (version_id < vmsd->minimum_version_id) {
+        error_report(""%s %s"",  vmsd->name, ""too old"");
+        trace_get_qtailq_end(vmsd->name, ""too old"", -EINVAL);
+        return -EINVAL;
+    }
+
+    while (qemu_get_byte(f)) {
+        elm = g_malloc(size);
+        ret = vmstate_load_state(f, vmsd, elm, version_id);
+        if (ret) {
+            return ret;
+        }
+        QTAILQ_RAW_INSERT_TAIL(pv, elm, entry_offset);
+    }
+
+    trace_get_qtailq_end(vmsd->name, ""end"", ret);
+    return ret;
+}
+
+/* put for QTAILQ */
+static int put_qtailq(QEMUFile *f, void *pv, size_t unused_size,
+                      VMStateField *field, QJSON *vmdesc)
+{
+    const VMStateDescription *vmsd = field->vmsd;
+    /* offset of the QTAILQ entry in a QTAILQ element*/
+    size_t entry_offset = field->start;
+    void *elm;
+
+    trace_put_qtailq(vmsd->name, vmsd->version_id);
+
+    QTAILQ_RAW_FOREACH(elm, pv, entry_offset) {
+        qemu_put_byte(f, true);
+        vmstate_save_state(f, vmsd, elm, vmdesc);
+    }
+    qemu_put_byte(f, false);
+
+    trace_put_qtailq_end(vmsd->name, ""end"");
+
+    return 0;
+}
+const VMStateInfo vmstate_info_qtailq = {
+    .name = ""qtailq"",
+    .get  = get_qtailq,
+    .put  = put_qtailq,
+};
",1,migration/vmstate-types.c,661,java,qemu___qemu,test
8252,38999,0102e4efda76d0721bc744dd80258eb6cfa25fc3,"@@ -53,37 +53,37 @@ static void evtchn_2l_bind_to_cpu(struct irq_info *info, unsigned cpu)
 	set_bit(info->evtchn, BM(per_cpu(cpu_evtchn_mask, cpu)));
 }
 
-static void evtchn_2l_clear_pending(unsigned port)
+static void evtchn_2l_clear_pending(evtchn_port_t port)
 {
 	struct shared_info *s = HYPERVISOR_shared_info;
 	sync_clear_bit(port, BM(&s->evtchn_pending[0]));
 }
 
-static void evtchn_2l_set_pending(unsigned port)
+static void evtchn_2l_set_pending(evtchn_port_t port)
 {
 	struct shared_info *s = HYPERVISOR_shared_info;
 	sync_set_bit(port, BM(&s->evtchn_pending[0]));
 }
 
-static bool evtchn_2l_is_pending(unsigned port)
+static bool evtchn_2l_is_pending(evtchn_port_t port)
 {
 	struct shared_info *s = HYPERVISOR_shared_info;
 	return sync_test_bit(port, BM(&s->evtchn_pending[0]));
 }
 
-static bool evtchn_2l_test_and_set_mask(unsigned port)
+static bool evtchn_2l_test_and_set_mask(evtchn_port_t port)
 {
 	struct shared_info *s = HYPERVISOR_shared_info;
 	return sync_test_and_set_bit(port, BM(&s->evtchn_mask[0]));
 }
 
-static void evtchn_2l_mask(unsigned port)
+static void evtchn_2l_mask(evtchn_port_t port)
 {
 	struct shared_info *s = HYPERVISOR_shared_info;
 	sync_set_bit(port, BM(&s->evtchn_mask[0]));
 }
 
-static void evtchn_2l_unmask(unsigned port)
+static void evtchn_2l_unmask(evtchn_port_t port)
 {
 	struct shared_info *s = HYPERVISOR_shared_info;
 	unsigned int cpu = get_cpu();
@@ -173,7 +173,7 @@ static void evtchn_2l_handle_events(unsigned cpu)
 	/* Timer interrupt has highest priority. */
 	irq = irq_from_virq(cpu, VIRQ_TIMER);
 	if (irq != -1) {
-		unsigned int evtchn = evtchn_from_irq(irq);
+		evtchn_port_t evtchn = evtchn_from_irq(irq);
 		word_idx = evtchn / BITS_PER_LONG;
 		bit_idx = evtchn % BITS_PER_LONG;
 		if (active_evtchns(cpu, s, word_idx) & (1ULL << bit_idx))
@@ -228,7 +228,7 @@ static void evtchn_2l_handle_events(unsigned cpu)
 
 		do {
 			xen_ulong_t bits;
-			int port;
+			evtchn_port_t port;
 
 			bits = MASK_LSBS(pending_bits, bit_idx);
 
",1,drivers/xen/events/events_2l.c,16,java,torvalds___linux,test
2176,10492,4d3811681a80f92a53e795f6a64c4b0fc2c8dd22,"@@ -9235,12 +9235,12 @@ static int cmd_anal_all(RCore *core, const char *input) {
 }
 
 static bool anal_fcn_data (RCore *core, const char *input) {
-	RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
-	ut32 fcn_size = r_anal_function_size_from_entry (fcn);
+	RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);
 	if (fcn) {
 		int i;
 		bool gap = false;
 		ut64 gap_addr = UT64_MAX;
+		ut32 fcn_size = r_anal_function_size_from_entry (fcn);
 		char *bitmap = calloc (1, fcn_size);
 		if (bitmap) {
 			RAnalBlock *b;
",0,libr/core/cmd_anal.c,4,java,radareorg___radare2,test
7058,33155,907bedb3f3ce134c149599bd9cb61856d811b8ca,"@@ -6463,6 +6463,36 @@ static void do_v7m_exception_exit(ARMCPU *cpu)
                           ""for destination state is UNPREDICTABLE\n"");
         }
 
+        /* Do we need to pop callee-saved registers? */
+        if (return_to_secure &&
+            ((excret & R_V7M_EXCRET_ES_MASK) == 0 ||
+             (excret & R_V7M_EXCRET_DCRS_MASK) == 0)) {
+            uint32_t expected_sig = 0xfefa125b;
+            uint32_t actual_sig = ldl_phys(cs->as, frameptr);
+
+            if (expected_sig != actual_sig) {
+                /* Take a SecureFault on the current stack */
+                env->v7m.sfsr |= R_V7M_SFSR_INVIS_MASK;
+                armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);
+                v7m_exception_taken(cpu, excret);
+                qemu_log_mask(CPU_LOG_INT, ""...taking SecureFault on existing ""
+                              ""stackframe: failed exception return integrity ""
+                              ""signature check\n"");
+                return;
+            }
+
+            env->regs[4] = ldl_phys(cs->as, frameptr + 0x8);
+            env->regs[5] = ldl_phys(cs->as, frameptr + 0xc);
+            env->regs[6] = ldl_phys(cs->as, frameptr + 0x10);
+            env->regs[7] = ldl_phys(cs->as, frameptr + 0x14);
+            env->regs[8] = ldl_phys(cs->as, frameptr + 0x18);
+            env->regs[9] = ldl_phys(cs->as, frameptr + 0x1c);
+            env->regs[10] = ldl_phys(cs->as, frameptr + 0x20);
+            env->regs[11] = ldl_phys(cs->as, frameptr + 0x24);
+
+            frameptr += 0x28;
+        }
+
         /* Pop registers. TODO: make these accesses use the correct
          * attributes and address space (S/NS, priv/unpriv) and handle
          * memory transaction failures.
",1,target/arm/helper.c,30,java,qemu___qemu,test
8352,39533,d45bbc0502ea651dcfc71091d67363b7651b5cd5,"@@ -95,8 +95,8 @@ GF_Err gendump_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remov
 	sr = p ? p->value.uint : 0;
 	p = gf_filter_pid_get_property(pid, GF_PROP_PID_NUM_CHANNELS);
 	chan = p ? p->value.uint : 0;
-	p = gf_filter_pid_get_property(pid, GF_PROP_PID_BPS);
-	bps = p ? p->value.uint : 16;
+	p = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);
+	bps = p ? gf_audio_fmt_bit_depth(p->value.uint) : 16;
 	p = gf_filter_pid_get_property(pid, GF_PROP_PID_WIDTH);
 	w = p ? p->value.uint : 0;
 	p = gf_filter_pid_get_property(pid, GF_PROP_PID_HEIGHT);
",1,src/filters/write_generic.c,4,java,gpac___gpac,test
5530,26082,f2529807164bd590f54526199ff202fa966c71d4,"@@ -89,11 +89,11 @@ public:
 
 		lock_write_get(lock_);	       		
 		err = str_dup(&tmp, stats);
-		info(""peerflow(%p): OnStatsDelivered err=%d len=%d\n"", pf_, err, (int)str_len(tmp));
+		//info(""peerflow(%p): OnStatsDelivered err=%d len=%d stats=%s\n"", pf_, err, (int)str_len(tmp), stats);
 		mem_deref(current_stats_);
 		current_stats_ = tmp;
 		lock_rel(lock_);
-		
+
 		std::vector<const webrtc::RTCInboundRTPStreamStats*> streamStats =
 			report->GetStatsOfType<webrtc::RTCInboundRTPStreamStats>();
 		std::vector<const webrtc::RTCInboundRTPStreamStats*>::iterator it;
@@ -165,10 +165,19 @@ public:
 			}
 		}
 
-		info(""stats callback: pl: %.02f rtt: %.02f\n"", downloss, rtt);
+		int audio_level = 0;
+
+		const webrtc::RTCAudioSourceStats *asrc_stats =
+			report->GetAs<webrtc::RTCAudioSourceStats>(""RTCAudioSource_1"");
+
+		if (asrc_stats)
+			audio_level = (int)(*asrc_stats->audio_level * 255.0);
+
+		//info(""stats callback: pl: %.02f rtt: %.02f\n"", downloss, rtt);
 		lock_write_get(lock_);
 		if (active_) {
 			peerflow_set_stats(pf_,
+					   audio_level,
 					   apkts_recv,
 					   vpkts_recv,
 					   apkts_sent,
",1,src/peerflow/stats.h,15,java,wireapp___wire-avs,test
7282,34378,27bf9db67efb8774f08e28fea78d43837d2ebbf2,"@@ -66,6 +66,7 @@
 #include <libtpms/tpm_library.h>
 
 #include <openssl/sha.h>
+#include <openssl/hmac.h>
 
 #include ""swtpm_aes.h""
 #include ""swtpm_debug.h""
@@ -74,6 +75,7 @@
 #include ""logging.h""
 #include ""tpmstate.h""
 #include ""tpmlib.h""
+#include ""tlv.h""
 
 /* local structures */
 typedef struct {
@@ -84,11 +86,12 @@ typedef struct {
     uint32_t totlen; /* length of the header and following data */
 } __attribute__((packed)) blobheader;
 
-#define BLOB_HEADER_VERSION 1
+#define BLOB_HEADER_VERSION 2
 
 /* flags for blobheader */
 #define BLOB_FLAG_ENCRYPTED              0x1
 #define BLOB_FLAG_MIGRATION_ENCRYPTED    0x2 /* encrypted with migration key */
+#define BLOB_FLAG_MIGRATION_DATA         0x4 /* migration data are available */
 
 typedef struct {
     enum encryption_mode data_encmode;
@@ -116,16 +119,30 @@ static TPM_RESULT SWTPM_NVRAM_GetFilenameForName(char *filename,
                                                  const char *name);
 
 static TPM_RESULT SWTPM_NVRAM_EncryptData(const encryptionkey *key,
-                                          unsigned char **encrypt_data,
-                                          uint32_t *encrypt_length,
+                                          tlv_data *td,
+                                          size_t *td_len,
+                                          uint16_t tag_encrypted_data,
                                           const unsigned char *decrypt_data,
                                           uint32_t decrypt_length);
 
-static TPM_RESULT SWTPM_NVRAM_DecryptData(const encryptionkey *key,
-                                          unsigned char **decrypt_data,
-                                          uint32_t *decrypt_length,
-                                          const unsigned char *encrypt_data,
-                                          uint32_t encrypt_length);
+static TPM_RESULT SWTPM_NVRAM_GetDecryptedData(const encryptionkey *key,
+                                               unsigned char **decrypt_data,
+                                               uint32_t *decrypt_length,
+                                               const unsigned char *encrypt_data,
+                                               uint32_t encrypt_length,
+                                               uint16_t tag_decryped_data,
+                                               uint16_t tag_data,
+                                               uint8_t hdrversion);
+
+static TPM_RESULT SWTPM_NVRAM_PrependHeader(unsigned char **data,
+                                            uint32_t *length,
+                                            uint16_t flags);
+
+static TPM_RESULT SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,
+                                          uint32_t *dataoffset,
+                                          uint16_t *hdrflags,
+                                          uint8_t *hdrversion,
+                                          bool quiet);
 
 /* A file name in NVRAM is composed of 3 parts:
 
@@ -194,12 +211,11 @@ TPM_RESULT SWTPM_NVRAM_Init(void)
         TPM_FAIL on failure to load (fatal), since it should never occur
 */
 
-static TPM_RESULT
-SWTPM_NVRAM_LoadData_Intern(unsigned char **data,     /* freed by caller */
-                            uint32_t *length,
-                            uint32_t tpm_number,
-                            const char *name,
-                            TPM_BOOL decrypt)         /* decrypt if key is set */
+TPM_RESULT
+SWTPM_NVRAM_LoadData(unsigned char **data,     /* freed by caller */
+                     uint32_t *length,
+                     uint32_t tpm_number,
+                     const char *name)
 {
     TPM_RESULT    rc = 0;
     long          lrc;
@@ -209,6 +225,9 @@ SWTPM_NVRAM_LoadData_Intern(unsigned char **data,     /* freed by caller */
     char          filename[FILENAME_MAX]; /* rooted file name from name */
     unsigned char *decrypt_data = NULL;
     uint32_t      decrypt_length;
+    uint32_t      dataoffset = 0;
+    uint8_t       hdrversion = 0;
+    uint16_t      hdrflags;
 
     TPM_DEBUG("" SWTPM_NVRAM_LoadData: From file %s\n"", name);
     *data = NULL;
@@ -314,9 +333,22 @@ SWTPM_NVRAM_LoadData_Intern(unsigned char **data,     /* freed by caller */
         }
     }
 
-    if (rc == 0 && decrypt) {
-        rc = SWTPM_NVRAM_DecryptData(&filekey, &decrypt_data, &decrypt_length,
-                                     *data, *length);
+    if (rc == 0) {
+        /* this function needs to return the plain data -- no tlv headers */
+
+        /* try to get a header from it -- old files may not have one */
+        irc = SWTPM_NVRAM_CheckHeader(*data, *length, &dataoffset,
+                                      &hdrflags, &hdrversion, true);
+        /* valid header -- this one can only be version 2 or later */
+        if (irc)
+            hdrversion = 1; /* no header -- payload was written like vers. 1 */
+
+        rc = SWTPM_NVRAM_GetDecryptedData(&filekey,
+                                          &decrypt_data, &decrypt_length,
+                                          *data + dataoffset,
+                                          *length - dataoffset,
+                                          TAG_ENCRYPTED_DATA, TAG_DATA,
+                                          hdrversion);
         TPM_DEBUG("" SWTPM_NVRAM_LoadData: SWTPM_NVRAM_DecryptData rc = %d\n"",
                   rc);
         if (rc != 0)
@@ -325,26 +357,21 @@ SWTPM_NVRAM_LoadData_Intern(unsigned char **data,     /* freed by caller */
                       ""failed rc = %d\n"", rc);
 
         if (rc == 0) {
-            if (decrypt_data) {
-                TPM_DEBUG("" SWTPM_NVRAM_LoadData: Decrypted %u bytes of ""
-                          ""data to %u bytes.\n"",
-                          *length, decrypt_length);
-                TPM_Free(*data);
-                *data = decrypt_data;
-                *length = decrypt_length;
-            }
+            TPM_DEBUG("" SWTPM_NVRAM_LoadData: Decrypted %u bytes of ""
+                      ""data to %u bytes.\n"",
+                      *length, decrypt_length);
+            TPM_Free(*data);
+            *data = decrypt_data;
+            *length = decrypt_length;
         }
     }
 
-    return rc;
-}
+    if (rc != 0) {
+        free(*data);
+        *data = NULL;
+    }
 
-TPM_RESULT SWTPM_NVRAM_LoadData(unsigned char **data,     /* freed by caller */
-                                uint32_t *length,
-                                uint32_t tpm_number,
-                                const char *name)
-{
-     return SWTPM_NVRAM_LoadData_Intern(data, length, tpm_number, name, TRUE);
+    return rc;
 }
 
 /* SWTPM_NVRAM_StoreData stores 'data' of 'length' to the rooted 'filename'
@@ -366,8 +393,11 @@ SWTPM_NVRAM_StoreData_Intern(const unsigned char *data,
     int           irc;
     FILE          *file = NULL;
     char          filename[FILENAME_MAX]; /* rooted file name from name */
-    unsigned char *encrypt_data = NULL;
-    uint32_t      encrypt_length = 0;
+    unsigned char *filedata = NULL;
+    uint32_t      filedata_length = 0;
+    tlv_data      td[2];
+    size_t        td_len = 0;
+    uint16_t      flags = 0;
 
     TPM_DEBUG("" SWTPM_NVRAM_StoreData: To name %s\n"", name);
     if (rc == 0) {
@@ -396,29 +426,40 @@ SWTPM_NVRAM_StoreData_Intern(const unsigned char *data,
         }
     }
 
-    if (rc == 0 && encrypt) {
-        rc = SWTPM_NVRAM_EncryptData(&filekey, &encrypt_data, &encrypt_length,
-                                     data, length);
-        if (rc) {
-            logprintf(STDERR_FILENO,
-                      ""SWTPM_NVRAM_EncryptData failed: 0x%02x\n"", rc);
-        }
-        if (encrypt_data) {
-            TPM_DEBUG(""  SWTPM_NVRAM_StoreData: Encrypted %u bytes before ""
-                      ""write, will write %u bytes\n"", length, encrypt_length);
-            length = encrypt_length;
+    if (rc == 0) {
+        if (encrypt && filekey.symkey.valid) {
+            td_len = 2;
+            rc = SWTPM_NVRAM_EncryptData(&filekey, &td[0], &td_len,
+                                         TAG_ENCRYPTED_DATA, data, length);
+            if (rc) {
+                logprintf(STDERR_FILENO,
+                          ""SWTPM_NVRAM_EncryptData failed: 0x%02x\n"", rc);
+            } else {
+                TPM_DEBUG(""  SWTPM_NVRAM_StoreData: Encrypted %u bytes before ""
+                          ""write, will write %u bytes\n"", length,
+                          td[0].tlv.length);
+            }
+            flags |= BLOB_FLAG_ENCRYPTED;
+        } else {
+            td_len = 1;
+            td[0] = TLV_DATA_CONST(TAG_DATA, length, data);
         }
     }
 
+    if (rc == 0)
+        rc = tlv_data_append(&filedata, &filedata_length, td, td_len);
+
+    if (rc == 0)
+        rc = SWTPM_NVRAM_PrependHeader(&filedata, &filedata_length, flags);
+
     /* write the data to the file */
     if (rc == 0) {
         TPM_DEBUG(""  SWTPM_NVRAM_StoreData: Writing %u bytes of data\n"", length);
-        lrc = fwrite(encrypt_data ? encrypt_data : data, 1,
-                     length, file);
-        if (lrc != length) {
+        lrc = fwrite(filedata, 1, filedata_length, file);
+        if (lrc != filedata_length) {
             logprintf(STDERR_FILENO,
                       ""TPM_NVRAM_StoreData: Error (fatal), data write ""
-                      ""of %u only wrote %u\n"", length, lrc);
+                      ""of %u only wrote %u\n"", filedata_length, lrc);
             rc = TPM_FAIL;
         }
     }
@@ -439,7 +480,8 @@ SWTPM_NVRAM_StoreData_Intern(const unsigned char *data,
         unlink(filename);
     }
 
-    TPM_Free(encrypt_data);
+    tlv_data_free(td, td_len);
+    TPM_Free(filedata);
 
     TPM_DEBUG("" SWTPM_NVRAM_StoreData: rc=%d\n"", rc);
 
@@ -603,29 +645,97 @@ TPM_RESULT SWTPM_NVRAM_Set_MigrationKey(const unsigned char *key,
     return rc;
 }
 
+/*
+ * SWTPM_CalcHMAC
+ *
+ * @in: input buffer to calculate HMAC on
+ * @in_length: length of input buffer
+ * @td: pointer to a tlv_data structure to receive the result with the
+ *      tag, length, and pointer to an allocated buffer holding the HMAC
+ * @tpm_symmetric_key_token: symmetric key
+ *
+ * Calculate an HMAC on the input buffer with payload and create an output
+ * buffer with the HMAC
+ */
 static TPM_RESULT
-SWTPM_PrependHash(const unsigned char *in, uint32_t in_length,
-                  unsigned char **out, uint32_t *out_length)
+SWTPM_CalcHMAC(const unsigned char *in, uint32_t in_length,
+               tlv_data *td,
+               const TPM_SYMMETRIC_KEY_DATA *tpm_symmetric_key_token)
 {
     TPM_RESULT rc = 0;
-    unsigned char *dest;
-    unsigned char hashbuf[SHA256_DIGEST_LENGTH];
-
-    /* hash the data */
-    SHA256(in, in_length, hashbuf);
+    unsigned int md_len;
+    unsigned char md[EVP_MAX_MD_SIZE];
+    unsigned char *buffer = NULL;
+
+    if (!HMAC(EVP_sha256(), tpm_symmetric_key_token->userKey,
+              TPM_AES_BLOCK_SIZE, in, in_length, md, &md_len)) {
+        logprintf(STDOUT_FILENO, ""HMAC() call failed.\n"");
+        return TPM_FAIL;
+    }
 
-    *out_length = sizeof(hashbuf) + in_length;
-    rc = TPM_Malloc(out, *out_length);
+    rc = TPM_Malloc(&buffer, md_len);
 
     if (rc == TPM_SUCCESS) {
-        dest = *out;
-        memcpy(dest, hashbuf, sizeof(hashbuf));
-        memcpy(&dest[sizeof(hashbuf)], in, in_length);
+        *td = TLV_DATA(TAG_HMAC, md_len, buffer);
+        memcpy(buffer, md, md_len);
     }
 
     return rc;
 }
 
+/*
+ * SWTPM_CheckHMAC:
+ *
+ * @hmac: tlv_data with pointer to hmac bytes
+ * @encrypted_data: tlv_data with pointer to encrypted data bytes
+ * @tpm_symmetric_key_token: symmetric key
+ *
+ * Verify the HMAC given the expected @hmac and the @tpm_symmetric_key_token
+ * to calculate the HMAC over the @encrypted_data.
+ */
+static TPM_RESULT
+SWTPM_CheckHMAC(tlv_data *hmac, tlv_data *encrypted_data,
+                const TPM_SYMMETRIC_KEY_DATA *tpm_symmetric_key_token)
+{
+    const unsigned char *data;
+    uint32_t data_length;
+    unsigned int md_len;
+    unsigned char md[EVP_MAX_MD_SIZE];
+
+    md_len = EVP_MD_size(EVP_sha256());
+    if (md_len > hmac->tlv.length) {
+        logprintf(STDOUT_FILENO, ""Insufficient bytes for CheckHMAC()\n"");
+        return TPM_FAIL;
+    }
+
+    data = encrypted_data->u.ptr;
+    data_length = encrypted_data->tlv.length;
+
+    if (!HMAC(EVP_sha256(), tpm_symmetric_key_token->userKey,
+              TPM_AES_BLOCK_SIZE, data, data_length, md, &md_len)) {
+        logprintf(STDOUT_FILENO, ""HMAC() call failed.\n"");
+        return TPM_FAIL;
+    }
+
+    if (memcmp(hmac->u.ptr, md, md_len)) {
+        logprintf(STDOUT_FILENO, ""Verification of hash failed. ""
+                  ""Data integrity is compromised\n"");
+        /* TPM_DECRYPT_ERROR indicates (to libtpms) that something
+           exists but we have the wrong key. */
+        return TPM_DECRYPT_ERROR;
+    }
+
+    return TPM_SUCCESS;
+}
+
+/*
+ * SWTPM_CheckHash:
+ *
+ * @in: input buffer
+ * @in_length: input buffer length
+ * @out: output buffer
+ * @out_length: output buffer length
+ */
 static TPM_RESULT
 SWTPM_CheckHash(const unsigned char *in, uint32_t in_length,
                 unsigned char **out, uint32_t *out_length)
@@ -645,9 +755,9 @@ SWTPM_CheckHash(const unsigned char *in, uint32_t in_length,
         rc = TPM_FAIL;
     }
 
-    if (rc == TPM_SUCCESS) {
+    if (rc == 0) {
         rc = TPM_Malloc(&dest, data_length);
-        if (rc == TPM_SUCCESS) {
+        if (rc == 0) {
             *out = dest;
             *out_length = data_length;
             memcpy(dest, data, data_length);
@@ -657,78 +767,179 @@ SWTPM_CheckHash(const unsigned char *in, uint32_t in_length,
     return rc;
 }
 
-static TPM_RESULT 
+static TPM_RESULT
 SWTPM_NVRAM_EncryptData(const encryptionkey *key,
-                        unsigned char **encrypt_data,
-                        uint32_t *encrypt_length,
-                        const unsigned char *decrypt_data,
-                        uint32_t decrypt_length)
+                        struct tlv_data *td, /* must provide 2 array members */
+                        size_t *td_len,
+                        uint16_t tag_encrypted_data,
+                        const unsigned char *data,
+                        uint32_t length)
 {
     TPM_RESULT rc = 0;
-    unsigned char *hashed_data = NULL;
-    uint32_t hashed_length = 0;
-
-    if (rc == 0) {
-        if (key->symkey.valid) {
-            switch (key->data_encmode) {
-            case ENCRYPTION_MODE_UNKNOWN:
-                rc = TPM_BAD_MODE;
-                break;
-            case ENCRYPTION_MODE_AES_CBC:
-                rc = SWTPM_PrependHash(decrypt_data, decrypt_length,
-                                       &hashed_data, &hashed_length);
-                if (rc)
-                     break;
-                rc = TPM_SymmetricKeyData_Encrypt(encrypt_data,
-                                                  encrypt_length,
-                                                  hashed_data,
-                                                  hashed_length,
-                                                  &key->symkey);
-                TPM_Free(hashed_data);
-                break;
+    unsigned char *tmp_data = NULL;
+    uint32_t tmp_length = 0;
+
+    *td_len = 0;
+
+    if (key->symkey.valid) {
+        switch (key->data_encmode) {
+        case ENCRYPTION_MODE_UNKNOWN:
+            rc = TPM_BAD_MODE;
+            break;
+        case ENCRYPTION_MODE_AES_CBC:
+            rc = TPM_SymmetricKeyData_Encrypt(&tmp_data, &tmp_length,
+                                              data, length, &key->symkey);
+            if (rc)
+                 break;
+
+            rc = SWTPM_CalcHMAC(tmp_data, tmp_length, &td[1], &key->symkey);
+            if (rc == 0) {
+                td[0] = TLV_DATA(tag_encrypted_data, tmp_length, tmp_data);
+                *td_len = 2;
+                tmp_data = NULL;
             }
+            break;
         }
     }
 
+    if (rc)
+        tlv_data_free(td, *td_len);
+
+    free(tmp_data);
+
     return rc;
 }
 
-static TPM_RESULT 
+static TPM_RESULT
 SWTPM_NVRAM_DecryptData(const encryptionkey *key,
-                        unsigned char **decrypt_data,
-                        uint32_t *decrypt_length,
-                        const unsigned char *encrypt_data,
-                        uint32_t encrypt_length)
+                        unsigned char **decrypt_data, uint32_t *decrypt_length,
+                        const unsigned char *data, uint32_t length,
+                        uint16_t tag_encrypted_data,
+                        uint8_t hdrversion)
 {
     TPM_RESULT rc = 0;
-    unsigned char *hashed_data = NULL;
-    uint32_t hashed_length = 0;
-
-    if (rc == 0) {
-        if (key->symkey.valid) {
-            switch (key->data_encmode) {
-            case ENCRYPTION_MODE_UNKNOWN:
-                rc = TPM_BAD_MODE;
-                break;
-            case ENCRYPTION_MODE_AES_CBC:
-                rc = TPM_SymmetricKeyData_Decrypt(&hashed_data,
-                                                  &hashed_length,
-                                                  encrypt_data,
-                                                  encrypt_length,
+    unsigned char *tmp_data = NULL;
+    uint32_t tmp_length = 0;
+    tlv_data td[2];
+
+    if (key->symkey.valid) {
+        switch (key->data_encmode) {
+        case ENCRYPTION_MODE_UNKNOWN:
+            rc = TPM_BAD_MODE;
+            break;
+        case ENCRYPTION_MODE_AES_CBC:
+            switch (hdrversion) {
+            case 1:
+                rc = TPM_SymmetricKeyData_Decrypt(&tmp_data,
+                                                  &tmp_length,
+                                                  data, length,
                                                   &key->symkey);
-                if (rc == TPM_SUCCESS) {
-                    rc = SWTPM_CheckHash(hashed_data, hashed_length,
+                if (rc == 0) {
+                    rc = SWTPM_CheckHash(tmp_data, tmp_length,
                                          decrypt_data, decrypt_length);
-                    TPM_Free(hashed_data);
                 }
-                break;
+            break;
+            case 2:
+                if (!tlv_data_find_tag(data, length, TAG_HMAC, &td[0]) ||
+                    !tlv_data_find_tag(data, length, tag_encrypted_data,
+                                       &td[1])) {
+                    logprintf(STDERR_FILENO,
+                              ""Could not find HMAC or encrpted data (tag %u) ""
+                              ""in byte stream.\n"", tag_encrypted_data);
+                    rc = TPM_FAIL;
+                    break;
+                }
+                rc = SWTPM_CheckHMAC(&td[0], &td[1], &key->symkey);
+                if (rc == 0) {
+                    rc = TPM_SymmetricKeyData_Decrypt(decrypt_data,
+                                                      decrypt_length,
+                                                      td[1].u.const_ptr,
+                                                      td[1].tlv.length,
+                                                      &key->symkey);
+                }
+            break;
+            default:
+                rc = TPM_FAIL;
             }
+            TPM_Free(tmp_data);
         }
     }
 
     return rc;
 }
 
+static TPM_RESULT
+SWTPM_NVRAM_GetPlainData(unsigned char **plain, uint32_t *plain_length,
+                         const unsigned char *data, uint32_t length,
+                         uint16_t tag_data,
+                         uint8_t hdrversion)
+{
+    TPM_RESULT rc = 0;
+    tlv_data td[1];
+
+    switch (hdrversion) {
+    case 1:
+        rc = TPM_Malloc(plain, length);
+        if (rc == 0) {
+            memcpy(*plain, data, length);
+            *plain_length = length;
+        }
+    break;
+
+    case 2:
+        if (!tlv_data_find_tag(data, length, tag_data, &td[0])) {
+            logprintf(STDERR_FILENO,
+                      ""Could not find plain data in byte stream.\n"");
+            rc = TPM_FAIL;
+            break;
+        }
+        rc = TPM_Malloc(plain, td->tlv.length);
+        if (rc == 0) {
+            memcpy(*plain, td->u.const_ptr, td->tlv.length);
+            *plain_length = td->tlv.length;
+        }
+    break;
+    }
+
+    return rc;
+}
+
+/*
+ * SWTPM_NVRAM_GetDecryptedData: Get the decrytped data either by just returning
+ *                               the data if they were not encrypted or by
+ *                               actually decrypting them if there is a key.
+ *                               The plain data is returned, meaning any TLV
+ *                               header has been removed.
+ * @key: the encryption key, may be NULL
+ * @decrypt_data: pointer to a pointer for the result
+ * @decrypt_length: the length of the returned data
+ * @data: input data
+ * @length: length of the input data
+ * @tag_encrypted_data: the tag the encrypted data is stored with
+ * @tag_data: the tag the plain data is stored with
+ * @hdrversion: the version found in the header that determines in what
+ *              format the data is stored; tag-length-value is the format
+ *              in v2
+ */
+static TPM_RESULT
+SWTPM_NVRAM_GetDecryptedData(const encryptionkey *key,
+                             unsigned char **decrypt_data,
+                             uint32_t *decrypt_length,
+                             const unsigned char *data,
+                             uint32_t length,
+                             uint16_t tag_encrypted_data,
+                             uint16_t tag_data,
+                             uint8_t hdrversion)
+{
+    if (key && key->symkey.valid) {
+        /* we assume the data are encrypted when there's a key given */
+        return SWTPM_NVRAM_DecryptData(key, decrypt_data, decrypt_length,
+                                       data, length, tag_encrypted_data,
+                                       hdrversion);
+    }
+    return SWTPM_NVRAM_GetPlainData(decrypt_data, decrypt_length,
+                                    data, length, tag_data, hdrversion);
+}
 
 /*
  * Prepend a header in front of the state blob
@@ -741,7 +952,7 @@ SWTPM_NVRAM_PrependHeader(unsigned char **data, uint32_t *length,
     uint32_t out_len = sizeof(blobheader) + *length;
     blobheader bh = {
         .version = BLOB_HEADER_VERSION,
-        .min_version = BLOB_HEADER_VERSION,
+        .min_version = 1,
         .hdrsize = htons(sizeof(bh)),
         .flags = htons(flags),
         .totlen = htonl(out_len),
@@ -773,30 +984,36 @@ SWTPM_NVRAM_PrependHeader(unsigned char **data, uint32_t *length,
 
 static TPM_RESULT
 SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,
-                        uint32_t *dataoffset, uint16_t *hdrflags)
+                        uint32_t *dataoffset, uint16_t *hdrflags,
+                        uint8_t *hdrversion, bool quiet)
 {
     blobheader *bh = (blobheader *)data;
 
     if (length < sizeof(bh)) {
-        logprintf(STDERR_FILENO,
-                  ""not enough bytes for header: %u\n"", length);
+        if (!quiet)
+            logprintf(STDERR_FILENO,
+                      ""not enough bytes for header: %u\n"", length);
         return TPM_BAD_PARAMETER;
     }
 
     if (ntohl(bh->totlen) != length) {
-        logprintf(STDERR_FILENO,
-                  ""broken header: bh->totlen %u != %u\n"", htonl(bh->totlen), length);
+        if (!quiet)
+            logprintf(STDERR_FILENO,
+                      ""broken header: bh->totlen %u != %u\n"",
+                      htonl(bh->totlen), length);
         return TPM_BAD_PARAMETER;
     }
 
     if (bh->min_version > BLOB_HEADER_VERSION) {
-        logprintf(STDERR_FILENO,
-                  ""Minimum required version for the blob is %d, we ""
-                  ""only support version %d\n"", bh->min_version,
-                  BLOB_HEADER_VERSION);
+        if (!quiet)
+            logprintf(STDERR_FILENO,
+                      ""Minimum required version for the blob is %d, we ""
+                      ""only support version %d\n"", bh->min_version,
+                      BLOB_HEADER_VERSION);
         return TPM_BAD_VERSION;
     }
 
+    *hdrversion = bh->version;
     *dataoffset = ntohs(bh->hdrsize);
     *hdrflags = ntohs(bh->flags);
 
@@ -817,48 +1034,76 @@ TPM_RESULT SWTPM_NVRAM_GetStateBlob(unsigned char **data,
 {
     TPM_RESULT res;
     uint16_t flags = 0;
+    tlv_data td[2];
+    size_t td_len;
+    unsigned char *plain = NULL, *buffer = NULL;
+    uint32_t plain_len, buffer_len = 0;
 
-    res = SWTPM_NVRAM_LoadData_Intern(data, length, tpm_number, name,
-                                      decrypt);
-    if (decrypt) {
-        /* we asked for a decrypted blob, so it cannot be encrypted */
-        *is_encrypted = FALSE;
+    *data = NULL;
+    *length = 0;
+
+    res = SWTPM_NVRAM_LoadData(&plain, &plain_len, tpm_number, name);
+    if (res)
+        return res;
+
+    /* @plain contains unencrypted data without tlv headers */
+
+    /* if the user doesn't want decryption and there's a file key, we need to
+       encrypt the data */
+    if (!decrypt && filekey.symkey.valid) {
+        td_len = 2;
+        res = SWTPM_NVRAM_EncryptData(&filekey, &td[0], &td_len,
+                                      TAG_ENCRYPTED_DATA, plain, plain_len);
+        if (res)
+            goto err_exit;
+
+        *is_encrypted = TRUE;
     } else {
-        /*
-         * We did not ask for a decrypted blob; in this case it's
-         * encrypted if there is a key set
-         */
-        *is_encrypted = filekey.symkey.valid;
+        *is_encrypted = FALSE;
+        td[0] = TLV_DATA(TAG_DATA, plain_len, plain);
+        plain = NULL;
+        td_len = 1;
     }
 
-    if (res == TPM_SUCCESS && migrationkey.symkey.valid) {
-        /*
-         * we have to encrypt it now with the migration key
-         */
-        unsigned char *out = NULL;
-        uint32_t out_len = 0;
+    res = tlv_data_append(&buffer, &buffer_len, td, td_len);
+    if (res)
+        goto err_exit;
+
+    tlv_data_free(td, td_len);
 
+    /* @buffer contains tlv data */
+
+    if (migrationkey.symkey.valid) {
+        /* we have to encrypt it now with the migration key */
         flags |= BLOB_FLAG_MIGRATION_ENCRYPTED;
 
-        res = SWTPM_NVRAM_EncryptData(&migrationkey, &out, &out_len,
-                                      *data, *length);
-        TPM_Free(*data);
-        if (res == TPM_SUCCESS) {
-            *data = out;
-            *length = out_len;
-        } else {
-            *data = NULL;
-            *length = 0;
-        }
+        td_len = 2;
+        res = SWTPM_NVRAM_EncryptData(&migrationkey, &td[0], &td_len,
+                                      TAG_ENCRYPTED_MIGRATION_DATA,
+                                      buffer, buffer_len);
+        if (res)
+            goto err_exit;
+    } else {
+        td[0] = TLV_DATA(TAG_MIGRATION_DATA, buffer_len, buffer);
+        buffer = NULL;
+        td_len = 1;
     }
+    flags |= BLOB_FLAG_MIGRATION_DATA;
 
-    if (res == TPM_SUCCESS) {
-        /* put the header in clear text */
-        if (*is_encrypted)
-            flags |= BLOB_FLAG_ENCRYPTED;
+    res = tlv_data_append(data, length, td, td_len);
+    if (res)
+        goto err_exit;
 
-        res = SWTPM_NVRAM_PrependHeader(data, length, flags);
-    }
+    /* put the header in clear text */
+    if (*is_encrypted)
+        flags |= BLOB_FLAG_ENCRYPTED;
+
+    res = SWTPM_NVRAM_PrependHeader(data, length, flags);
+
+err_exit:
+    tlv_data_free(td, td_len);
+    TPM_Free(buffer);
+    TPM_Free(plain);
 
     return res;
 }
@@ -881,6 +1126,7 @@ TPM_RESULT SWTPM_NVRAM_SetStateBlob(unsigned char *data,
     uint16_t hdrflags;
     enum TPMLIB_StateType st = tpmlib_blobtype_to_statetype(blobtype);
     const char *blobname = tpmlib_get_blobname(blobtype);
+    uint8_t hdrversion;
 
     if (st == 0) {
         logprintf(STDERR_FILENO,
@@ -891,7 +1137,8 @@ TPM_RESULT SWTPM_NVRAM_SetStateBlob(unsigned char *data,
     if (length == 0)
         return TPMLIB_SetState(st, NULL, 0);
 
-    res = SWTPM_NVRAM_CheckHeader(data, length, &dataoffset, &hdrflags);
+    res = SWTPM_NVRAM_CheckHeader(data, length, &dataoffset, &hdrflags,
+                                  &hdrversion, false);
     if (res != TPM_SUCCESS)
         return res;
 
@@ -916,16 +1163,22 @@ TPM_RESULT SWTPM_NVRAM_SetStateBlob(unsigned char *data,
 
         res = SWTPM_NVRAM_DecryptData(&migrationkey,
                                       &mig_decrypt, &mig_decrypt_len,
-                                      &data[dataoffset], length - dataoffset);
-        if (res != 0) {
+                                      &data[dataoffset], length - dataoffset,
+                                      TAG_ENCRYPTED_MIGRATION_DATA,
+                                      hdrversion);
+        if (res) {
             logprintf(STDERR_FILENO,
                       ""Decrypting the %s blob with the migration key failed; ""
                       ""res = %d\n"", blobname, res);
             return res;
         }
     } else {
-        mig_decrypt = &data[dataoffset];
-        mig_decrypt_len = length - dataoffset;
+        res = SWTPM_NVRAM_GetPlainData(&mig_decrypt, &mig_decrypt_len,
+                                       &data[dataoffset], length - dataoffset,
+                                       TAG_MIGRATION_DATA,
+                                       hdrversion);
+        if (res)
+            return res;
     }
 
     /*
@@ -933,36 +1186,39 @@ TPM_RESULT SWTPM_NVRAM_SetStateBlob(unsigned char *data,
      * with the state encryption key, we need to decrypt them using that
      * key now.
      */
-    if (is_encrypted) {
+    if (is_encrypted || (hdrflags & BLOB_FLAG_ENCRYPTED)) {
         if (!SWTPM_NVRAM_Has_FileKey()) {
             logprintf(STDERR_FILENO,
                       ""Missing state key to decrypt %s\n"", blobname);
             res = TPM_KEYNOTFOUND;
             goto cleanup;
         }
-        res = SWTPM_NVRAM_DecryptData(&filekey,
-                                      &plain, &plain_len,
-                                      mig_decrypt, mig_decrypt_len);
-        if (res != 0) {
+        res = SWTPM_NVRAM_DecryptData(&filekey, &plain, &plain_len,
+                                      mig_decrypt, mig_decrypt_len,
+                                      TAG_ENCRYPTED_DATA,
+                                      hdrversion);
+        if (res) {
             logprintf(STDERR_FILENO,
                       ""Decrypting the %s blob with the state key ""
                       ""failed; res = %d\n"", blobname, res);
             goto cleanup;
         }
     } else {
-        plain_len = mig_decrypt_len;
-        plain = mig_decrypt;
+        res = SWTPM_NVRAM_GetPlainData(&plain, &plain_len,
+                                       mig_decrypt, mig_decrypt_len,
+                                       TAG_DATA,
+                                       hdrversion);
+        if (res)
+            goto cleanup;
     }
 
     /* SetState will make a copy of the buffer */
     res = TPMLIB_SetState(st, plain, plain_len);
 
-    if (plain != mig_decrypt)
-        TPM_Free(plain);
+    TPM_Free(plain);
 
 cleanup:
-    if (mig_decrypt != &data[dataoffset])
-        TPM_Free(mig_decrypt);
+    TPM_Free(mig_decrypt);
 
     return res;
 }
",1,src/swtpm/swtpm_nvfile.c,600,java,stefanberger___swtpm,test
6636,31208,77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0,"@@ -22,49 +22,12 @@
  * THE SOFTWARE.
  */
 #include ""qemu/osdep.h""
-#include ""hw/hw.h""
 #include ""hw/input/adb.h""
-#include ""hw/input/adb-keys.h""
-#include ""ui/console.h""
-#include ""ui/input.h""
-#include ""sysemu/sysemu.h""
-
-/* debug ADB */
-//#define DEBUG_ADB
-
-#ifdef DEBUG_ADB
-#define ADB_DPRINTF(fmt, ...) \
-do { printf(""ADB: "" fmt , ## __VA_ARGS__); } while (0)
-#else
-#define ADB_DPRINTF(fmt, ...)
-#endif
-
-/* ADB commands */
-#define ADB_BUSRESET		0x00
-#define ADB_FLUSH               0x01
-#define ADB_WRITEREG		0x08
-#define ADB_READREG		0x0c
-
-/* ADB device commands */
-#define ADB_CMD_SELF_TEST		0xff
-#define ADB_CMD_CHANGE_ID		0xfe
-#define ADB_CMD_CHANGE_ID_AND_ACT	0xfd
-#define ADB_CMD_CHANGE_ID_AND_ENABLE	0x00
-
-/* ADB default device IDs (upper 4 bits of ADB command byte) */
-#define ADB_DEVID_DONGLE   1
-#define ADB_DEVID_KEYBOARD 2
-#define ADB_DEVID_MOUSE    3
-#define ADB_DEVID_TABLET   4
-#define ADB_DEVID_MODEM    5
-#define ADB_DEVID_MISC     7
+#include ""adb-internal.h""
 
 /* error codes */
 #define ADB_RET_NOTPRESENT (-2)
 
-/* The adb keyboard doesn't have every key imaginable */
-#define NO_KEY 0xff
-
 static void adb_device_reset(ADBDevice *d)
 {
     qdev_reset_all(DEVICE(d));
@@ -127,7 +90,7 @@ static const TypeInfo adb_bus_type_info = {
     .instance_size = sizeof(ADBBusState),
 };
 
-static const VMStateDescription vmstate_adb_device = {
+const VMStateDescription vmstate_adb_device = {
     .name = ""adb_device"",
     .version_id = 0,
     .minimum_version_id = 0,
@@ -166,591 +129,10 @@ static const TypeInfo adb_device_type_info = {
     .class_init = adb_device_class_init,
 };
 
-/***************************************************************/
-/* Keyboard ADB device */
-
-#define ADB_KEYBOARD(obj) OBJECT_CHECK(KBDState, (obj), TYPE_ADB_KEYBOARD)
-
-typedef struct KBDState {
-    /*< private >*/
-    ADBDevice parent_obj;
-    /*< public >*/
-
-    uint8_t data[128];
-    int rptr, wptr, count;
-} KBDState;
-
-#define ADB_KEYBOARD_CLASS(class) \
-    OBJECT_CLASS_CHECK(ADBKeyboardClass, (class), TYPE_ADB_KEYBOARD)
-#define ADB_KEYBOARD_GET_CLASS(obj) \
-    OBJECT_GET_CLASS(ADBKeyboardClass, (obj), TYPE_ADB_KEYBOARD)
-
-typedef struct ADBKeyboardClass {
-    /*< private >*/
-    ADBDeviceClass parent_class;
-    /*< public >*/
-
-    DeviceRealize parent_realize;
-} ADBKeyboardClass;
-
-int qcode_to_adb_keycode[] = {
-     /* Make sure future additions are automatically set to NO_KEY */
-    [0 ... 0xff]               = NO_KEY,
-
-    [Q_KEY_CODE_SHIFT]         = ADB_KEY_LEFT_SHIFT,
-    [Q_KEY_CODE_SHIFT_R]       = ADB_KEY_RIGHT_SHIFT,
-    [Q_KEY_CODE_ALT]           = ADB_KEY_LEFT_OPTION,
-    [Q_KEY_CODE_ALT_R]         = ADB_KEY_RIGHT_OPTION,
-    [Q_KEY_CODE_CTRL]          = ADB_KEY_LEFT_CONTROL,
-    [Q_KEY_CODE_CTRL_R]        = ADB_KEY_RIGHT_CONTROL,
-    [Q_KEY_CODE_META_L]        = ADB_KEY_COMMAND,
-    [Q_KEY_CODE_META_R]        = ADB_KEY_COMMAND,
-    [Q_KEY_CODE_SPC]           = ADB_KEY_SPACEBAR,
-
-    [Q_KEY_CODE_ESC]           = ADB_KEY_ESC,
-    [Q_KEY_CODE_1]             = ADB_KEY_1,
-    [Q_KEY_CODE_2]             = ADB_KEY_2,
-    [Q_KEY_CODE_3]             = ADB_KEY_3,
-    [Q_KEY_CODE_4]             = ADB_KEY_4,
-    [Q_KEY_CODE_5]             = ADB_KEY_5,
-    [Q_KEY_CODE_6]             = ADB_KEY_6,
-    [Q_KEY_CODE_7]             = ADB_KEY_7,
-    [Q_KEY_CODE_8]             = ADB_KEY_8,
-    [Q_KEY_CODE_9]             = ADB_KEY_9,
-    [Q_KEY_CODE_0]             = ADB_KEY_0,
-    [Q_KEY_CODE_MINUS]         = ADB_KEY_MINUS,
-    [Q_KEY_CODE_EQUAL]         = ADB_KEY_EQUAL,
-    [Q_KEY_CODE_BACKSPACE]     = ADB_KEY_DELETE,
-    [Q_KEY_CODE_TAB]           = ADB_KEY_TAB,
-    [Q_KEY_CODE_Q]             = ADB_KEY_Q,
-    [Q_KEY_CODE_W]             = ADB_KEY_W,
-    [Q_KEY_CODE_E]             = ADB_KEY_E,
-    [Q_KEY_CODE_R]             = ADB_KEY_R,
-    [Q_KEY_CODE_T]             = ADB_KEY_T,
-    [Q_KEY_CODE_Y]             = ADB_KEY_Y,
-    [Q_KEY_CODE_U]             = ADB_KEY_U,
-    [Q_KEY_CODE_I]             = ADB_KEY_I,
-    [Q_KEY_CODE_O]             = ADB_KEY_O,
-    [Q_KEY_CODE_P]             = ADB_KEY_P,
-    [Q_KEY_CODE_BRACKET_LEFT]  = ADB_KEY_LEFT_BRACKET,
-    [Q_KEY_CODE_BRACKET_RIGHT] = ADB_KEY_RIGHT_BRACKET,
-    [Q_KEY_CODE_RET]           = ADB_KEY_RETURN,
-    [Q_KEY_CODE_A]             = ADB_KEY_A,
-    [Q_KEY_CODE_S]             = ADB_KEY_S,
-    [Q_KEY_CODE_D]             = ADB_KEY_D,
-    [Q_KEY_CODE_F]             = ADB_KEY_F,
-    [Q_KEY_CODE_G]             = ADB_KEY_G,
-    [Q_KEY_CODE_H]             = ADB_KEY_H,
-    [Q_KEY_CODE_J]             = ADB_KEY_J,
-    [Q_KEY_CODE_K]             = ADB_KEY_K,
-    [Q_KEY_CODE_L]             = ADB_KEY_L,
-    [Q_KEY_CODE_SEMICOLON]     = ADB_KEY_SEMICOLON,
-    [Q_KEY_CODE_APOSTROPHE]    = ADB_KEY_APOSTROPHE,
-    [Q_KEY_CODE_GRAVE_ACCENT]  = ADB_KEY_GRAVE_ACCENT,
-    [Q_KEY_CODE_BACKSLASH]     = ADB_KEY_BACKSLASH,
-    [Q_KEY_CODE_Z]             = ADB_KEY_Z,
-    [Q_KEY_CODE_X]             = ADB_KEY_X,
-    [Q_KEY_CODE_C]             = ADB_KEY_C,
-    [Q_KEY_CODE_V]             = ADB_KEY_V,
-    [Q_KEY_CODE_B]             = ADB_KEY_B,
-    [Q_KEY_CODE_N]             = ADB_KEY_N,
-    [Q_KEY_CODE_M]             = ADB_KEY_M,
-    [Q_KEY_CODE_COMMA]         = ADB_KEY_COMMA,
-    [Q_KEY_CODE_DOT]           = ADB_KEY_PERIOD,
-    [Q_KEY_CODE_SLASH]         = ADB_KEY_FORWARD_SLASH,
-    [Q_KEY_CODE_ASTERISK]      = ADB_KEY_KP_MULTIPLY,
-    [Q_KEY_CODE_CAPS_LOCK]     = ADB_KEY_CAPS_LOCK,
-
-    [Q_KEY_CODE_F1]            = ADB_KEY_F1,
-    [Q_KEY_CODE_F2]            = ADB_KEY_F2,
-    [Q_KEY_CODE_F3]            = ADB_KEY_F3,
-    [Q_KEY_CODE_F4]            = ADB_KEY_F4,
-    [Q_KEY_CODE_F5]            = ADB_KEY_F5,
-    [Q_KEY_CODE_F6]            = ADB_KEY_F6,
-    [Q_KEY_CODE_F7]            = ADB_KEY_F7,
-    [Q_KEY_CODE_F8]            = ADB_KEY_F8,
-    [Q_KEY_CODE_F9]            = ADB_KEY_F9,
-    [Q_KEY_CODE_F10]           = ADB_KEY_F10,
-    [Q_KEY_CODE_F11]           = ADB_KEY_F11,
-    [Q_KEY_CODE_F12]           = ADB_KEY_F12,
-    [Q_KEY_CODE_PRINT]         = ADB_KEY_F13,
-    [Q_KEY_CODE_SYSRQ]         = ADB_KEY_F13,
-    [Q_KEY_CODE_SCROLL_LOCK]   = ADB_KEY_F14,
-    [Q_KEY_CODE_PAUSE]         = ADB_KEY_F15,
-
-    [Q_KEY_CODE_NUM_LOCK]      = ADB_KEY_KP_CLEAR,
-    [Q_KEY_CODE_KP_EQUALS]     = ADB_KEY_KP_EQUAL,
-    [Q_KEY_CODE_KP_DIVIDE]     = ADB_KEY_KP_DIVIDE,
-    [Q_KEY_CODE_KP_MULTIPLY]   = ADB_KEY_KP_MULTIPLY,
-    [Q_KEY_CODE_KP_SUBTRACT]   = ADB_KEY_KP_SUBTRACT,
-    [Q_KEY_CODE_KP_ADD]        = ADB_KEY_KP_PLUS,
-    [Q_KEY_CODE_KP_ENTER]      = ADB_KEY_KP_ENTER,
-    [Q_KEY_CODE_KP_DECIMAL]    = ADB_KEY_KP_PERIOD,
-    [Q_KEY_CODE_KP_0]          = ADB_KEY_KP_0,
-    [Q_KEY_CODE_KP_1]          = ADB_KEY_KP_1,
-    [Q_KEY_CODE_KP_2]          = ADB_KEY_KP_2,
-    [Q_KEY_CODE_KP_3]          = ADB_KEY_KP_3,
-    [Q_KEY_CODE_KP_4]          = ADB_KEY_KP_4,
-    [Q_KEY_CODE_KP_5]          = ADB_KEY_KP_5,
-    [Q_KEY_CODE_KP_6]          = ADB_KEY_KP_6,
-    [Q_KEY_CODE_KP_7]          = ADB_KEY_KP_7,
-    [Q_KEY_CODE_KP_8]          = ADB_KEY_KP_8,
-    [Q_KEY_CODE_KP_9]          = ADB_KEY_KP_9,
-
-    [Q_KEY_CODE_UP]            = ADB_KEY_UP,
-    [Q_KEY_CODE_DOWN]          = ADB_KEY_DOWN,
-    [Q_KEY_CODE_LEFT]          = ADB_KEY_LEFT,
-    [Q_KEY_CODE_RIGHT]         = ADB_KEY_RIGHT,
-
-    [Q_KEY_CODE_HELP]          = ADB_KEY_HELP,
-    [Q_KEY_CODE_INSERT]        = ADB_KEY_HELP,
-    [Q_KEY_CODE_DELETE]        = ADB_KEY_FORWARD_DELETE,
-    [Q_KEY_CODE_HOME]          = ADB_KEY_HOME,
-    [Q_KEY_CODE_END]           = ADB_KEY_END,
-    [Q_KEY_CODE_PGUP]          = ADB_KEY_PAGE_UP,
-    [Q_KEY_CODE_PGDN]          = ADB_KEY_PAGE_DOWN,
-
-    [Q_KEY_CODE_POWER]         = ADB_KEY_POWER
-};
-
-static void adb_kbd_put_keycode(void *opaque, int keycode)
-{
-    KBDState *s = opaque;
-
-    if (s->count < sizeof(s->data)) {
-        s->data[s->wptr] = keycode;
-        if (++s->wptr == sizeof(s->data))
-            s->wptr = 0;
-        s->count++;
-    }
-}
-
-static int adb_kbd_poll(ADBDevice *d, uint8_t *obuf)
-{
-    KBDState *s = ADB_KEYBOARD(d);
-    int keycode;
-    int olen;
-
-    olen = 0;
-    if (s->count == 0) {
-        return 0;
-    }
-    keycode = s->data[s->rptr];
-    s->rptr++;
-    if (s->rptr == sizeof(s->data)) {
-        s->rptr = 0;
-    }
-    s->count--;
-    /*
-     * The power key is the only two byte value key, so it is a special case.
-     * Since 0x7f is not a used keycode for ADB we overload it to indicate the
-     * power button when we're storing keycodes in our internal buffer, and
-     * expand it out to two bytes when we send to the guest.
-     */
-    if (keycode == 0x7f) {
-        obuf[0] = 0x7f;
-        obuf[1] = 0x7f;
-        olen = 2;
-    } else {
-        obuf[0] = keycode;
-        /* NOTE: the power key key-up is the two byte sequence 0xff 0xff;
-         * otherwise we could in theory send a second keycode in the second
-         * byte, but choose not to bother.
-         */
-        obuf[1] = 0xff;
-        olen = 2;
-    }
-
-    return olen;
-}
-
-static int adb_kbd_request(ADBDevice *d, uint8_t *obuf,
-                           const uint8_t *buf, int len)
-{
-    KBDState *s = ADB_KEYBOARD(d);
-    int cmd, reg, olen;
-
-    if ((buf[0] & 0x0f) == ADB_FLUSH) {
-        /* flush keyboard fifo */
-        s->wptr = s->rptr = s->count = 0;
-        return 0;
-    }
-
-    cmd = buf[0] & 0xc;
-    reg = buf[0] & 0x3;
-    olen = 0;
-    switch(cmd) {
-    case ADB_WRITEREG:
-        switch(reg) {
-        case 2:
-            /* LED status */
-            break;
-        case 3:
-            switch(buf[2]) {
-            case ADB_CMD_SELF_TEST:
-                break;
-            case ADB_CMD_CHANGE_ID:
-            case ADB_CMD_CHANGE_ID_AND_ACT:
-            case ADB_CMD_CHANGE_ID_AND_ENABLE:
-                d->devaddr = buf[1] & 0xf;
-                break;
-            default:
-                d->devaddr = buf[1] & 0xf;
-                /* we support handlers:
-                 * 1: Apple Standard Keyboard
-                 * 2: Apple Extended Keyboard (LShift = RShift)
-                 * 3: Apple Extended Keyboard (LShift != RShift)
-                 */
-                if (buf[2] == 1 || buf[2] == 2 || buf[2] == 3) {
-                    d->handler = buf[2];
-                }
-                break;
-            }
-        }
-        break;
-    case ADB_READREG:
-        switch(reg) {
-        case 0:
-            olen = adb_kbd_poll(d, obuf);
-            break;
-        case 1:
-            break;
-        case 2:
-            obuf[0] = 0x00; /* XXX: check this */
-            obuf[1] = 0x07; /* led status */
-            olen = 2;
-            break;
-        case 3:
-            obuf[0] = d->handler;
-            obuf[1] = d->devaddr;
-            olen = 2;
-            break;
-        }
-        break;
-    }
-    return olen;
-}
-
-/* This is where keyboard events enter this file */
-static void adb_keyboard_event(DeviceState *dev, QemuConsole *src,
-                               InputEvent *evt)
-{
-    KBDState *s = (KBDState *)dev;
-    int qcode, keycode;
-
-    qcode = qemu_input_key_value_to_qcode(evt->u.key.data->key);
-    if (qcode >= ARRAY_SIZE(qcode_to_adb_keycode)) {
-        return;
-    }
-    /* FIXME: take handler into account when translating qcode */
-    keycode = qcode_to_adb_keycode[qcode];
-    if (keycode == NO_KEY) {  /* We don't want to send this to the guest */
-        ADB_DPRINTF(""Ignoring NO_KEY\n"");
-        return;
-    }
-    if (evt->u.key.data->down == false) { /* if key release event */
-        keycode = keycode | 0x80;   /* create keyboard break code */
-    }
-
-    adb_kbd_put_keycode(s, keycode);
-}
-
-static const VMStateDescription vmstate_adb_kbd = {
-    .name = ""adb_kbd"",
-    .version_id = 2,
-    .minimum_version_id = 2,
-    .fields = (VMStateField[]) {
-        VMSTATE_STRUCT(parent_obj, KBDState, 0, vmstate_adb_device, ADBDevice),
-        VMSTATE_BUFFER(data, KBDState),
-        VMSTATE_INT32(rptr, KBDState),
-        VMSTATE_INT32(wptr, KBDState),
-        VMSTATE_INT32(count, KBDState),
-        VMSTATE_END_OF_LIST()
-    }
-};
-
-static void adb_kbd_reset(DeviceState *dev)
-{
-    ADBDevice *d = ADB_DEVICE(dev);
-    KBDState *s = ADB_KEYBOARD(dev);
-
-    d->handler = 1;
-    d->devaddr = ADB_DEVID_KEYBOARD;
-    memset(s->data, 0, sizeof(s->data));
-    s->rptr = 0;
-    s->wptr = 0;
-    s->count = 0;
-}
-
-static QemuInputHandler adb_keyboard_handler = {
-    .name  = ""QEMU ADB Keyboard"",
-    .mask  = INPUT_EVENT_MASK_KEY,
-    .event = adb_keyboard_event,
-};
-
-static void adb_kbd_realizefn(DeviceState *dev, Error **errp)
-{
-    ADBKeyboardClass *akc = ADB_KEYBOARD_GET_CLASS(dev);
-    akc->parent_realize(dev, errp);
-    qemu_input_handler_register(dev, &adb_keyboard_handler);
-}
-
-static void adb_kbd_initfn(Object *obj)
-{
-    ADBDevice *d = ADB_DEVICE(obj);
-
-    d->devaddr = ADB_DEVID_KEYBOARD;
-}
-
-static void adb_kbd_class_init(ObjectClass *oc, void *data)
-{
-    DeviceClass *dc = DEVICE_CLASS(oc);
-    ADBDeviceClass *adc = ADB_DEVICE_CLASS(oc);
-    ADBKeyboardClass *akc = ADB_KEYBOARD_CLASS(oc);
-
-    akc->parent_realize = dc->realize;
-    dc->realize = adb_kbd_realizefn;
-    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-
-    adc->devreq = adb_kbd_request;
-    dc->reset = adb_kbd_reset;
-    dc->vmsd = &vmstate_adb_kbd;
-}
-
-static const TypeInfo adb_kbd_type_info = {
-    .name = TYPE_ADB_KEYBOARD,
-    .parent = TYPE_ADB_DEVICE,
-    .instance_size = sizeof(KBDState),
-    .instance_init = adb_kbd_initfn,
-    .class_init = adb_kbd_class_init,
-    .class_size = sizeof(ADBKeyboardClass),
-};
-
-/***************************************************************/
-/* Mouse ADB device */
-
-#define ADB_MOUSE(obj) OBJECT_CHECK(MouseState, (obj), TYPE_ADB_MOUSE)
-
-typedef struct MouseState {
-    /*< public >*/
-    ADBDevice parent_obj;
-    /*< private >*/
-
-    int buttons_state, last_buttons_state;
-    int dx, dy, dz;
-} MouseState;
-
-#define ADB_MOUSE_CLASS(class) \
-    OBJECT_CLASS_CHECK(ADBMouseClass, (class), TYPE_ADB_MOUSE)
-#define ADB_MOUSE_GET_CLASS(obj) \
-    OBJECT_GET_CLASS(ADBMouseClass, (obj), TYPE_ADB_MOUSE)
-
-typedef struct ADBMouseClass {
-    /*< public >*/
-    ADBDeviceClass parent_class;
-    /*< private >*/
-
-    DeviceRealize parent_realize;
-} ADBMouseClass;
-
-static void adb_mouse_event(void *opaque,
-                            int dx1, int dy1, int dz1, int buttons_state)
-{
-    MouseState *s = opaque;
-
-    s->dx += dx1;
-    s->dy += dy1;
-    s->dz += dz1;
-    s->buttons_state = buttons_state;
-}
-
-
-static int adb_mouse_poll(ADBDevice *d, uint8_t *obuf)
-{
-    MouseState *s = ADB_MOUSE(d);
-    int dx, dy;
-
-    if (s->last_buttons_state == s->buttons_state &&
-        s->dx == 0 && s->dy == 0)
-        return 0;
-
-    dx = s->dx;
-    if (dx < -63)
-        dx = -63;
-    else if (dx > 63)
-        dx = 63;
-
-    dy = s->dy;
-    if (dy < -63)
-        dy = -63;
-    else if (dy > 63)
-        dy = 63;
-
-    s->dx -= dx;
-    s->dy -= dy;
-    s->last_buttons_state = s->buttons_state;
-
-    dx &= 0x7f;
-    dy &= 0x7f;
-
-    if (!(s->buttons_state & MOUSE_EVENT_LBUTTON))
-        dy |= 0x80;
-    if (!(s->buttons_state & MOUSE_EVENT_RBUTTON))
-        dx |= 0x80;
-
-    obuf[0] = dy;
-    obuf[1] = dx;
-    return 2;
-}
-
-static int adb_mouse_request(ADBDevice *d, uint8_t *obuf,
-                             const uint8_t *buf, int len)
-{
-    MouseState *s = ADB_MOUSE(d);
-    int cmd, reg, olen;
-
-    if ((buf[0] & 0x0f) == ADB_FLUSH) {
-        /* flush mouse fifo */
-        s->buttons_state = s->last_buttons_state;
-        s->dx = 0;
-        s->dy = 0;
-        s->dz = 0;
-        return 0;
-    }
-
-    cmd = buf[0] & 0xc;
-    reg = buf[0] & 0x3;
-    olen = 0;
-    switch(cmd) {
-    case ADB_WRITEREG:
-        ADB_DPRINTF(""write reg %d val 0x%2.2x\n"", reg, buf[1]);
-        switch(reg) {
-        case 2:
-            break;
-        case 3:
-            switch(buf[2]) {
-            case ADB_CMD_SELF_TEST:
-                break;
-            case ADB_CMD_CHANGE_ID:
-            case ADB_CMD_CHANGE_ID_AND_ACT:
-            case ADB_CMD_CHANGE_ID_AND_ENABLE:
-                d->devaddr = buf[1] & 0xf;
-                break;
-            default:
-                d->devaddr = buf[1] & 0xf;
-                /* we support handlers:
-                 * 0x01: Classic Apple Mouse Protocol / 100 cpi operations
-                 * 0x02: Classic Apple Mouse Protocol / 200 cpi operations
-                 * we don't support handlers (at least):
-                 * 0x03: Mouse systems A3 trackball
-                 * 0x04: Extended Apple Mouse Protocol
-                 * 0x2f: Microspeed mouse
-                 * 0x42: Macally
-                 * 0x5f: Microspeed mouse
-                 * 0x66: Microspeed mouse
-                 */
-                if (buf[2] == 1 || buf[2] == 2) {
-                    d->handler = buf[2];
-                }
-                break;
-            }
-        }
-        break;
-    case ADB_READREG:
-        switch(reg) {
-        case 0:
-            olen = adb_mouse_poll(d, obuf);
-            break;
-        case 1:
-            break;
-        case 3:
-            obuf[0] = d->handler;
-            obuf[1] = d->devaddr;
-            olen = 2;
-            break;
-        }
-        ADB_DPRINTF(""read reg %d obuf[0] 0x%2.2x obuf[1] 0x%2.2x\n"", reg,
-                    obuf[0], obuf[1]);
-        break;
-    }
-    return olen;
-}
-
-static void adb_mouse_reset(DeviceState *dev)
-{
-    ADBDevice *d = ADB_DEVICE(dev);
-    MouseState *s = ADB_MOUSE(dev);
-
-    d->handler = 2;
-    d->devaddr = ADB_DEVID_MOUSE;
-    s->last_buttons_state = s->buttons_state = 0;
-    s->dx = s->dy = s->dz = 0;
-}
-
-static const VMStateDescription vmstate_adb_mouse = {
-    .name = ""adb_mouse"",
-    .version_id = 2,
-    .minimum_version_id = 2,
-    .fields = (VMStateField[]) {
-        VMSTATE_STRUCT(parent_obj, MouseState, 0, vmstate_adb_device,
-                       ADBDevice),
-        VMSTATE_INT32(buttons_state, MouseState),
-        VMSTATE_INT32(last_buttons_state, MouseState),
-        VMSTATE_INT32(dx, MouseState),
-        VMSTATE_INT32(dy, MouseState),
-        VMSTATE_INT32(dz, MouseState),
-        VMSTATE_END_OF_LIST()
-    }
-};
-
-static void adb_mouse_realizefn(DeviceState *dev, Error **errp)
-{
-    MouseState *s = ADB_MOUSE(dev);
-    ADBMouseClass *amc = ADB_MOUSE_GET_CLASS(dev);
-
-    amc->parent_realize(dev, errp);
-
-    qemu_add_mouse_event_handler(adb_mouse_event, s, 0, ""QEMU ADB Mouse"");
-}
-
-static void adb_mouse_initfn(Object *obj)
-{
-    ADBDevice *d = ADB_DEVICE(obj);
-
-    d->devaddr = ADB_DEVID_MOUSE;
-}
-
-static void adb_mouse_class_init(ObjectClass *oc, void *data)
-{
-    DeviceClass *dc = DEVICE_CLASS(oc);
-    ADBDeviceClass *adc = ADB_DEVICE_CLASS(oc);
-    ADBMouseClass *amc = ADB_MOUSE_CLASS(oc);
-
-    amc->parent_realize = dc->realize;
-    dc->realize = adb_mouse_realizefn;
-    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-
-    adc->devreq = adb_mouse_request;
-    dc->reset = adb_mouse_reset;
-    dc->vmsd = &vmstate_adb_mouse;
-}
-
-static const TypeInfo adb_mouse_type_info = {
-    .name = TYPE_ADB_MOUSE,
-    .parent = TYPE_ADB_DEVICE,
-    .instance_size = sizeof(MouseState),
-    .instance_init = adb_mouse_initfn,
-    .class_init = adb_mouse_class_init,
-    .class_size = sizeof(ADBMouseClass),
-};
-
-
 static void adb_register_types(void)
 {
     type_register_static(&adb_bus_type_info);
     type_register_static(&adb_device_type_info);
-    type_register_static(&adb_kbd_type_info);
-    type_register_static(&adb_mouse_type_info);
 }
 
 type_init(adb_register_types)
",0,hw/input/adb.c,622,java,qemu___qemu,test
1239,5986,db5fae32294763677caa4c1417dcba704c7e764e,"@@ -177,10 +177,10 @@ static int make_ydt15_entry(int p1, int p2, int16_t *ydt)
     int lo, hi;
 
     lo = ydt[p1];
-    lo += (lo << 5) + (lo << 10);
+    lo += (lo * 32) + (lo * 1024);
     hi = ydt[p2];
-    hi += (hi << 5) + (hi << 10);
-    return (lo + (hi << 16)) << 1;
+    hi += (hi * 32) + (hi * 1024);
+    return (lo + (hi * (1 << 16))) * 2;
 }
 
 static int make_cdt15_entry(int p1, int p2, int16_t *cdt)
@@ -188,9 +188,9 @@ static int make_cdt15_entry(int p1, int p2, int16_t *cdt)
     int r, b, lo;
 
     b = cdt[p2];
-    r = cdt[p1] << 10;
+    r = cdt[p1] * 1024;
     lo = b + r;
-    return (lo + (lo << 16)) << 1;
+    return (lo + (lo * (1 << 16))) * 2;
 }
 
 #if HAVE_BIGENDIAN
",1,libavcodec/truemotion1.c,10,java,ffmpeg___ffmpeg,test
7028,32990,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement
   // of one of them here.
   using HTMLElement::GetExecutionContext;
 
-  bool HasSingleSecurityOrigin() const {
-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()
-                               : true;
-  }
-
   bool IsFullscreen() const;
   virtual bool UsesOverlayFullscreenVideo() const { return false; }
 
",0,third_party/blink/renderer/core/html/media/html_media_element.h,5,java,chromium___chromium,test
4952,23366,4bb823621629e82d0546c0941de1f543d0815e69,"@@ -22,7 +22,9 @@ public:
           auto* virtual_host = route_config->mutable_virtual_hosts(0);
           {
             auto* cors = virtual_host->mutable_cors();
-            cors->add_hidden_envoy_deprecated_allow_origin(""*"");
+            auto* regex = cors->add_allow_origin_string_match()->mutable_safe_regex();
+            regex->mutable_google_re2();
+            regex->set_regex("".*"");
             cors->set_allow_headers(""content-type,x-grpc-web"");
             cors->set_allow_methods(""GET,POST"");
           }
@@ -48,21 +50,19 @@ public:
             route->mutable_match()->set_prefix(""/cors-route-config"");
             route->mutable_route()->set_cluster(""cluster_0"");
             auto* cors = route->mutable_route()->mutable_cors();
-            cors->add_hidden_envoy_deprecated_allow_origin(""test-origin-1"");
-            cors->add_hidden_envoy_deprecated_allow_origin(""test-host-2"");
+            cors->add_allow_origin_string_match()->set_exact(""test-origin-1"");
+            cors->add_allow_origin_string_match()->set_exact(""test-host-2"");
             cors->set_allow_headers(""content-type"");
             cors->set_allow_methods(""POST"");
             cors->set_max_age(""100"");
           }
 
           {
-            // TODO(mattklein123): When deprecated config is removed, remove DEPRECATED_FEATURE_TEST
-            // from all tests below.
             auto* route = virtual_host->add_routes();
             route->mutable_match()->set_prefix(""/cors-credentials-allowed"");
             route->mutable_route()->set_cluster(""cluster_0"");
             auto* cors = route->mutable_route()->mutable_cors();
-            cors->add_hidden_envoy_deprecated_allow_origin(""test-origin-1"");
+            cors->add_allow_origin_string_match()->set_exact(""test-origin-1"");
             cors->mutable_allow_credentials()->set_value(true);
           }
 
@@ -82,13 +82,10 @@ public:
             route->mutable_match()->set_prefix(""/cors-expose-headers"");
             route->mutable_route()->set_cluster(""cluster_0"");
             auto* cors = route->mutable_route()->mutable_cors();
-            cors->add_hidden_envoy_deprecated_allow_origin(""test-origin-1"");
+            cors->add_allow_origin_string_match()->set_exact(""test-origin-1"");
             cors->set_expose_headers(""custom-header-1,custom-header-2"");
           }
         });
-    config_helper_.addRuntimeOverride(""envoy.deprecated_features:envoy.config.route.v3.CorsPolicy.""
-                                      ""hidden_envoy_deprecated_allow_origin"",
-                                      ""true"");
     HttpIntegrationTest::initialize();
   }
 
@@ -125,10 +122,7 @@ INSTANTIATE_TEST_SUITE_P(IpVersions, CorsFilterIntegrationTest,
                          testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                          TestUtility::ipTestParamsToString);
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestVHostConfigSuccess)) {
-  config_helper_.addRuntimeOverride(""envoy.deprecated_features:envoy.config.route.v3.""
-                                    ""CorsPolicy.hidden_envoy_deprecated_enabled"",
-                                    ""true"");
+TEST_P(CorsFilterIntegrationTest, TestVHostConfigSuccess) {
   testPreflight(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""OPTIONS""},
@@ -148,7 +142,7 @@ TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestVHostConfigSuccess
       });
 }
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestRouteConfigSuccess)) {
+TEST_P(CorsFilterIntegrationTest, TestRouteConfigSuccess) {
   testPreflight(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""OPTIONS""},
@@ -169,10 +163,7 @@ TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestRouteConfigSuccess
       });
 }
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestRouteConfigBadOrigin)) {
-  config_helper_.addRuntimeOverride(""envoy.deprecated_features:envoy.config.route.v3.""
-                                    ""CorsPolicy.hidden_envoy_deprecated_enabled"",
-                                    ""true"");
+TEST_P(CorsFilterIntegrationTest, TestRouteConfigBadOrigin) {
   testNormalRequest(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""OPTIONS""},
@@ -189,7 +180,7 @@ TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestRouteConfigBadOrig
       });
 }
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestCorsDisabled)) {
+TEST_P(CorsFilterIntegrationTest, TestCorsDisabled) {
   testNormalRequest(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""OPTIONS""},
@@ -206,41 +197,7 @@ TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestCorsDisabled)) {
       });
 }
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestLegacyCorsDisabled)) {
-  config_helper_.addRuntimeOverride(""envoy.deprecated_features:envoy.config.route.v3.""
-                                    ""CorsPolicy.hidden_envoy_deprecated_enabled"",
-                                    ""true"");
-
-  config_helper_.addConfigModifier(
-      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
-              hcm) -> void {
-        auto* route_config = hcm.mutable_route_config();
-        auto* virtual_host = route_config->mutable_virtual_hosts(0);
-        auto* route = virtual_host->add_routes();
-        route->mutable_match()->set_prefix(""/legacy-no-cors"");
-        route->mutable_route()->set_cluster(""cluster_0"");
-        route->mutable_route()
-            ->mutable_cors()
-            ->mutable_hidden_envoy_deprecated_enabled()
-            ->set_value(false);
-      });
-  testNormalRequest(
-      Http::TestRequestHeaderMapImpl{
-          {"":method"", ""OPTIONS""},
-          {"":path"", ""/legacy-no-cors/test""},
-          {"":scheme"", ""http""},
-          {"":authority"", ""test-host""},
-          {""access-control-request-method"", ""GET""},
-          {""origin"", ""test-origin""},
-      },
-      Http::TestResponseHeaderMapImpl{
-          {""server"", ""envoy""},
-          {""content-length"", ""0""},
-          {"":status"", ""200""},
-      });
-}
-
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestEncodeHeaders)) {
+TEST_P(CorsFilterIntegrationTest, TestEncodeHeaders) {
   testNormalRequest(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""GET""},
@@ -257,7 +214,7 @@ TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestEncodeHeaders)) {
       });
 }
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestEncodeHeadersCredentialsAllowed)) {
+TEST_P(CorsFilterIntegrationTest, TestEncodeHeadersCredentialsAllowed) {
   testNormalRequest(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""GET""},
@@ -275,7 +232,7 @@ TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestEncodeHeadersCrede
       });
 }
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestAllowedOriginRegex)) {
+TEST_P(CorsFilterIntegrationTest, TestAllowedOriginRegex) {
   testNormalRequest(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""GET""},
@@ -293,7 +250,7 @@ TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestAllowedOriginRegex
       });
 }
 
-TEST_P(CorsFilterIntegrationTest, DEPRECATED_FEATURE_TEST(TestExposeHeaders)) {
+TEST_P(CorsFilterIntegrationTest, TestExposeHeaders) {
   testNormalRequest(
       Http::TestRequestHeaderMapImpl{
           {"":method"", ""GET""},
",1,test/extensions/filters/http/cors/cors_filter_integration_test.cc,73,java,envoyproxy___envoy,test
49,217,3652556dab3ebfe0152232facc7304fe5754aecb,"@@ -0,0 +1,225 @@
+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include ""tensorflow/core/kernels/cwise_op_clip.h""
+
+namespace tensorflow {
+
+typedef Eigen::ThreadPoolDevice CPUDevice;
+typedef Eigen::GpuDevice GPUDevice;
+
+// Basic coefficient-wise tenary operations.
+// This is the case for example of the clip_by_value.
+//   Device: E.g., CPUDevice, GPUDevice.
+//   Functor: defined above. E.g., functor::clip.
+template <typename Device, typename T>
+class ClipOp : public OpKernel {
+ public:
+  explicit ClipOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}
+
+  void Compute(OpKernelContext* ctx) override {
+    const Tensor& in0 = ctx->input(0);
+    const Tensor& in1 = ctx->input(1);
+    const Tensor& in2 = ctx->input(2);
+
+    auto in0_flat = in0.flat<T>();
+    auto in1_flat = in1.flat<T>();
+    auto in2_flat = in2.flat<T>();
+    const Device& d = ctx->eigen_device<Device>();
+
+    Tensor* out = nullptr;
+    OP_REQUIRES_OK(
+        ctx, ctx->forward_input_or_allocate_output({0}, 0, in0.shape(), &out));
+    auto out_flat = out->flat<T>();
+    if (in1.shape() == in2.shape()) {
+      if (in0.shape() == in1.shape()) {
+        functor::TernaryClipOp<Device, T>()(d, in0_flat, in1_flat, in2_flat,
+                                            out_flat);
+      } else {
+        OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(in1.shape()),
+                    errors::InvalidArgument(
+                        ""clip_value_min and clip_value_max must be either of ""
+                        ""the same shape as input, or a scalar. "",
+                        ""input shape: "", in0.shape().DebugString(),
+                        ""clip_value_min shape: "", in1.shape().DebugString(),
+                        ""clip_value_max shape: "", in2.shape().DebugString()));
+        functor::UnaryClipOp<Device, T>()(d, in0_flat, in1_flat, in2_flat,
+                                          out_flat);
+      }
+    } else {
+      if (in0.shape() == in1.shape()) {
+        OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(in2.shape()),
+                    errors::InvalidArgument(
+                        ""clip_value_min and clip_value_max must be either of ""
+                        ""the same shape as input, or a scalar. "",
+                        ""input shape: "", in0.shape().DebugString(),
+                        ""clip_value_min shape: "", in1.shape().DebugString(),
+                        ""clip_value_max shape: "", in2.shape().DebugString()));
+        functor::BinaryLeftClipOp<Device, T>()(d, in0_flat, in1_flat, in2_flat,
+                                               out_flat);
+      } else {
+        OP_REQUIRES(ctx,
+                    (in0.shape() == in2.shape() &&
+                     TensorShapeUtils::IsScalar(in1.shape())),
+                    errors::InvalidArgument(
+                        ""clip_value_min and clip_value_max must be either of ""
+                        ""the same shape as input, or a scalar. "",
+                        ""input shape: "", in0.shape().DebugString(),
+                        ""clip_value_min shape: "", in1.shape().DebugString(),
+                        ""clip_value_max shape: "", in2.shape().DebugString()));
+        functor::BinaryRightClipOp<Device, T>()(d, in0_flat, in1_flat, in2_flat,
+                                                out_flat);
+      }
+    }
+  }
+};
+
+namespace functor {
+// Unary functor for clip [Tensor, Scalar, Scalar]
+template <typename T>
+struct UnaryClipFunc {
+  UnaryClipFunc(const T& value_min, const T& value_max)
+      : value_min(value_min), value_max(value_max) {}
+  const T operator()(const T& value) const {
+    return std::max(std::min(value, value_max), value_min);
+  }
+  T value_min;
+  T value_max;
+};
+template <typename T>
+struct UnaryClipOp<CPUDevice, T> {
+  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat& in0_flat,
+                  typename TTypes<T>::ConstFlat& in1_flat,
+                  typename TTypes<T>::ConstFlat& in2_flat,
+                  typename TTypes<T>::Flat& out_flat) const {
+    out_flat = in0_flat.unaryExpr(UnaryClipFunc<T>(in1_flat(0), in2_flat(0)));
+  }
+};
+
+// Binary functor for clip [Tensor, Scalar, Tensor]
+template <typename T>
+struct BinaryRightClipFunc {
+  explicit BinaryRightClipFunc(const T& value_min) : value_min(value_min) {}
+  const T operator()(const T& value, const T& value_max) const {
+    return std::max(std::min(value, value_max), value_min);
+  }
+  T value_min;
+};
+template <typename T>
+struct BinaryRightClipOp<CPUDevice, T> {
+  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat& in0_flat,
+                  typename TTypes<T>::ConstFlat& in1_flat,
+                  typename TTypes<T>::ConstFlat& in2_flat,
+                  typename TTypes<T>::Flat& out_flat) const {
+    out_flat =
+        in0_flat.binaryExpr(in2_flat, BinaryRightClipFunc<T>(in1_flat(0)));
+  }
+};
+
+// Binary functor for clip [Tensor, Tensor, Scalar]
+template <typename T>
+struct BinaryLeftClipFunc {
+  explicit BinaryLeftClipFunc(const T& value_max) : value_max(value_max) {}
+  const T operator()(const T& value, const T& value_min) const {
+    return std::max(std::min(value, value_max), value_min);
+  }
+  T value_max;
+};
+template <typename T>
+struct BinaryLeftClipOp<CPUDevice, T> {
+  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat& in0_flat,
+                  typename TTypes<T>::ConstFlat& in1_flat,
+                  typename TTypes<T>::ConstFlat& in2_flat,
+                  typename TTypes<T>::Flat& out_flat) const {
+    out_flat =
+        in0_flat.binaryExpr(in1_flat, BinaryLeftClipFunc<T>(in2_flat(0)));
+  }
+};
+
+// Ternary functor for clip [Tensor, Tensor, Tensor]
+template <typename T>
+struct TernaryClipOp<CPUDevice, T> {
+  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat& in0_flat,
+                  typename TTypes<T>::ConstFlat& in1_flat,
+                  typename TTypes<T>::ConstFlat& in2_flat,
+                  typename TTypes<T>::Flat& out_flat) const {
+    out_flat.device(d) = in0_flat.cwiseMin(in2_flat).cwiseMax(in1_flat);
+  }
+};
+
+#define INSTANTIATE_CPU(T)                         \
+  template struct UnaryClipOp<CPUDevice, T>;       \
+  template struct BinaryRightClipOp<CPUDevice, T>; \
+  template struct BinaryLeftClipOp<CPUDevice, T>;  \
+  template struct TernaryClipOp<CPUDevice, T>;
+INSTANTIATE_CPU(Eigen::half);
+INSTANTIATE_CPU(float);
+INSTANTIATE_CPU(double);
+INSTANTIATE_CPU(int8);
+INSTANTIATE_CPU(int16);
+INSTANTIATE_CPU(int32);
+INSTANTIATE_CPU(int64);
+INSTANTIATE_CPU(uint8);
+INSTANTIATE_CPU(uint16);
+#undef INSTANTIATE_CPU
+}  // namespace functor
+
+#define REGISTER_CPU_KERNEL(type)                                       \
+  REGISTER_KERNEL_BUILDER(                                              \
+      Name(""ClipByValue"").Device(DEVICE_CPU).TypeConstraint<type>(""T""), \
+      ClipOp<CPUDevice, type>);
+
+REGISTER_CPU_KERNEL(Eigen::half);
+REGISTER_CPU_KERNEL(float);
+REGISTER_CPU_KERNEL(double);
+REGISTER_CPU_KERNEL(int8);
+REGISTER_CPU_KERNEL(int16);
+REGISTER_CPU_KERNEL(int32);
+REGISTER_CPU_KERNEL(int64);
+REGISTER_CPU_KERNEL(uint8);
+REGISTER_CPU_KERNEL(uint16);
+#undef REGISTER_CPU_KERNEL
+
+#if GOOGLE_CUDA
+
+#define REGISTER_GPU_KERNEL(type)                                       \
+  REGISTER_KERNEL_BUILDER(                                              \
+      Name(""ClipByValue"").Device(DEVICE_GPU).TypeConstraint<type>(""T""), \
+      ClipOp<GPUDevice, type>);
+REGISTER_GPU_KERNEL(Eigen::half);
+REGISTER_GPU_KERNEL(float);
+REGISTER_GPU_KERNEL(double);
+REGISTER_GPU_KERNEL(int8);
+REGISTER_GPU_KERNEL(int16);
+REGISTER_GPU_KERNEL(int64);
+REGISTER_GPU_KERNEL(uint8);
+REGISTER_GPU_KERNEL(uint16);
+
+// A special GPU kernel for int32.
+// TODO(b/25387198): Also enable int32 in device memory. This kernel
+// registration requires all int32 inputs and outputs to be in host memory.
+REGISTER_KERNEL_BUILDER(Name(""ClipByValue"")
+                            .Device(DEVICE_GPU)
+                            .HostMemory(""t"")
+                            .HostMemory(""clip_value_min"")
+                            .HostMemory(""clip_value_max"")
+                            .HostMemory(""output"")
+                            .TypeConstraint<int32>(""T""),
+                        ClipOp<CPUDevice, int32>);
+
+#undef REGISTER_GPU_KERNEL
+#endif
+
+}  // namespace tensorflow
",1,tensorflow/core/kernels/cwise_op_clip.cc,225,java,tensorflow___tensorflow,test
5442,25670,ff630ed4f0977a7958117a277a2265884cf03d81,"@@ -3971,6 +3971,10 @@ JSValue gf_sg_script_to_qjs_field(GF_ScriptPriv *priv, GF_FieldInfo *field, GF_N
 			return JS_NULL;
 		}
 		parent->sgprivate->interact->js_binding->fields = gf_list_new();
+		if (!parent->sgprivate->interact->js_binding->fields) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (""[VRMLJS] Failed to create JS bindings storage\n""));
+			return JS_NULL;
+		}
 	}
 
 	if ( gf_list_find(parent->sgprivate->interact->js_binding->fields, jsf) < 0) {
",1,src/scenegraph/vrml_js.c,4,java,gpac___gpac,test
7468,35229,9c85329cd02e9284892bf263ce6133b2fc479792,"@@ -181,6 +181,8 @@ static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)
             dend   = c->frame[page] + c->frame_size;
             offset = (x & 0x7F) * 2;
             j      = bytestream2_get_le16(&c->gb) + offset;
+            if (bytestream2_get_bytes_left(&c->gb) < (j - offset) * 16)
+                return AVERROR_INVALIDDATA;
             do {
                 offset++;
                 if (dst + 3 * c->width + 4 > dend)
@@ -198,7 +200,8 @@ static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)
     do {
         set_src_position(c, &src, &send);
         if ((src + 3 * c->width + 4 > send) ||
-            (dst + 3 * c->width + 4 > dend))
+            (dst + 3 * c->width + 4 > dend) ||
+            bytestream2_get_bytes_left(&c->gb) < 4)
             return AVERROR_INVALIDDATA;
         copy_block4(dst, src, c->width, c->width, 4);
         i++;
",0,libavcodec/pafvideo.c,5,java,ffmpeg___ffmpeg,test
1294,6296,673ce95d481ea9368c4d4d43ac756ba1d6d9e608,"@@ -87,7 +87,8 @@ void MojoAudioOutputStream::OnStreamCreated(
   }
 
   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(
-      foreign_memory_handle, shared_memory->requested_size(), false);
+      foreign_memory_handle, shared_memory->requested_size(),
+      mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);
   mojo::ScopedHandle socket_handle =
       mojo::WrapPlatformFile(foreign_socket->Release());
 
",0,media/mojo/services/mojo_audio_output_stream.cc,3,java,chromium___chromium,test
8399,39753,eff2861a757b8a46398e6fcb844b960b4775daad,"@@ -701,12 +701,12 @@ static int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s,
             if ((ret = ff_thread_get_buffer(avctx, &s->previous_picture, AV_GET_BUFFER_FLAG_REF)) < 0)
                 return ret;
         }
-        ff_thread_finish_setup(avctx);
-
         p->pict_type        = AV_PICTURE_TYPE_I;
         p->key_frame        = 1;
         p->interlaced_frame = !!s->interlace_type;
 
+        ff_thread_finish_setup(avctx);
+
         /* compute the compressed row size */
         if (!s->interlace_type) {
             s->crow_size = s->row_size + 1;
",0,libavcodec/pngdec.c,4,java,ffmpeg___ffmpeg,test
9489,45249,92b540dac9fc3a572c7342edd0b073000f5a6abf,"@@ -43,12 +43,13 @@ static testdef_t tests[] = {
 static void check_guest_output(const testdef_t *test, int fd)
 {
     bool output_ok = false;
-    int i, nbr, pos = 0;
+    int i, nbr, pos = 0, ccnt;
     char ch;
 
     /* Poll serial output... Wait at most 60 seconds */
     for (i = 0; i < 6000; ++i) {
-        while ((nbr = read(fd, &ch, 1)) == 1) {
+        ccnt = 0;
+        while ((nbr = read(fd, &ch, 1)) == 1 && ccnt++ < 512) {
             if (ch == test->expect[pos]) {
                 pos += 1;
                 if (test->expect[pos] == '\0') {
",0,tests/boot-serial-test.c,5,java,qemu___qemu,test
9859,46848,318347234d7069b62d38391dd27e269a3107d668,"@@ -2655,7 +2655,8 @@ static void spapr_pending_dimm_unplugs_remove(sPAPRMachineState *spapr,
     g_free(dimm_state);
 }
 
-static void spapr_lmb_release(DeviceState *dev, void *opaque)
+/* Callback to be called during DRC release. */
+void spapr_lmb_release(DeviceState *dev)
 {
     HotplugHandler *hotplug_ctrl = qdev_get_hotplug_handler(dev);
     sPAPRMachineState *spapr = SPAPR_MACHINE(hotplug_ctrl);
@@ -2720,7 +2721,7 @@ static void spapr_memory_unplug_request(HotplugHandler *hotplug_dev,
         g_assert(drc);
 
         drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
-        drck->detach(drc, dev, spapr_lmb_release, NULL, errp);
+        drck->detach(drc, dev, errp);
         addr += SPAPR_MEMORY_BLOCK_SIZE;
     }
 
@@ -2767,7 +2768,8 @@ static void spapr_core_unplug(HotplugHandler *hotplug_dev, DeviceState *dev,
     object_unparent(OBJECT(dev));
 }
 
-static void spapr_core_release(DeviceState *dev, void *opaque)
+/* Callback to be called during DRC release. */
+void spapr_core_release(DeviceState *dev)
 {
     HotplugHandler *hotplug_ctrl;
 
@@ -2800,7 +2802,7 @@ void spapr_core_unplug_request(HotplugHandler *hotplug_dev, DeviceState *dev,
     g_assert(drc);
 
     drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
-    drck->detach(drc, dev, spapr_core_release, NULL, &local_err);
+    drck->detach(drc, dev, &local_err);
     if (local_err) {
         error_propagate(errp, local_err);
         return;
",1,hw/ppc/spapr.c,10,java,qemu___qemu,test
4646,21861,e1dab14cf68d1e03950135969af3faf322f0db04,"@@ -1,93 +1,16 @@
-/*
- * Core of Xen paravirt_ops implementation.
- *
- * This file contains the xen_paravirt_ops structure itself, and the
- * implementations for:
- * - privileged instructions
- * - interrupt flags
- * - segment operations
- * - booting and setup
- *
- * Jeremy Fitzhardinge <jeremy@xensource.com>, XenSource Inc, 2007
- */
-
 #include <linux/cpu.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/preempt.h>
-#include <linux/hardirq.h>
-#include <linux/percpu.h>
-#include <linux/delay.h>
-#include <linux/start_kernel.h>
-#include <linux/sched.h>
-#include <linux/kprobes.h>
-#include <linux/bootmem.h>
-#include <linux/export.h>
-#include <linux/mm.h>
-#include <linux/page-flags.h>
-#include <linux/highmem.h>
-#include <linux/console.h>
-#include <linux/pci.h>
-#include <linux/gfp.h>
-#include <linux/memblock.h>
-#include <linux/edd.h>
-#include <linux/frame.h>
-
 #include <linux/kexec.h>
 
-#include <xen/xen.h>
-#include <xen/events.h>
-#include <xen/interface/xen.h>
-#include <xen/interface/version.h>
-#include <xen/interface/physdev.h>
-#include <xen/interface/vcpu.h>
-#include <xen/interface/memory.h>
-#include <xen/interface/nmi.h>
-#include <xen/interface/xen-mca.h>
 #include <xen/features.h>
 #include <xen/page.h>
-#include <xen/hvc-console.h>
-#include <xen/acpi.h>
 
-#include <asm/paravirt.h>
-#include <asm/apic.h>
-#include <asm/page.h>
-#include <asm/xen/pci.h>
 #include <asm/xen/hypercall.h>
 #include <asm/xen/hypervisor.h>
-#include <asm/xen/cpuid.h>
-#include <asm/fixmap.h>
-#include <asm/processor.h>
-#include <asm/proto.h>
-#include <asm/msr-index.h>
-#include <asm/traps.h>
-#include <asm/setup.h>
-#include <asm/desc.h>
-#include <asm/pgalloc.h>
-#include <asm/pgtable.h>
-#include <asm/tlbflush.h>
-#include <asm/reboot.h>
-#include <asm/stackprotector.h>
-#include <asm/hypervisor.h>
-#include <asm/mach_traps.h>
-#include <asm/mwait.h>
-#include <asm/pci_x86.h>
 #include <asm/cpu.h>
 #include <asm/e820/api.h> 
 
-#ifdef CONFIG_ACPI
-#include <linux/acpi.h>
-#include <asm/acpi.h>
-#include <acpi/pdc_intel.h>
-#include <acpi/processor.h>
-#include <xen/interface/platform.h>
-#endif
-
 #include ""xen-ops.h""
-#include ""mmu.h""
 #include ""smp.h""
-#include ""multicalls.h""
 #include ""pmu.h""
 
 EXPORT_SYMBOL_GPL(hypercall_page);
@@ -134,14 +57,6 @@ EXPORT_SYMBOL_GPL(xen_start_info);
 
 struct shared_info xen_dummy_shared_info;
 
-void *xen_initial_gdt;
-
-RESERVE_BRK(shared_info_page_brk, PAGE_SIZE);
-
-static int xen_cpu_up_prepare_pv(unsigned int cpu);
-static int xen_cpu_up_online(unsigned int cpu);
-static int xen_cpu_dead_pv(unsigned int cpu);
-
 /*
  * Point at some empty memory to start with. We map the real shared_info
  * page as soon as fixmap is up and running.
@@ -163,18 +78,30 @@ struct shared_info *HYPERVISOR_shared_info = &xen_dummy_shared_info;
  */
 int xen_have_vcpu_info_placement = 1;
 
-struct tls_descs {
-	struct desc_struct desc[3];
-};
+static int xen_cpu_up_online(unsigned int cpu)
+{
+	xen_init_lock_cpu(cpu);
+	return 0;
+}
 
-/*
- * Updating the 3 TLS descriptors in the GDT on every task switch is
- * surprisingly expensive so we avoid updating them if they haven't
- * changed.  Since Xen writes different descriptors than the one
- * passed in the update_descriptor hypercall we keep shadow copies to
- * compare against.
- */
-static DEFINE_PER_CPU(struct tls_descs, shadow_tls_desc);
+int xen_cpuhp_setup(int (*cpu_up_prepare_cb)(unsigned int),
+		    int (*cpu_dead_cb)(unsigned int))
+{
+	int rc;
+
+	rc = cpuhp_setup_state_nocalls(CPUHP_XEN_PREPARE,
+				       ""x86/xen/hvm_guest:prepare"",
+				       cpu_up_prepare_cb, cpu_dead_cb);
+	if (rc >= 0) {
+		rc = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+					       ""x86/xen/hvm_guest:online"",
+					       xen_cpu_up_online, NULL);
+		if (rc < 0)
+			cpuhp_remove_state_nocalls(CPUHP_XEN_PREPARE);
+	}
+
+	return rc >= 0 ? 0 : rc;
+}
 
 static void clamp_max_cpus(void)
 {
@@ -243,1510 +170,81 @@ void xen_vcpu_setup(int cpu)
 	}
 }
 
-/*
- * On restore, set the vcpu placement up again.
- * If it fails, then we're in a bad state, since
- * we can't back out from using it...
- */
-void xen_vcpu_restore(void)
+void xen_reboot(int reason)
 {
+	struct sched_shutdown r = { .reason = reason };
 	int cpu;
 
-	for_each_possible_cpu(cpu) {
-		bool other_cpu = (cpu != smp_processor_id());
-		bool is_up = HYPERVISOR_vcpu_op(VCPUOP_is_up, xen_vcpu_nr(cpu),
-						NULL);
-
-		if (other_cpu && is_up &&
-		    HYPERVISOR_vcpu_op(VCPUOP_down, xen_vcpu_nr(cpu), NULL))
-			BUG();
-
-		xen_setup_runstate_info(cpu);
-
-		if (xen_have_vcpu_info_placement)
-			xen_vcpu_setup(cpu);
-
-		if (other_cpu && is_up &&
-		    HYPERVISOR_vcpu_op(VCPUOP_up, xen_vcpu_nr(cpu), NULL))
-			BUG();
-	}
-}
-
-static void __init xen_banner(void)
-{
-	unsigned version = HYPERVISOR_xen_version(XENVER_version, NULL);
-	struct xen_extraversion extra;
-	HYPERVISOR_xen_version(XENVER_extraversion, &extra);
-
-	pr_info(""Booting paravirtualized kernel %son %s\n"",
-		xen_feature(XENFEAT_auto_translated_physmap) ?
-			""with PVH extensions "" : """", pv_info.name);
-	printk(KERN_INFO ""Xen version: %d.%d%s%s\n"",
-	       version >> 16, version & 0xffff, extra.extraversion,
-	       xen_feature(XENFEAT_mmu_pt_update_preserve_ad) ? "" (preserve-AD)"" : """");
-}
-/* Check if running on Xen version (major, minor) or later */
-bool
-xen_running_on_version_or_later(unsigned int major, unsigned int minor)
-{
-	unsigned int version;
-
-	if (!xen_domain())
-		return false;
-
-	version = HYPERVISOR_xen_version(XENVER_version, NULL);
-	if ((((version >> 16) == major) && ((version & 0xffff) >= minor)) ||
-		((version >> 16) > major))
-		return true;
-	return false;
-}
-
-#define CPUID_THERM_POWER_LEAF 6
-#define APERFMPERF_PRESENT 0
-
-static __read_mostly unsigned int cpuid_leaf1_edx_mask = ~0;
-static __read_mostly unsigned int cpuid_leaf1_ecx_mask = ~0;
-
-static __read_mostly unsigned int cpuid_leaf1_ecx_set_mask;
-static __read_mostly unsigned int cpuid_leaf5_ecx_val;
-static __read_mostly unsigned int cpuid_leaf5_edx_val;
-
-static void xen_cpuid(unsigned int *ax, unsigned int *bx,
-		      unsigned int *cx, unsigned int *dx)
-{
-	unsigned maskebx = ~0;
-	unsigned maskecx = ~0;
-	unsigned maskedx = ~0;
-	unsigned setecx = 0;
-	/*
-	 * Mask out inconvenient features, to try and disable as many
-	 * unsupported kernel subsystems as possible.
-	 */
-	switch (*ax) {
-	case 1:
-		maskecx = cpuid_leaf1_ecx_mask;
-		setecx = cpuid_leaf1_ecx_set_mask;
-		maskedx = cpuid_leaf1_edx_mask;
-		break;
-
-	case CPUID_MWAIT_LEAF:
-		/* Synthesize the values.. */
-		*ax = 0;
-		*bx = 0;
-		*cx = cpuid_leaf5_ecx_val;
-		*dx = cpuid_leaf5_edx_val;
-		return;
-
-	case CPUID_THERM_POWER_LEAF:
-		/* Disabling APERFMPERF for kernel usage */
-		maskecx = ~(1 << APERFMPERF_PRESENT);
-		break;
-
-	case 0xb:
-		/* Suppress extended topology stuff */
-		maskebx = 0;
-		break;
-	}
-
-	asm(XEN_EMULATE_PREFIX ""cpuid""
-		: ""=a"" (*ax),
-		  ""=b"" (*bx),
-		  ""=c"" (*cx),
-		  ""=d"" (*dx)
-		: ""0"" (*ax), ""2"" (*cx));
-
-	*bx &= maskebx;
-	*cx &= maskecx;
-	*cx |= setecx;
-	*dx &= maskedx;
-}
-STACK_FRAME_NON_STANDARD(xen_cpuid); /* XEN_EMULATE_PREFIX */
-
-static bool __init xen_check_mwait(void)
-{
-#ifdef CONFIG_ACPI
-	struct xen_platform_op op = {
-		.cmd			= XENPF_set_processor_pminfo,
-		.u.set_pminfo.id	= -1,
-		.u.set_pminfo.type	= XEN_PM_PDC,
-	};
-	uint32_t buf[3];
-	unsigned int ax, bx, cx, dx;
-	unsigned int mwait_mask;
-
-	/* We need to determine whether it is OK to expose the MWAIT
-	 * capability to the kernel to harvest deeper than C3 states from ACPI
-	 * _CST using the processor_harvest_xen.c module. For this to work, we
-	 * need to gather the MWAIT_LEAF values (which the cstate.c code
-	 * checks against). The hypervisor won't expose the MWAIT flag because
-	 * it would break backwards compatibility; so we will find out directly
-	 * from the hardware and hypercall.
-	 */
-	if (!xen_initial_domain())
-		return false;
-
-	/*
-	 * When running under platform earlier than Xen4.2, do not expose
-	 * mwait, to avoid the risk of loading native acpi pad driver
-	 */
-	if (!xen_running_on_version_or_later(4, 2))
-		return false;
-
-	ax = 1;
-	cx = 0;
-
-	native_cpuid(&ax, &bx, &cx, &dx);
-
-	mwait_mask = (1 << (X86_FEATURE_EST % 32)) |
-		     (1 << (X86_FEATURE_MWAIT % 32));
-
-	if ((cx & mwait_mask) != mwait_mask)
-		return false;
-
-	/* We need to emulate the MWAIT_LEAF and for that we need both
-	 * ecx and edx. The hypercall provides only partial information.
-	 */
-
-	ax = CPUID_MWAIT_LEAF;
-	bx = 0;
-	cx = 0;
-	dx = 0;
-
-	native_cpuid(&ax, &bx, &cx, &dx);
-
-	/* Ask the Hypervisor whether to clear ACPI_PDC_C_C2C3_FFH. If so,
-	 * don't expose MWAIT_LEAF and let ACPI pick the IOPORT version of C3.
-	 */
-	buf[0] = ACPI_PDC_REVISION_ID;
-	buf[1] = 1;
-	buf[2] = (ACPI_PDC_C_CAPABILITY_SMP | ACPI_PDC_EST_CAPABILITY_SWSMP);
-
-	set_xen_guest_handle(op.u.set_pminfo.pdc, buf);
-
-	if ((HYPERVISOR_platform_op(&op) == 0) &&
-	    (buf[2] & (ACPI_PDC_C_C1_FFH | ACPI_PDC_C_C2C3_FFH))) {
-		cpuid_leaf5_ecx_val = cx;
-		cpuid_leaf5_edx_val = dx;
-	}
-	return true;
-#else
-	return false;
-#endif
-}
-static void __init xen_init_cpuid_mask(void)
-{
-	unsigned int ax, bx, cx, dx;
-	unsigned int xsave_mask;
-
-	cpuid_leaf1_edx_mask =
-		~((1 << X86_FEATURE_MTRR) |  /* disable MTRR */
-		  (1 << X86_FEATURE_ACC));   /* thermal monitoring */
-
-	if (!xen_initial_domain())
-		cpuid_leaf1_edx_mask &=
-			~((1 << X86_FEATURE_ACPI));  /* disable ACPI */
-
-	cpuid_leaf1_ecx_mask &= ~(1 << (X86_FEATURE_X2APIC % 32));
-
-	ax = 1;
-	cx = 0;
-	cpuid(1, &ax, &bx, &cx, &dx);
-
-	xsave_mask =
-		(1 << (X86_FEATURE_XSAVE % 32)) |
-		(1 << (X86_FEATURE_OSXSAVE % 32));
-
-	/* Xen will set CR4.OSXSAVE if supported and not disabled by force */
-	if ((cx & xsave_mask) != xsave_mask)
-		cpuid_leaf1_ecx_mask &= ~xsave_mask; /* disable XSAVE & OSXSAVE */
-	if (xen_check_mwait())
-		cpuid_leaf1_ecx_set_mask = (1 << (X86_FEATURE_MWAIT % 32));
-}
-
-static void xen_set_debugreg(int reg, unsigned long val)
-{
-	HYPERVISOR_set_debugreg(reg, val);
-}
-
-static unsigned long xen_get_debugreg(int reg)
-{
-	return HYPERVISOR_get_debugreg(reg);
-}
-
-static void xen_end_context_switch(struct task_struct *next)
-{
-	xen_mc_flush();
-	paravirt_end_context_switch(next);
-}
-
-static unsigned long xen_store_tr(void)
-{
-	return 0;
-}
-
-/*
- * Set the page permissions for a particular virtual address.  If the
- * address is a vmalloc mapping (or other non-linear mapping), then
- * find the linear mapping of the page and also set its protections to
- * match.
- */
-static void set_aliased_prot(void *v, pgprot_t prot)
-{
-	int level;
-	pte_t *ptep;
-	pte_t pte;
-	unsigned long pfn;
-	struct page *page;
-	unsigned char dummy;
-
-	ptep = lookup_address((unsigned long)v, &level);
-	BUG_ON(ptep == NULL);
-
-	pfn = pte_pfn(*ptep);
-	page = pfn_to_page(pfn);
-
-	pte = pfn_pte(pfn, prot);
-
-	/*
-	 * Careful: update_va_mapping() will fail if the virtual address
-	 * we're poking isn't populated in the page tables.  We don't
-	 * need to worry about the direct map (that's always in the page
-	 * tables), but we need to be careful about vmap space.  In
-	 * particular, the top level page table can lazily propagate
-	 * entries between processes, so if we've switched mms since we
-	 * vmapped the target in the first place, we might not have the
-	 * top-level page table entry populated.
-	 *
-	 * We disable preemption because we want the same mm active when
-	 * we probe the target and when we issue the hypercall.  We'll
-	 * have the same nominal mm, but if we're a kernel thread, lazy
-	 * mm dropping could change our pgd.
-	 *
-	 * Out of an abundance of caution, this uses __get_user() to fault
-	 * in the target address just in case there's some obscure case
-	 * in which the target address isn't readable.
-	 */
-
-	preempt_disable();
-
-	probe_kernel_read(&dummy, v, 1);
+	for_each_online_cpu(cpu)
+		xen_pmu_finish(cpu);
 
-	if (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))
+	if (HYPERVISOR_sched_op(SCHEDOP_shutdown, &r))
 		BUG();
-
-	if (!PageHighMem(page)) {
-		void *av = __va(PFN_PHYS(pfn));
-
-		if (av != v)
-			if (HYPERVISOR_update_va_mapping((unsigned long)av, pte, 0))
-				BUG();
-	} else
-		kmap_flush_unused();
-
-	preempt_enable();
-}
-
-static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
-{
-	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
-	int i;
-
-	/*
-	 * We need to mark the all aliases of the LDT pages RO.  We
-	 * don't need to call vm_flush_aliases(), though, since that's
-	 * only responsible for flushing aliases out the TLBs, not the
-	 * page tables, and Xen will flush the TLB for us if needed.
-	 *
-	 * To avoid confusing future readers: none of this is necessary
-	 * to load the LDT.  The hypervisor only checks this when the
-	 * LDT is faulted in due to subsequent descriptor access.
-	 */
-
-	for(i = 0; i < entries; i += entries_per_page)
-		set_aliased_prot(ldt + i, PAGE_KERNEL_RO);
 }
 
-static void xen_free_ldt(struct desc_struct *ldt, unsigned entries)
-{
-	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
-	int i;
-
-	for(i = 0; i < entries; i += entries_per_page)
-		set_aliased_prot(ldt + i, PAGE_KERNEL);
-}
-
-static void xen_set_ldt(const void *addr, unsigned entries)
+void xen_emergency_restart(void)
 {
-	struct mmuext_op *op;
-	struct multicall_space mcs = xen_mc_entry(sizeof(*op));
-
-	trace_xen_cpu_set_ldt(addr, entries);
-
-	op = mcs.args;
-	op->cmd = MMUEXT_SET_LDT;
-	op->arg1.linear_addr = (unsigned long)addr;
-	op->arg2.nr_ents = entries;
-
-	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);
-
-	xen_mc_issue(PARAVIRT_LAZY_CPU);
+	xen_reboot(SHUTDOWN_reboot);
 }
 
-static void xen_load_gdt(const struct desc_ptr *dtr)
+static int
+xen_panic_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
-	unsigned long va = dtr->address;
-	unsigned int size = dtr->size + 1;
-	unsigned pages = DIV_ROUND_UP(size, PAGE_SIZE);
-	unsigned long frames[pages];
-	int f;
-
-	/*
-	 * A GDT can be up to 64k in size, which corresponds to 8192
-	 * 8-byte entries, or 16 4k pages..
-	 */
-
-	BUG_ON(size > 65536);
-	BUG_ON(va & ~PAGE_MASK);
-
-	for (f = 0; va < dtr->address + size; va += PAGE_SIZE, f++) {
-		int level;
-		pte_t *ptep;
-		unsigned long pfn, mfn;
-		void *virt;
-
-		/*
-		 * The GDT is per-cpu and is in the percpu data area.
-		 * That can be virtually mapped, so we need to do a
-		 * page-walk to get the underlying MFN for the
-		 * hypercall.  The page can also be in the kernel's
-		 * linear range, so we need to RO that mapping too.
-		 */
-		ptep = lookup_address(va, &level);
-		BUG_ON(ptep == NULL);
-
-		pfn = pte_pfn(*ptep);
-		mfn = pfn_to_mfn(pfn);
-		virt = __va(PFN_PHYS(pfn));
-
-		frames[f] = mfn;
-
-		make_lowmem_page_readonly((void *)va);
-		make_lowmem_page_readonly(virt);
-	}
-
-	if (HYPERVISOR_set_gdt(frames, size / sizeof(struct desc_struct)))
-		BUG();
+	if (!kexec_crash_loaded())
+		xen_reboot(SHUTDOWN_crash);
+	return NOTIFY_DONE;
 }
 
-/*
- * load_gdt for early boot, when the gdt is only mapped once
- */
-static void __init xen_load_gdt_boot(const struct desc_ptr *dtr)
-{
-	unsigned long va = dtr->address;
-	unsigned int size = dtr->size + 1;
-	unsigned pages = DIV_ROUND_UP(size, PAGE_SIZE);
-	unsigned long frames[pages];
-	int f;
-
-	/*
-	 * A GDT can be up to 64k in size, which corresponds to 8192
-	 * 8-byte entries, or 16 4k pages..
-	 */
-
-	BUG_ON(size > 65536);
-	BUG_ON(va & ~PAGE_MASK);
-
-	for (f = 0; va < dtr->address + size; va += PAGE_SIZE, f++) {
-		pte_t pte;
-		unsigned long pfn, mfn;
-
-		pfn = virt_to_pfn(va);
-		mfn = pfn_to_mfn(pfn);
-
-		pte = pfn_pte(pfn, PAGE_KERNEL_RO);
-
-		if (HYPERVISOR_update_va_mapping((unsigned long)va, pte, 0))
-			BUG();
-
-		frames[f] = mfn;
-	}
-
-	if (HYPERVISOR_set_gdt(frames, size / sizeof(struct desc_struct)))
-		BUG();
-}
+static struct notifier_block xen_panic_block = {
+	.notifier_call = xen_panic_event,
+	.priority = INT_MIN
+};
 
-static inline bool desc_equal(const struct desc_struct *d1,
-			      const struct desc_struct *d2)
+int xen_panic_handler_init(void)
 {
-	return d1->a == d2->a && d1->b == d2->b;
+	atomic_notifier_chain_register(&panic_notifier_list, &xen_panic_block);
+	return 0;
 }
 
-static void load_TLS_descriptor(struct thread_struct *t,
-				unsigned int cpu, unsigned int i)
+void xen_pin_vcpu(int cpu)
 {
-	struct desc_struct *shadow = &per_cpu(shadow_tls_desc, cpu).desc[i];
-	struct desc_struct *gdt;
-	xmaddr_t maddr;
-	struct multicall_space mc;
+	static bool disable_pinning;
+	struct sched_pin_override pin_override;
+	int ret;
 
-	if (desc_equal(shadow, &t->tls_array[i]))
+	if (disable_pinning)
 		return;
 
-	*shadow = t->tls_array[i];
-
-	gdt = get_cpu_gdt_rw(cpu);
-	maddr = arbitrary_virt_to_machine(&gdt[GDT_ENTRY_TLS_MIN+i]);
-	mc = __xen_mc_entry(0);
+	pin_override.pcpu = cpu;
+	ret = HYPERVISOR_sched_op(SCHEDOP_pin_override, &pin_override);
 
-	MULTI_update_descriptor(mc.mc, maddr.maddr, t->tls_array[i]);
-}
+	/* Ignore errors when removing override. */
+	if (cpu < 0)
+		return;
 
-static void xen_load_tls(struct thread_struct *t, unsigned int cpu)
-{
-	/*
-	 * XXX sleazy hack: If we're being called in a lazy-cpu zone
-	 * and lazy gs handling is enabled, it means we're in a
-	 * context switch, and %gs has just been saved.  This means we
-	 * can zero it out to prevent faults on exit from the
-	 * hypervisor if the next process has no %gs.  Either way, it
-	 * has been saved, and the new value will get loaded properly.
-	 * This will go away as soon as Xen has been modified to not
-	 * save/restore %gs for normal hypercalls.
-	 *
-	 * On x86_64, this hack is not used for %gs, because gs points
-	 * to KERNEL_GS_BASE (and uses it for PDA references), so we
-	 * must not zero %gs on x86_64
-	 *
-	 * For x86_64, we need to zero %fs, otherwise we may get an
-	 * exception between the new %fs descriptor being loaded and
-	 * %fs being effectively cleared at __switch_to().
-	 */
-	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_CPU) {
-#ifdef CONFIG_X86_32
-		lazy_load_gs(0);
-#else
-		loadsegment(fs, 0);
-#endif
+	switch (ret) {
+	case -ENOSYS:
+		pr_warn(""Unable to pin on physical cpu %d. In case of problems consider vcpu pinning.\n"",
+			cpu);
+		disable_pinning = true;
+		break;
+	case -EPERM:
+		WARN(1, ""Trying to pin vcpu without having privilege to do so\n"");
+		disable_pinning = true;
+		break;
+	case -EINVAL:
+	case -EBUSY:
+		pr_warn(""Physical cpu %d not available for pinning. Check Xen cpu configuration.\n"",
+			cpu);
+		break;
+	case 0:
+		break;
+	default:
+		WARN(1, ""rc %d while trying to pin vcpu\n"", ret);
+		disable_pinning = true;
 	}
-
-	xen_mc_batch();
-
-	load_TLS_descriptor(t, cpu, 0);
-	load_TLS_descriptor(t, cpu, 1);
-	load_TLS_descriptor(t, cpu, 2);
-
-	xen_mc_issue(PARAVIRT_LAZY_CPU);
-}
-
-#ifdef CONFIG_X86_64
-static void xen_load_gs_index(unsigned int idx)
-{
-	if (HYPERVISOR_set_segment_base(SEGBASE_GS_USER_SEL, idx))
-		BUG();
-}
-#endif
-
-static void xen_write_ldt_entry(struct desc_struct *dt, int entrynum,
-				const void *ptr)
-{
-	xmaddr_t mach_lp = arbitrary_virt_to_machine(&dt[entrynum]);
-	u64 entry = *(u64 *)ptr;
-
-	trace_xen_cpu_write_ldt_entry(dt, entrynum, entry);
-
-	preempt_disable();
-
-	xen_mc_flush();
-	if (HYPERVISOR_update_descriptor(mach_lp.maddr, entry))
-		BUG();
-
-	preempt_enable();
 }
 
-static int cvt_gate_to_trap(int vector, const gate_desc *val,
-			    struct trap_info *info)
-{
-	unsigned long addr;
-
-	if (val->type != GATE_TRAP && val->type != GATE_INTERRUPT)
-		return 0;
-
-	info->vector = vector;
-
-	addr = gate_offset(*val);
-#ifdef CONFIG_X86_64
-	/*
-	 * Look for known traps using IST, and substitute them
-	 * appropriately.  The debugger ones are the only ones we care
-	 * about.  Xen will handle faults like double_fault,
-	 * so we should never see them.  Warn if
-	 * there's an unexpected IST-using fault handler.
-	 */
-	if (addr == (unsigned long)debug)
-		addr = (unsigned long)xen_debug;
-	else if (addr == (unsigned long)int3)
-		addr = (unsigned long)xen_int3;
-	else if (addr == (unsigned long)stack_segment)
-		addr = (unsigned long)xen_stack_segment;
-	else if (addr == (unsigned long)double_fault) {
-		/* Don't need to handle these */
-		return 0;
-#ifdef CONFIG_X86_MCE
-	} else if (addr == (unsigned long)machine_check) {
-		/*
-		 * when xen hypervisor inject vMCE to guest,
-		 * use native mce handler to handle it
-		 */
-		;
-#endif
-	} else if (addr == (unsigned long)nmi)
-		/*
-		 * Use the native version as well.
-		 */
-		;
-	else {
-		/* Some other trap using IST? */
-		if (WARN_ON(val->ist != 0))
-			return 0;
-	}
-#endif	/* CONFIG_X86_64 */
-	info->address = addr;
-
-	info->cs = gate_segment(*val);
-	info->flags = val->dpl;
-	/* interrupt gates clear IF */
-	if (val->type == GATE_INTERRUPT)
-		info->flags |= 1 << 2;
-
-	return 1;
-}
-
-/* Locations of each CPU's IDT */
-static DEFINE_PER_CPU(struct desc_ptr, idt_desc);
-
-/* Set an IDT entry.  If the entry is part of the current IDT, then
-   also update Xen. */
-static void xen_write_idt_entry(gate_desc *dt, int entrynum, const gate_desc *g)
-{
-	unsigned long p = (unsigned long)&dt[entrynum];
-	unsigned long start, end;
-
-	trace_xen_cpu_write_idt_entry(dt, entrynum, g);
-
-	preempt_disable();
-
-	start = __this_cpu_read(idt_desc.address);
-	end = start + __this_cpu_read(idt_desc.size) + 1;
-
-	xen_mc_flush();
-
-	native_write_idt_entry(dt, entrynum, g);
-
-	if (p >= start && (p + 8) <= end) {
-		struct trap_info info[2];
-
-		info[1].address = 0;
-
-		if (cvt_gate_to_trap(entrynum, g, &info[0]))
-			if (HYPERVISOR_set_trap_table(info))
-				BUG();
-	}
-
-	preempt_enable();
-}
-
-static void xen_convert_trap_info(const struct desc_ptr *desc,
-				  struct trap_info *traps)
-{
-	unsigned in, out, count;
-
-	count = (desc->size+1) / sizeof(gate_desc);
-	BUG_ON(count > 256);
-
-	for (in = out = 0; in < count; in++) {
-		gate_desc *entry = (gate_desc*)(desc->address) + in;
-
-		if (cvt_gate_to_trap(in, entry, &traps[out]))
-			out++;
-	}
-	traps[out].address = 0;
-}
-
-void xen_copy_trap_info(struct trap_info *traps)
-{
-	const struct desc_ptr *desc = this_cpu_ptr(&idt_desc);
-
-	xen_convert_trap_info(desc, traps);
-}
-
-/* Load a new IDT into Xen.  In principle this can be per-CPU, so we
-   hold a spinlock to protect the static traps[] array (static because
-   it avoids allocation, and saves stack space). */
-static void xen_load_idt(const struct desc_ptr *desc)
-{
-	static DEFINE_SPINLOCK(lock);
-	static struct trap_info traps[257];
-
-	trace_xen_cpu_load_idt(desc);
-
-	spin_lock(&lock);
-
-	memcpy(this_cpu_ptr(&idt_desc), desc, sizeof(idt_desc));
-
-	xen_convert_trap_info(desc, traps);
-
-	xen_mc_flush();
-	if (HYPERVISOR_set_trap_table(traps))
-		BUG();
-
-	spin_unlock(&lock);
-}
-
-/* Write a GDT descriptor entry.  Ignore LDT descriptors, since
-   they're handled differently. */
-static void xen_write_gdt_entry(struct desc_struct *dt, int entry,
-				const void *desc, int type)
-{
-	trace_xen_cpu_write_gdt_entry(dt, entry, desc, type);
-
-	preempt_disable();
-
-	switch (type) {
-	case DESC_LDT:
-	case DESC_TSS:
-		/* ignore */
-		break;
-
-	default: {
-		xmaddr_t maddr = arbitrary_virt_to_machine(&dt[entry]);
-
-		xen_mc_flush();
-		if (HYPERVISOR_update_descriptor(maddr.maddr, *(u64 *)desc))
-			BUG();
-	}
-
-	}
-
-	preempt_enable();
-}
-
-/*
- * Version of write_gdt_entry for use at early boot-time needed to
- * update an entry as simply as possible.
- */
-static void __init xen_write_gdt_entry_boot(struct desc_struct *dt, int entry,
-					    const void *desc, int type)
-{
-	trace_xen_cpu_write_gdt_entry(dt, entry, desc, type);
-
-	switch (type) {
-	case DESC_LDT:
-	case DESC_TSS:
-		/* ignore */
-		break;
-
-	default: {
-		xmaddr_t maddr = virt_to_machine(&dt[entry]);
-
-		if (HYPERVISOR_update_descriptor(maddr.maddr, *(u64 *)desc))
-			dt[entry] = *(struct desc_struct *)desc;
-	}
-
-	}
-}
-
-static void xen_load_sp0(struct tss_struct *tss,
-			 struct thread_struct *thread)
-{
-	struct multicall_space mcs;
-
-	mcs = xen_mc_entry(0);
-	MULTI_stack_switch(mcs.mc, __KERNEL_DS, thread->sp0);
-	xen_mc_issue(PARAVIRT_LAZY_CPU);
-	tss->x86_tss.sp0 = thread->sp0;
-}
-
-void xen_set_iopl_mask(unsigned mask)
-{
-	struct physdev_set_iopl set_iopl;
-
-	/* Force the change at ring 0. */
-	set_iopl.iopl = (mask == 0) ? 1 : (mask >> 12) & 3;
-	HYPERVISOR_physdev_op(PHYSDEVOP_set_iopl, &set_iopl);
-}
-
-static void xen_io_delay(void)
-{
-}
-
-static DEFINE_PER_CPU(unsigned long, xen_cr0_value);
-
-static unsigned long xen_read_cr0(void)
-{
-	unsigned long cr0 = this_cpu_read(xen_cr0_value);
-
-	if (unlikely(cr0 == 0)) {
-		cr0 = native_read_cr0();
-		this_cpu_write(xen_cr0_value, cr0);
-	}
-
-	return cr0;
-}
-
-static void xen_write_cr0(unsigned long cr0)
-{
-	struct multicall_space mcs;
-
-	this_cpu_write(xen_cr0_value, cr0);
-
-	/* Only pay attention to cr0.TS; everything else is
-	   ignored. */
-	mcs = xen_mc_entry(0);
-
-	MULTI_fpu_taskswitch(mcs.mc, (cr0 & X86_CR0_TS) != 0);
-
-	xen_mc_issue(PARAVIRT_LAZY_CPU);
-}
-
-static void xen_write_cr4(unsigned long cr4)
-{
-	cr4 &= ~(X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PCE);
-
-	native_write_cr4(cr4);
-}
-#ifdef CONFIG_X86_64
-static inline unsigned long xen_read_cr8(void)
-{
-	return 0;
-}
-static inline void xen_write_cr8(unsigned long val)
-{
-	BUG_ON(val);
-}
-#endif
-
-static u64 xen_read_msr_safe(unsigned int msr, int *err)
-{
-	u64 val;
-
-	if (pmu_msr_read(msr, &val, err))
-		return val;
-
-	val = native_read_msr_safe(msr, err);
-	switch (msr) {
-	case MSR_IA32_APICBASE:
-#ifdef CONFIG_X86_X2APIC
-		if (!(cpuid_ecx(1) & (1 << (X86_FEATURE_X2APIC & 31))))
-#endif
-			val &= ~X2APIC_ENABLE;
-		break;
-	}
-	return val;
-}
-
-static int xen_write_msr_safe(unsigned int msr, unsigned low, unsigned high)
-{
-	int ret;
-
-	ret = 0;
-
-	switch (msr) {
-#ifdef CONFIG_X86_64
-		unsigned which;
-		u64 base;
-
-	case MSR_FS_BASE:		which = SEGBASE_FS; goto set;
-	case MSR_KERNEL_GS_BASE:	which = SEGBASE_GS_USER; goto set;
-	case MSR_GS_BASE:		which = SEGBASE_GS_KERNEL; goto set;
-
-	set:
-		base = ((u64)high << 32) | low;
-		if (HYPERVISOR_set_segment_base(which, base) != 0)
-			ret = -EIO;
-		break;
-#endif
-
-	case MSR_STAR:
-	case MSR_CSTAR:
-	case MSR_LSTAR:
-	case MSR_SYSCALL_MASK:
-	case MSR_IA32_SYSENTER_CS:
-	case MSR_IA32_SYSENTER_ESP:
-	case MSR_IA32_SYSENTER_EIP:
-		/* Fast syscall setup is all done in hypercalls, so
-		   these are all ignored.  Stub them out here to stop
-		   Xen console noise. */
-		break;
-
-	default:
-		if (!pmu_msr_write(msr, low, high, &ret))
-			ret = native_write_msr_safe(msr, low, high);
-	}
-
-	return ret;
-}
-
-static u64 xen_read_msr(unsigned int msr)
-{
-	/*
-	 * This will silently swallow a #GP from RDMSR.  It may be worth
-	 * changing that.
-	 */
-	int err;
-
-	return xen_read_msr_safe(msr, &err);
-}
-
-static void xen_write_msr(unsigned int msr, unsigned low, unsigned high)
-{
-	/*
-	 * This will silently swallow a #GP from WRMSR.  It may be worth
-	 * changing that.
-	 */
-	xen_write_msr_safe(msr, low, high);
-}
-
-void xen_setup_shared_info(void)
-{
-	if (!xen_feature(XENFEAT_auto_translated_physmap)) {
-		set_fixmap(FIX_PARAVIRT_BOOTMAP,
-			   xen_start_info->shared_info);
-
-		HYPERVISOR_shared_info =
-			(struct shared_info *)fix_to_virt(FIX_PARAVIRT_BOOTMAP);
-	} else
-		HYPERVISOR_shared_info =
-			(struct shared_info *)__va(xen_start_info->shared_info);
-
-#ifndef CONFIG_SMP
-	/* In UP this is as good a place as any to set up shared info */
-	xen_setup_vcpu_info_placement();
-#endif
-
-	xen_setup_mfn_list_list();
-}
-
-/* This is called once we have the cpu_possible_mask */
-void xen_setup_vcpu_info_placement(void)
-{
-	int cpu;
-
-	for_each_possible_cpu(cpu) {
-		/* Set up direct vCPU id mapping for PV guests. */
-		per_cpu(xen_vcpu_id, cpu) = cpu;
-		xen_vcpu_setup(cpu);
-	}
-
-	/*
-	 * xen_vcpu_setup managed to place the vcpu_info within the
-	 * percpu area for all cpus, so make use of it.
-	 */
-	if (xen_have_vcpu_info_placement) {
-		pv_irq_ops.save_fl = __PV_IS_CALLEE_SAVE(xen_save_fl_direct);
-		pv_irq_ops.restore_fl = __PV_IS_CALLEE_SAVE(xen_restore_fl_direct);
-		pv_irq_ops.irq_disable = __PV_IS_CALLEE_SAVE(xen_irq_disable_direct);
-		pv_irq_ops.irq_enable = __PV_IS_CALLEE_SAVE(xen_irq_enable_direct);
-		pv_mmu_ops.read_cr2 = xen_read_cr2_direct;
-	}
-}
-
-static unsigned xen_patch(u8 type, u16 clobbers, void *insnbuf,
-			  unsigned long addr, unsigned len)
-{
-	char *start, *end, *reloc;
-	unsigned ret;
-
-	start = end = reloc = NULL;
-
-#define SITE(op, x)							\
-	case PARAVIRT_PATCH(op.x):					\
-	if (xen_have_vcpu_info_placement) {				\
-		start = (char *)xen_##x##_direct;			\
-		end = xen_##x##_direct_end;				\
-		reloc = xen_##x##_direct_reloc;				\
-	}								\
-	goto patch_site
-
-	switch (type) {
-		SITE(pv_irq_ops, irq_enable);
-		SITE(pv_irq_ops, irq_disable);
-		SITE(pv_irq_ops, save_fl);
-		SITE(pv_irq_ops, restore_fl);
-#undef SITE
-
-	patch_site:
-		if (start == NULL || (end-start) > len)
-			goto default_patch;
-
-		ret = paravirt_patch_insns(insnbuf, len, start, end);
-
-		/* Note: because reloc is assigned from something that
-		   appears to be an array, gcc assumes it's non-null,
-		   but doesn't know its relationship with start and
-		   end. */
-		if (reloc > start && reloc < end) {
-			int reloc_off = reloc - start;
-			long *relocp = (long *)(insnbuf + reloc_off);
-			long delta = start - (char *)addr;
-
-			*relocp += delta;
-		}
-		break;
-
-	default_patch:
-	default:
-		ret = paravirt_patch_default(type, clobbers, insnbuf,
-					     addr, len);
-		break;
-	}
-
-	return ret;
-}
-
-static const struct pv_info xen_info __initconst = {
-	.shared_kernel_pmd = 0,
-
-#ifdef CONFIG_X86_64
-	.extra_user_64bit_cs = FLAT_USER_CS64,
-#endif
-	.name = ""Xen"",
-};
-
-static const struct pv_init_ops xen_init_ops __initconst = {
-	.patch = xen_patch,
-};
-
-static const struct pv_cpu_ops xen_cpu_ops __initconst = {
-	.cpuid = xen_cpuid,
-
-	.set_debugreg = xen_set_debugreg,
-	.get_debugreg = xen_get_debugreg,
-
-	.read_cr0 = xen_read_cr0,
-	.write_cr0 = xen_write_cr0,
-
-	.read_cr4 = native_read_cr4,
-	.write_cr4 = xen_write_cr4,
-
-#ifdef CONFIG_X86_64
-	.read_cr8 = xen_read_cr8,
-	.write_cr8 = xen_write_cr8,
-#endif
-
-	.wbinvd = native_wbinvd,
-
-	.read_msr = xen_read_msr,
-	.write_msr = xen_write_msr,
-
-	.read_msr_safe = xen_read_msr_safe,
-	.write_msr_safe = xen_write_msr_safe,
-
-	.read_pmc = xen_read_pmc,
-
-	.iret = xen_iret,
-#ifdef CONFIG_X86_64
-	.usergs_sysret64 = xen_sysret64,
-#endif
-
-	.load_tr_desc = paravirt_nop,
-	.set_ldt = xen_set_ldt,
-	.load_gdt = xen_load_gdt,
-	.load_idt = xen_load_idt,
-	.load_tls = xen_load_tls,
-#ifdef CONFIG_X86_64
-	.load_gs_index = xen_load_gs_index,
-#endif
-
-	.alloc_ldt = xen_alloc_ldt,
-	.free_ldt = xen_free_ldt,
-
-	.store_idt = native_store_idt,
-	.store_tr = xen_store_tr,
-
-	.write_ldt_entry = xen_write_ldt_entry,
-	.write_gdt_entry = xen_write_gdt_entry,
-	.write_idt_entry = xen_write_idt_entry,
-	.load_sp0 = xen_load_sp0,
-
-	.set_iopl_mask = xen_set_iopl_mask,
-	.io_delay = xen_io_delay,
-
-	/* Xen takes care of %gs when switching to usermode for us */
-	.swapgs = paravirt_nop,
-
-	.start_context_switch = paravirt_start_context_switch,
-	.end_context_switch = xen_end_context_switch,
-};
-
-void xen_reboot(int reason)
-{
-	struct sched_shutdown r = { .reason = reason };
-	int cpu;
-
-	for_each_online_cpu(cpu)
-		xen_pmu_finish(cpu);
-
-	if (HYPERVISOR_sched_op(SCHEDOP_shutdown, &r))
-		BUG();
-}
-
-static void xen_restart(char *msg)
-{
-	xen_reboot(SHUTDOWN_reboot);
-}
-
-void xen_emergency_restart(void)
-{
-	xen_reboot(SHUTDOWN_reboot);
-}
-
-static void xen_machine_halt(void)
-{
-	xen_reboot(SHUTDOWN_poweroff);
-}
-
-static void xen_machine_power_off(void)
-{
-	if (pm_power_off)
-		pm_power_off();
-	xen_reboot(SHUTDOWN_poweroff);
-}
-
-static void xen_crash_shutdown(struct pt_regs *regs)
-{
-	xen_reboot(SHUTDOWN_crash);
-}
-
-static int
-xen_panic_event(struct notifier_block *this, unsigned long event, void *ptr)
-{
-	if (!kexec_crash_loaded())
-		xen_reboot(SHUTDOWN_crash);
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block xen_panic_block = {
-	.notifier_call= xen_panic_event,
-	.priority = INT_MIN
-};
-
-int xen_panic_handler_init(void)
-{
-	atomic_notifier_chain_register(&panic_notifier_list, &xen_panic_block);
-	return 0;
-}
-
-static const struct machine_ops xen_machine_ops __initconst = {
-	.restart = xen_restart,
-	.halt = xen_machine_halt,
-	.power_off = xen_machine_power_off,
-	.shutdown = xen_machine_halt,
-	.crash_shutdown = xen_crash_shutdown,
-	.emergency_restart = xen_emergency_restart,
-};
-
-static unsigned char xen_get_nmi_reason(void)
-{
-	unsigned char reason = 0;
-
-	/* Construct a value which looks like it came from port 0x61. */
-	if (test_bit(_XEN_NMIREASON_io_error,
-		     &HYPERVISOR_shared_info->arch.nmi_reason))
-		reason |= NMI_REASON_IOCHK;
-	if (test_bit(_XEN_NMIREASON_pci_serr,
-		     &HYPERVISOR_shared_info->arch.nmi_reason))
-		reason |= NMI_REASON_SERR;
-
-	return reason;
-}
-
-static void __init xen_boot_params_init_edd(void)
-{
-#if IS_ENABLED(CONFIG_EDD)
-	struct xen_platform_op op;
-	struct edd_info *edd_info;
-	u32 *mbr_signature;
-	unsigned nr;
-	int ret;
-
-	edd_info = boot_params.eddbuf;
-	mbr_signature = boot_params.edd_mbr_sig_buffer;
-
-	op.cmd = XENPF_firmware_info;
-
-	op.u.firmware_info.type = XEN_FW_DISK_INFO;
-	for (nr = 0; nr < EDDMAXNR; nr++) {
-		struct edd_info *info = edd_info + nr;
-
-		op.u.firmware_info.index = nr;
-		info->params.length = sizeof(info->params);
-		set_xen_guest_handle(op.u.firmware_info.u.disk_info.edd_params,
-				     &info->params);
-		ret = HYPERVISOR_platform_op(&op);
-		if (ret)
-			break;
-
-#define C(x) info->x = op.u.firmware_info.u.disk_info.x
-		C(device);
-		C(version);
-		C(interface_support);
-		C(legacy_max_cylinder);
-		C(legacy_max_head);
-		C(legacy_sectors_per_track);
-#undef C
-	}
-	boot_params.eddbuf_entries = nr;
-
-	op.u.firmware_info.type = XEN_FW_DISK_MBR_SIGNATURE;
-	for (nr = 0; nr < EDD_MBR_SIG_MAX; nr++) {
-		op.u.firmware_info.index = nr;
-		ret = HYPERVISOR_platform_op(&op);
-		if (ret)
-			break;
-		mbr_signature[nr] = op.u.firmware_info.u.disk_mbr_signature.mbr_signature;
-	}
-	boot_params.edd_mbr_sig_buf_entries = nr;
-#endif
-}
-
-/*
- * Set up the GDT and segment registers for -fstack-protector.  Until
- * we do this, we have to be careful not to call any stack-protected
- * function, which is most of the kernel.
- */
-static void xen_setup_gdt(int cpu)
-{
-	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry_boot;
-	pv_cpu_ops.load_gdt = xen_load_gdt_boot;
-
-	setup_stack_canary_segment(0);
-	switch_to_new_gdt(0);
-
-	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry;
-	pv_cpu_ops.load_gdt = xen_load_gdt;
-}
-
-static void __init xen_dom0_set_legacy_features(void)
-{
-	x86_platform.legacy.rtc = 1;
-}
-
-int xen_cpuhp_setup(int (*cpu_up_prepare_cb)(unsigned int),
-		    int (*cpu_dead_cb)(unsigned int))
-{
-	int rc;
-
-	rc = cpuhp_setup_state_nocalls(CPUHP_XEN_PREPARE,
-				       ""x86/xen/hvm_guest:prepare"",
-				       cpu_up_prepare_cb, cpu_dead_cb);
-	if (rc >= 0) {
-		rc = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
-					       ""x86/xen/hvm_guest:online"",
-					       xen_cpu_up_online, NULL);
-		if (rc < 0)
-			cpuhp_remove_state_nocalls(CPUHP_XEN_PREPARE);
-	}
-
-	return rc >= 0 ? 0 : rc;
-}
-
-/* First C function to be called on Xen boot */
-asmlinkage __visible void __init xen_start_kernel(void)
-{
-	struct physdev_set_iopl set_iopl;
-	unsigned long initrd_start = 0;
-	int rc;
-
-	if (!xen_start_info)
-		return;
-
-	xen_domain_type = XEN_PV_DOMAIN;
-
-	xen_setup_features();
-
-	xen_setup_machphys_mapping();
-
-	/* Install Xen paravirt ops */
-	pv_info = xen_info;
-	pv_init_ops = xen_init_ops;
-	pv_cpu_ops = xen_cpu_ops;
-
-	x86_platform.get_nmi_reason = xen_get_nmi_reason;
-
-	x86_init.resources.memory_setup = xen_memory_setup;
-	x86_init.oem.arch_setup = xen_arch_setup;
-	x86_init.oem.banner = xen_banner;
-
-	xen_init_time_ops();
-
-	/*
-	 * Set up some pagetable state before starting to set any ptes.
-	 */
-
-	xen_init_mmu_ops();
-
-	/* Prevent unwanted bits from being set in PTEs. */
-	__supported_pte_mask &= ~_PAGE_GLOBAL;
-
-	/*
-	 * Prevent page tables from being allocated in highmem, even
-	 * if CONFIG_HIGHPTE is enabled.
-	 */
-	__userpte_alloc_gfp &= ~__GFP_HIGHMEM;
-
-	/* Work out if we support NX */
-	x86_configure_nx();
-
-	/* Get mfn list */
-	xen_build_dynamic_phys_to_machine();
-
-	/*
-	 * Set up kernel GDT and segment registers, mainly so that
-	 * -fstack-protector code can be executed.
-	 */
-	xen_setup_gdt(0);
-
-	xen_init_irq_ops();
-	xen_init_cpuid_mask();
-
-#ifdef CONFIG_X86_LOCAL_APIC
-	/*
-	 * set up the basic apic ops.
-	 */
-	xen_init_apic();
-#endif
-
-	if (xen_feature(XENFEAT_mmu_pt_update_preserve_ad)) {
-		pv_mmu_ops.ptep_modify_prot_start = xen_ptep_modify_prot_start;
-		pv_mmu_ops.ptep_modify_prot_commit = xen_ptep_modify_prot_commit;
-	}
-
-	machine_ops = xen_machine_ops;
-
-	/*
-	 * The only reliable way to retain the initial address of the
-	 * percpu gdt_page is to remember it here, so we can go and
-	 * mark it RW later, when the initial percpu area is freed.
-	 */
-	xen_initial_gdt = &per_cpu(gdt_page, 0);
-
-	xen_smp_init();
-
-#ifdef CONFIG_ACPI_NUMA
-	/*
-	 * The pages we from Xen are not related to machine pages, so
-	 * any NUMA information the kernel tries to get from ACPI will
-	 * be meaningless.  Prevent it from trying.
-	 */
-	acpi_numa = -1;
-#endif
-	/* Don't do the full vcpu_info placement stuff until we have a
-	   possible map and a non-dummy shared_info. */
-	per_cpu(xen_vcpu, 0) = &HYPERVISOR_shared_info->vcpu_info[0];
-
-	WARN_ON(xen_cpuhp_setup(xen_cpu_up_prepare_pv, xen_cpu_dead_pv));
-
-	local_irq_disable();
-	early_boot_irqs_disabled = true;
-
-	xen_raw_console_write(""mapping kernel into physical memory\n"");
-	xen_setup_kernel_pagetable((pgd_t *)xen_start_info->pt_base,
-				   xen_start_info->nr_pages);
-	xen_reserve_special_pages();
-
-	/* keep using Xen gdt for now; no urgent need to change it */
-
-#ifdef CONFIG_X86_32
-	pv_info.kernel_rpl = 1;
-	if (xen_feature(XENFEAT_supervisor_mode_kernel))
-		pv_info.kernel_rpl = 0;
-#else
-	pv_info.kernel_rpl = 0;
-#endif
-	/* set the limit of our address space */
-	xen_reserve_top();
-
-	/*
-	 * We used to do this in xen_arch_setup, but that is too late
-	 * on AMD were early_cpu_init (run before ->arch_setup()) calls
-	 * early_amd_init which pokes 0xcf8 port.
-	 */
-	set_iopl.iopl = 1;
-	rc = HYPERVISOR_physdev_op(PHYSDEVOP_set_iopl, &set_iopl);
-	if (rc != 0)
-		xen_raw_printk(""physdev_op failed %d\n"", rc);
-
-#ifdef CONFIG_X86_32
-	/* set up basic CPUID stuff */
-	cpu_detect(&new_cpu_data);
-	set_cpu_cap(&new_cpu_data, X86_FEATURE_FPU);
-	new_cpu_data.x86_capability[CPUID_1_EDX] = cpuid_edx(1);
-#endif
-
-	if (xen_start_info->mod_start) {
-	    if (xen_start_info->flags & SIF_MOD_START_PFN)
-		initrd_start = PFN_PHYS(xen_start_info->mod_start);
-	    else
-		initrd_start = __pa(xen_start_info->mod_start);
-	}
-
-	/* Poke various useful things into boot_params */
-	boot_params.hdr.type_of_loader = (9 << 4) | 0;
-	boot_params.hdr.ramdisk_image = initrd_start;
-	boot_params.hdr.ramdisk_size = xen_start_info->mod_len;
-	boot_params.hdr.cmd_line_ptr = __pa(xen_start_info->cmd_line);
-	boot_params.hdr.hardware_subarch = X86_SUBARCH_XEN;
-
-	if (!xen_initial_domain()) {
-		add_preferred_console(""xenboot"", 0, NULL);
-		add_preferred_console(""tty"", 0, NULL);
-		add_preferred_console(""hvc"", 0, NULL);
-		if (pci_xen)
-			x86_init.pci.arch_init = pci_xen_init;
-	} else {
-		const struct dom0_vga_console_info *info =
-			(void *)((char *)xen_start_info +
-				 xen_start_info->console.dom0.info_off);
-		struct xen_platform_op op = {
-			.cmd = XENPF_firmware_info,
-			.interface_version = XENPF_INTERFACE_VERSION,
-			.u.firmware_info.type = XEN_FW_KBD_SHIFT_FLAGS,
-		};
-
-		x86_platform.set_legacy_features =
-				xen_dom0_set_legacy_features;
-		xen_init_vga(info, xen_start_info->console.dom0.info_size);
-		xen_start_info->console.domU.mfn = 0;
-		xen_start_info->console.domU.evtchn = 0;
-
-		if (HYPERVISOR_platform_op(&op) == 0)
-			boot_params.kbd_status = op.u.firmware_info.u.kbd_shift_flags;
-
-		/* Make sure ACS will be enabled */
-		pci_request_acs();
-
-		xen_acpi_sleep_register();
-
-		/* Avoid searching for BIOS MP tables */
-		x86_init.mpparse.find_smp_config = x86_init_noop;
-		x86_init.mpparse.get_smp_config = x86_init_uint_noop;
-
-		xen_boot_params_init_edd();
-	}
-#ifdef CONFIG_PCI
-	/* PCI BIOS service won't work from a PV guest. */
-	pci_probe &= ~PCI_PROBE_BIOS;
-#endif
-	xen_raw_console_write(""about to get started...\n"");
-
-	/* Let's presume PV guests always boot on vCPU with id 0. */
-	per_cpu(xen_vcpu_id, 0) = 0;
-
-	xen_setup_runstate_info(0);
-
-	xen_efi_init();
-
-	/* Start the world */
-#ifdef CONFIG_X86_32
-	i386_start_kernel();
-#else
-	cr4_init_shadow(); /* 32b kernel does this in i386_start_kernel() */
-	x86_64_start_reservations((char *)__pa_symbol(&boot_params));
-#endif
-}
-
-static int xen_cpu_up_prepare_pv(unsigned int cpu)
-{
-	int rc;
-
-	xen_setup_timer(cpu);
-
-	rc = xen_smp_intr_init(cpu);
-	if (rc) {
-		WARN(1, ""xen_smp_intr_init() for CPU %d failed: %d\n"",
-		     cpu, rc);
-		return rc;
-	}
-	return 0;
-}
-
-static int xen_cpu_dead_pv(unsigned int cpu)
-{
-	xen_smp_intr_free(cpu);
-
-	xen_teardown_timer(cpu);
-
-	return 0;
-}
-
-static int xen_cpu_up_online(unsigned int cpu)
-{
-	xen_init_lock_cpu(cpu);
-	return 0;
-}
-
-static uint32_t __init xen_platform_pv(void)
-{
-	if (xen_pv_domain())
-		return xen_cpuid_base();
-
-	return 0;
-}
-
-static void xen_set_cpu_features(struct cpuinfo_x86 *c)
-{
-	clear_cpu_bug(c, X86_BUG_SYSRET_SS_ATTRS);
-	set_cpu_cap(c, X86_FEATURE_XENPV);
-}
-
-void xen_pin_vcpu(int cpu)
-{
-	static bool disable_pinning;
-	struct sched_pin_override pin_override;
-	int ret;
-
-	if (disable_pinning)
-		return;
-
-	pin_override.pcpu = cpu;
-	ret = HYPERVISOR_sched_op(SCHEDOP_pin_override, &pin_override);
-
-	/* Ignore errors when removing override. */
-	if (cpu < 0)
-		return;
-
-	switch (ret) {
-	case -ENOSYS:
-		pr_warn(""Unable to pin on physical cpu %d. In case of problems consider vcpu pinning.\n"",
-			cpu);
-		disable_pinning = true;
-		break;
-	case -EPERM:
-		WARN(1, ""Trying to pin vcpu without having privilege to do so\n"");
-		disable_pinning = true;
-		break;
-	case -EINVAL:
-	case -EBUSY:
-		pr_warn(""Physical cpu %d not available for pinning. Check Xen cpu configuration.\n"",
-			cpu);
-		break;
-	case 0:
-		break;
-	default:
-		WARN(1, ""rc %d while trying to pin vcpu\n"", ret);
-		disable_pinning = true;
-	}
-}
-
-const struct hypervisor_x86 x86_hyper_xen_pv = {
-	.name                   = ""Xen PV"",
-	.detect                 = xen_platform_pv,
-	.set_cpu_features       = xen_set_cpu_features,
-	.pin_vcpu               = xen_pin_vcpu,
-};
-EXPORT_SYMBOL(x86_hyper_xen_pv);
-
 #ifdef CONFIG_HOTPLUG_CPU
 void xen_arch_register_cpu(int num)
 {
",1,arch/x86/xen/enlighten.c,1646,java,torvalds___linux,test
1666,8031,33790cc18342231b13f7e6791196bd7c1f41e33f,"@@ -639,27 +639,27 @@ static void tee_ltc_alloc_mpa(void)
 	mpa_set_random_generator(crypto_rng_read);
 }
 
-static size_t num_bytes(struct bignum *a)
+size_t crypto_bignum_num_bytes(struct bignum *a)
 {
 	return mp_unsigned_bin_size(a);
 }
 
-static size_t num_bits(struct bignum *a)
+size_t crypto_bignum_num_bits(struct bignum *a)
 {
 	return mp_count_bits(a);
 }
 
-static int32_t compare(struct bignum *a, struct bignum *b)
+int32_t crypto_bignum_compare(struct bignum *a, struct bignum *b)
 {
 	return mp_cmp(a, b);
 }
 
-static void bn2bin(const struct bignum *from, uint8_t *to)
+void crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to)
 {
 	mp_to_unsigned_bin((struct bignum *)from, to);
 }
 
-static TEE_Result bin2bn(const uint8_t *from, size_t fromsize,
+TEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,
 			 struct bignum *to)
 {
 	if (mp_read_unsigned_bin(to, (uint8_t *)from, fromsize) != CRYPT_OK)
@@ -667,12 +667,12 @@ static TEE_Result bin2bn(const uint8_t *from, size_t fromsize,
 	return TEE_SUCCESS;
 }
 
-static void copy(struct bignum *to, const struct bignum *from)
+void crypto_bignum_copy(struct bignum *to, const struct bignum *from)
 {
 	mp_copy((void *)from, to);
 }
 
-static struct bignum *bn_allocate(size_t size_bits)
+struct bignum *crypto_bignum_allocate(size_t size_bits)
 {
 	size_t sz = mpa_StaticVarSizeInU32(size_bits) *	sizeof(uint32_t);
 	struct mpa_numbase_struct *bn = calloc(1, sz);
@@ -683,12 +683,12 @@ static struct bignum *bn_allocate(size_t size_bits)
 	return (struct bignum *)bn;
 }
 
-static void bn_free(struct bignum *s)
+void crypto_bignum_free(struct bignum *s)
 {
 	free(s);
 }
 
-static void bn_clear(struct bignum *s)
+void crypto_bignum_clear(struct bignum *s)
 {
 	struct mpa_numbase_struct *bn = (struct mpa_numbase_struct *)s;
 
@@ -701,7 +701,7 @@ static bool bn_alloc_max(struct bignum **s)
 	size_t sz = mpa_StaticVarSizeInU32(LTC_MAX_BITS_PER_VARIABLE) *
 			sizeof(uint32_t) * 8;
 
-	*s = bn_allocate(sz);
+	*s = crypto_bignum_allocate(sz);
 	return !!(*s);
 }
 
@@ -731,13 +731,13 @@ static TEE_Result alloc_rsa_keypair(struct rsa_keypair *s,
 
 	return TEE_SUCCESS;
 err:
-	bn_free(s->e);
-	bn_free(s->d);
-	bn_free(s->n);
-	bn_free(s->p);
-	bn_free(s->q);
-	bn_free(s->qp);
-	bn_free(s->dp);
+	crypto_bignum_free(s->e);
+	crypto_bignum_free(s->d);
+	crypto_bignum_free(s->n);
+	crypto_bignum_free(s->p);
+	crypto_bignum_free(s->q);
+	crypto_bignum_free(s->qp);
+	crypto_bignum_free(s->dp);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -753,7 +753,7 @@ static TEE_Result alloc_rsa_public_key(struct rsa_public_key *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	bn_free(s->e);
+	crypto_bignum_free(s->e);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -761,8 +761,8 @@ static void free_rsa_public_key(struct rsa_public_key *s)
 {
 	if (!s)
 		return;
-	bn_free(s->n);
-	bn_free(s->e);
+	crypto_bignum_free(s->n);
+	crypto_bignum_free(s->e);
 }
 
 static TEE_Result gen_rsa_key(struct rsa_keypair *key, size_t key_size)
@@ -892,7 +892,7 @@ static TEE_Result rsanopad_decrypt(struct rsa_keypair *key,
 	ltc_key.e = key->e;
 	ltc_key.N = key->n;
 	ltc_key.d = key->d;
-	if (key->p && num_bytes(key->p)) {
+	if (key->p && crypto_bignum_num_bytes(key->p)) {
 		ltc_key.p = key->p;
 		ltc_key.q = key->q;
 		ltc_key.qP = key->qp;
@@ -920,7 +920,7 @@ static TEE_Result rsaes_decrypt(uint32_t algo, struct rsa_keypair *key,
 	ltc_key.e = key->e;
 	ltc_key.d = key->d;
 	ltc_key.N = key->n;
-	if (key->p && num_bytes(key->p)) {
+	if (key->p && crypto_bignum_num_bytes(key->p)) {
 		ltc_key.p = key->p;
 		ltc_key.q = key->q;
 		ltc_key.qP = key->qp;
@@ -1073,7 +1073,7 @@ static TEE_Result rsassa_sign(uint32_t algo, struct rsa_keypair *key,
 	ltc_key.e = key->e;
 	ltc_key.N = key->n;
 	ltc_key.d = key->d;
-	if (key->p && num_bytes(key->p)) {
+	if (key->p && crypto_bignum_num_bytes(key->p)) {
 		ltc_key.p = key->p;
 		ltc_key.q = key->q;
 		ltc_key.qP = key->qp;
@@ -1235,10 +1235,10 @@ static TEE_Result alloc_dsa_keypair(struct dsa_keypair *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	bn_free(s->g);
-	bn_free(s->p);
-	bn_free(s->q);
-	bn_free(s->y);
+	crypto_bignum_free(s->g);
+	crypto_bignum_free(s->p);
+	crypto_bignum_free(s->q);
+	crypto_bignum_free(s->y);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -1258,9 +1258,9 @@ static TEE_Result alloc_dsa_public_key(struct dsa_public_key *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	bn_free(s->g);
-	bn_free(s->p);
-	bn_free(s->q);
+	crypto_bignum_free(s->g);
+	crypto_bignum_free(s->p);
+	crypto_bignum_free(s->q);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -1438,10 +1438,10 @@ static TEE_Result alloc_dh_keypair(struct dh_keypair *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	bn_free(s->g);
-	bn_free(s->p);
-	bn_free(s->y);
-	bn_free(s->x);
+	crypto_bignum_free(s->g);
+	crypto_bignum_free(s->p);
+	crypto_bignum_free(s->y);
+	crypto_bignum_free(s->x);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -1504,9 +1504,9 @@ static TEE_Result alloc_ecc_keypair(struct ecc_keypair *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	bn_free(s->d);
-	bn_free(s->x);
-	bn_free(s->y);
+	crypto_bignum_free(s->d);
+	crypto_bignum_free(s->x);
+	crypto_bignum_free(s->y);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -1520,8 +1520,8 @@ static TEE_Result alloc_ecc_public_key(struct ecc_public_key *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	bn_free(s->x);
-	bn_free(s->y);
+	crypto_bignum_free(s->x);
+	crypto_bignum_free(s->y);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -1530,8 +1530,8 @@ static void free_ecc_public_key(struct ecc_public_key *s)
 	if (!s)
 		return;
 
-	bn_free(s->x);
-	bn_free(s->y);
+	crypto_bignum_free(s->x);
+	crypto_bignum_free(s->y);
 }
 
 /*
@@ -3021,17 +3021,6 @@ const struct crypto_ops crypto_ops = {
 		.ecc_shared_secret = do_ecc_shared_secret,
 #endif
 	},
-	.bignum = {
-		.allocate = bn_allocate,
-		.num_bytes = num_bytes,
-		.num_bits = num_bits,
-		.compare = compare,
-		.bn2bin = bn2bin,
-		.bin2bn = bin2bn,
-		.copy = copy,
-		.free = bn_free,
-		.clear = bn_clear
-	},
 #endif /* _CFG_CRYPTO_WITH_ACIPHER */
 };
 
",1,core/lib/libtomcrypt/src/tee_ltc_provider.c,93,java,op-tee___optee_os,test
6796,31944,e380a95cfffef223a048dc307686cc1cccf1a8d1,"@@ -509,7 +509,14 @@ static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)
 
   offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);
   if (offset < 0)
-    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+    {
+      if (palette != NULL)
+        palette=DestroyImage(palette);
+      if (clone_info != NULL)
+        clone_info=DestroyImageInfo(clone_info);
+      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
+      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+    }
   for (i=0; i < (int) Header.Height; i++)
   {
       EncodedByte=ReadBlobLSBShort(image);
",1,coders/cut.c,9,java,imagemagick___imagemagick6,test
551,2554,bf208048283f56435daa8abc2357fdd42976ba18,"@@ -14,17 +14,17 @@
  */
 
 typedef enum {
-    NJS_NULL                  = 0x00,
-    NJS_UNDEFINED             = 0x01,
+    NJS_NULL,
+    NJS_UNDEFINED,
 
     /* The order of the above type is used in njs_is_null_or_undefined(). */
 
-    NJS_BOOLEAN               = 0x02,
+    NJS_BOOLEAN,
     /*
      * The order of the above type is used in
      * njs_is_null_or_undefined_or_boolean().
      */
-    NJS_NUMBER                = 0x03,
+    NJS_NUMBER,
     /*
      * The order of the above type is used in njs_is_numeric().
      * Booleans, null and void values can be used in mathematical operations:
@@ -32,16 +32,16 @@ typedef enum {
      *   a numeric value of the null and false values is zero,
      *   a numeric value of the void value is NaN.
      */
-    NJS_SYMBOL                = 0x04,
+    NJS_SYMBOL,
 
-    NJS_STRING                = 0x05,
+    NJS_STRING,
 
     /* The order of the above type is used in njs_is_primitive(). */
 
-    NJS_DATA                  = 0x06,
+    NJS_DATA,
 
     /* The type is external code. */
-    NJS_EXTERNAL              = 0x07,
+    NJS_EXTERNAL,
 
     /*
      * The invalid value type is used:
@@ -49,7 +49,7 @@ typedef enum {
      *   to detect non-declared explicitly or implicitly variables,
      *   for native property getters.
      */
-    NJS_INVALID               = 0x08,
+    NJS_INVALID,
 
     /*
      * The object types are >= NJS_OBJECT, this is used in njs_is_object().
@@ -59,17 +59,22 @@ typedef enum {
      * is used in vm->prototypes and vm->constructors arrays.
      */
     NJS_OBJECT                = 0x10,
-    NJS_ARRAY                 = 0x11,
-    NJS_OBJECT_BOOLEAN        = 0x12,
-    NJS_OBJECT_NUMBER         = 0x13,
-    NJS_OBJECT_SYMBOL         = 0x14,
-    NJS_OBJECT_STRING         = 0x15,
-    NJS_FUNCTION              = 0x16,
-    NJS_REGEXP                = 0x17,
-    NJS_DATE                  = 0x18,
-    NJS_PROMISE               = 0x19,
-    NJS_OBJECT_VALUE          = 0x1A,
-    NJS_ARRAY_BUFFER          = 0x1B,
+    NJS_ARRAY,
+#define NJS_OBJECT_WRAPPER_MIN  (NJS_OBJECT_BOOLEAN)
+    NJS_OBJECT_BOOLEAN,
+    NJS_OBJECT_NUMBER,
+    NJS_OBJECT_SYMBOL,
+    NJS_OBJECT_STRING,
+#define NJS_OBJECT_WRAPPER_MAX  (NJS_OBJECT_STRING + 1)
+#define NJS_OBJECT_SPECIAL_MIN  (NJS_FUNCTION)
+    NJS_FUNCTION,
+    NJS_REGEXP,
+    NJS_DATE,
+    NJS_TYPED_ARRAY,
+#define NJS_OBJECT_SPECIAL_MAX  (NJS_TYPED_ARRAY + 1)
+    NJS_PROMISE,
+    NJS_OBJECT_VALUE,
+    NJS_ARRAY_BUFFER,
     NJS_VALUE_TYPE_MAX
 } njs_value_type_t;
 
@@ -82,6 +87,7 @@ typedef struct njs_function_lambda_s  njs_function_lambda_t;
 typedef struct njs_regexp_pattern_s   njs_regexp_pattern_t;
 typedef struct njs_array_s            njs_array_t;
 typedef struct njs_array_buffer_s     njs_array_buffer_t;
+typedef struct njs_typed_array_s      njs_typed_array_t;
 typedef struct njs_regexp_s           njs_regexp_t;
 typedef struct njs_date_s             njs_date_t;
 typedef struct njs_object_value_s     njs_promise_t;
@@ -143,6 +149,7 @@ union njs_value_s {
             njs_object_t              *object;
             njs_array_t               *array;
             njs_array_buffer_t        *array_buffer;
+            njs_typed_array_t         *typed_array;
             njs_object_value_t        *object_value;
             njs_function_t            *function;
             njs_function_lambda_t     *lambda;
@@ -249,6 +256,15 @@ struct njs_array_buffer_s {
 };
 
 
+struct njs_typed_array_s {
+    njs_object_t                      object;
+    njs_array_buffer_t                *buffer;
+    size_t                            offset; // byte_offset / element_size
+    size_t                            byte_length;
+    uint8_t                           type;
+};
+
+
 typedef struct {
     union {
         uint32_t                      count;
@@ -345,6 +361,7 @@ typedef enum {
 typedef enum {
     NJS_PROPERTY = 0,
     NJS_PROPERTY_REF,
+    NJS_PROPERTY_TYPED_ARRAY_REF,
     NJS_PROPERTY_HANDLER,
     NJS_WHITEOUT,
 } njs_object_prop_type_t;
@@ -634,6 +651,10 @@ typedef struct {
     ((value)->type == NJS_ARRAY_BUFFER)
 
 
+#define njs_is_typed_array(value)                                             \
+    ((value)->type == NJS_TYPED_ARRAY)
+
+
 #define njs_is_function(value)                                                \
     ((value)->type == NJS_FUNCTION)
 
@@ -710,6 +731,14 @@ typedef struct {
     ((value)->data.u.array_buffer)
 
 
+#define njs_typed_array(value)                                                \
+    ((value)->data.u.typed_array)
+
+
+#define njs_typed_array_buffer(value)                                         \
+    ((value)->buffer)
+
+
 #define njs_array_start(value)                                                \
     ((value)->data.u.array->start)
 
@@ -870,6 +899,15 @@ njs_set_array_buffer(njs_value_t *value, njs_array_buffer_t *array)
 }
 
 
+njs_inline void
+njs_set_typed_array(njs_value_t *value, njs_typed_array_t *array)
+{
+    value->data.u.typed_array = array;
+    value->type = NJS_TYPED_ARRAY;
+    value->data.truth = 1;
+}
+
+
 njs_inline void
 njs_set_function(njs_value_t *value, njs_function_t *function)
 {
",1,src/njs_value.h,78,java,nginx___njs,test
7963,37564,430b00361b76827c055c63fb6398a520b25ed770,"@@ -66,8 +66,8 @@ TfLiteStatus SelectPrepare(TfLiteContext* context, TfLiteNode* node) {
   TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
 
   // Input must be bool.
-  TF_LITE_ENSURE(context, input_condition->type == kTfLiteBool);
-  TF_LITE_ENSURE_EQ(context, input_x->type, input_y->type);
+  TF_LITE_ENSURE_TYPES_EQ(context, input_condition->type, kTfLiteBool);
+  TF_LITE_ENSURE_TYPES_EQ(context, input_x->type, input_y->type);
   output->type = input_x->type;
 
   bool same_shape = HaveSameShapes(input_condition, input_x) &&
",1,tensorflow/lite/kernels/select.cc,4,java,tensorflow___tensorflow,test
5039,23778,c3f0f54e148e0866869a2ff67aab20db2a1949af,"@@ -270,21 +270,16 @@ static void add_key(EVP_PKEY * key, EVP_PKEY *** keys, int *nkeys)
 	(*nkeys)++;
 }
 
-extern int match_user(X509 * x509, const char *login)
+extern int match_user(EVP_PKEY *authkey, const char *login)
 {
 	char filename[PATH_MAX];
 	char line[OPENSSH_LINE_MAX];
 	struct passwd *pw;
 	FILE *file;
 	EVP_PKEY **keys = NULL;
-	EVP_PKEY *authkey;
 	const BIGNUM *rsa_e, *rsa_n, *auth_e, *auth_n;
 	int nkeys = 0, i;
 
-	authkey = X509_get_pubkey(x509);
-	if (!authkey)
-		return 0;
-
 	pw = getpwnam(login);
 	if (!pw || !pw->pw_dir)
 		return -1;
@@ -324,24 +319,9 @@ extern int match_user(X509 * x509, const char *login)
 	fclose(file);
 
 	for (i = 0; i < nkeys; i++) {
-		RSA *authrsa, *rsa;
-
-		authrsa = EVP_PKEY_get1_RSA(authkey);
-		if (!authrsa)
-			continue;	/* not RSA */
-
-		rsa = EVP_PKEY_get1_RSA(keys[i]);
-		if (!rsa)
-			continue;	/* not RSA */
-
-		RSA_get0_key(rsa, &rsa_n, &rsa_e, NULL);
-		RSA_get0_key(authrsa, &auth_n, &auth_e, NULL);
-
-		if (BN_cmp(rsa_e, auth_e) != 0)
-			continue;
-		if (BN_cmp(rsa_n, auth_n) != 0)
-			continue;
-		return 1;	/* FOUND */
+		if (1 == EVP_PKEY_cmp(authkey, keys[i])) {
+			return 1;	/* FOUND */
+		}
 	}
 	return 0;
 }
",1,src/match_openssh.c,28,java,opensc___pam_p11,test
8041,38033,853c918e94aa6bfedcb61418ab09ec574f8ff98f,"@@ -248,7 +248,7 @@ static Bool initGLES2(AndroidContext *rc) {
 
 static void load_matrix_shaders(GLuint program, Fixed *mat, const char *name)
 {
-	GLint loc=-1;
+	GLint loc;
 #ifdef GPAC_FIXED_POINT
 	Float _mat[16];
 	u32 i;
@@ -351,13 +351,13 @@ void initGL(AndroidContext *rc)
 void gluPerspective(GLfloat fovy, GLfloat aspect,
                     GLfloat zNear, GLfloat zFar)
 {
+#ifndef GPAC_USE_GLES2
 	GLfloat xmin, xmax, ymin, ymax;
 
 	ymax = zNear * (GLfloat)tan(fovy * PI / 360);
 	ymin = -ymax;
 	xmin = ymin * aspect;
 	xmax = ymax * aspect;
-#ifndef GPAC_USE_GLES2
 	glFrustumx((GLfixed)(xmin * 65536), (GLfixed)(xmax * 65536),
 	           (GLfixed)(ymin * 65536), (GLfixed)(ymax * 65536),
 	           (GLfixed)(zNear * 65536), (GLfixed)(zFar * 65536));
@@ -367,16 +367,10 @@ void gluPerspective(GLfloat fovy, GLfloat aspect,
 void resizeWindow(AndroidContext *rc)
 {
 	GF_LOG(GF_LOG_DEBUG, GF_LOG_MMIO, (""resizeWindow : start""));
-	/* Height / width ration */
-	GLfloat ratio;
 
 	/* Protect against a divide by zero */
 	if (rc->height==0)
-	{
-		rc->height=1;
-	}
-
-	ratio=(GLfloat)rc->width/(GLfloat)rc->height;
+		rc->height = 1;
 
 	/* Setup our viewport. */
 	glViewport(0, 0, (GLsizei)rc->width, (GLsizei)rc->height);
@@ -418,13 +412,15 @@ void drawGLScene(AndroidContext *rc)
 	GLfloat texcoord[4][2];
 //	int i, j;
 
+#ifndef GPAC_USE_GLES2
 	float rgba[4];
+#endif
 	gl_check_error();
 
 	// Reset states
+#ifndef GPAC_USE_GLES2
 	rgba[0] = rgba[1] = rgba[2] = 0.f;
 	rgba[0] = 1.f;
-#ifndef GPAC_USE_GLES2
 	glColor4f(1.f, 1.f, 1.f, 1.f);
 	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, rgba);
 	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, rgba);
@@ -462,9 +458,9 @@ void drawGLScene(AndroidContext *rc)
 	gl_check_error();
 	if ( rc->draw_texture )
 	{
+#ifndef GPAC_USE_GLES2
 		gl_check_error();
 		int cropRect[4] = {0,rc->height,rc->width,-rc->height};
-#ifndef GPAC_USE_GLES2
 		glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, cropRect);
 		glDrawTexsOES(0, 0, 0, rc->width, rc->height);
 #endif
",1,modules/droid_out/droid_vout.c,18,java,gpac___gpac,test
8645,41058,8e0264cfd6889b73c241b60736fe96ba1322ee6e,"@@ -27,7 +27,7 @@ static int freeRedisRunLoop(RedisRunLoop* redisRunLoop) {
             CFSocketInvalidate(redisRunLoop->socketRef);
             CFRelease(redisRunLoop->socketRef);
         }
-        free(redisRunLoop);
+        hi_free(redisRunLoop);
     }
     return REDIS_ERR;
 }
@@ -80,8 +80,9 @@ static int redisMacOSAttach(redisAsyncContext *redisAsyncCtx, CFRunLoopRef runLo
     /* Nothing should be attached when something is already attached */
     if( redisAsyncCtx->ev.data != NULL ) return REDIS_ERR;
 
-    RedisRunLoop* redisRunLoop = (RedisRunLoop*) calloc(1, sizeof(RedisRunLoop));
-    if( !redisRunLoop ) return REDIS_ERR;
+    RedisRunLoop* redisRunLoop = (RedisRunLoop*) hi_calloc(1, sizeof(RedisRunLoop));
+    if (redisRunLoop == NULL)
+        return REDIS_ERR;
 
     /* Setup redis stuff */
     redisRunLoop->context = redisAsyncCtx;
",1,adapters/macosx.h,7,java,redis___hiredis,test
549,2546,841b86f3289dbe858daeceec36423d4ea286fac2,"@@ -963,8 +963,8 @@ static void do_act_open_rpl(struct cxgbi_device *cdev, struct sk_buff *skb)
 	spin_lock_bh(&csk->lock);
 
 	if (status == CPL_ERR_CONN_EXIST &&
-	    csk->retry_timer.function != (TIMER_FUNC_TYPE)csk_act_open_retry_timer) {
-		csk->retry_timer.function = (TIMER_FUNC_TYPE)csk_act_open_retry_timer;
+	    csk->retry_timer.function != csk_act_open_retry_timer) {
+		csk->retry_timer.function = csk_act_open_retry_timer;
 		mod_timer(&csk->retry_timer, jiffies + HZ / 2);
 	} else
 		cxgbi_sock_fail_act_open(csk,
",1,drivers/scsi/cxgbi/cxgb4i/cxgb4i.c,4,java,torvalds___linux,test
2490,11896,bc122ae0df1c033dac6b979e54084304c08d8afa,"@@ -437,7 +437,7 @@ apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,
 
 	/* read the parameters that are POST-ed to us */
 	apr_table_t *params = apr_table_make(r->pool, 8);
-	if (oidc_util_read_post_params(r, params) == FALSE) {
+	if (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {
 		oidc_error(r, ""something went wrong when reading the POST parameters"");
 		return FALSE;
 	}
@@ -2160,7 +2160,7 @@ static int oidc_handle_post_authorization_response(request_rec *r, oidc_cfg *c,
 
 	/* read the parameters that are POST-ed to us */
 	apr_table_t *params = apr_table_make(r->pool, 8);
-	if (oidc_util_read_post_params(r, params) == FALSE) {
+	if (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {
 		oidc_error(r, ""something went wrong when reading the POST parameters"");
 		return HTTP_INTERNAL_SERVER_ERROR;
 	}
@@ -2844,7 +2844,7 @@ static int oidc_handle_logout_backchannel(request_rec *r, oidc_cfg *cfg) {
 	int rc = HTTP_BAD_REQUEST;
 
 	apr_table_t *params = apr_table_make(r->pool, 8);
-	if (oidc_util_read_post_params(r, params) == FALSE) {
+	if (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {
 		oidc_error(r,
 				""could not read POST-ed parameters to the logout endpoint"");
 		goto out;
@@ -4088,10 +4088,30 @@ int oidc_auth_checker(request_rec *r) {
 
 #endif
 
+apr_byte_t oidc_enabled(request_rec *r) {
+	if (ap_auth_type(r) == NULL)
+		return FALSE;
+
+	if (apr_strnatcasecmp((const char *) ap_auth_type(r),
+			OIDC_AUTH_TYPE_OPENID_CONNECT) == 0)
+		return TRUE;
+
+	if (apr_strnatcasecmp((const char *) ap_auth_type(r),
+			OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)
+		return TRUE;
+
+	if (apr_strnatcasecmp((const char *) ap_auth_type(r),
+			OIDC_AUTH_TYPE_OPENID_BOTH) == 0)
+		return TRUE;
+
+	return FALSE;
+}
 /*
  * handle content generating requests
  */
 int oidc_content_handler(request_rec *r) {
+	if (oidc_enabled(r) == FALSE)
+		return DECLINED;
 	oidc_cfg *c = ap_get_module_config(r->server->module_config,
 			&auth_openidc_module);
 	return oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c)) ?
",1,src/mod_auth_openidc.c,26,java,zmartzone___mod_auth_openidc,test
6425,30226,271f6bb49d2140b4c1bca88391caedd1791561cf,"@@ -39,7 +39,7 @@ class SummaryAudioOp : public OpKernel {
   void Compute(OpKernelContext* c) override {
     const Tensor& tag = c->input(0);
     const Tensor& tensor = c->input(1);
-    OP_REQUIRES(c, IsLegacyScalar(tag.shape()),
+    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),
                 errors::InvalidArgument(""Tag must be a scalar""));
     OP_REQUIRES(c, tensor.dims() >= 2 && tensor.dims() <= 3,
                 errors::InvalidArgument(""Tensor must be 3-D or 2-D, got: "",
",1,tensorflow/core/kernels/summary_audio_op.cc,2,java,tensorflow___tensorflow,test
2934,13977,065f3bf4f2b3dbef086a32a520e4f15e47c164e4,"@@ -1487,7 +1487,7 @@ Fts5ExprNearset *sqlite3Fts5ParseNearset(
       if( pRet==0 ){
         pParse->rc = SQLITE_NOMEM;
       }else{
-        memset(pRet, 0, nByte);
+        memset(pRet, 0, (size_t)nByte);
       }
     }else if( (pNear->nPhrase % SZALLOC)==0 ){
       int nNew = pNear->nPhrase + SZALLOC;
@@ -1563,7 +1563,7 @@ static int fts5ParseTokenize(
     if( pSyn==0 ){
       rc = SQLITE_NOMEM;
     }else{
-      memset(pSyn, 0, nByte);
+      memset(pSyn, 0, (size_t)nByte);
       pSyn->zTerm = ((char*)pSyn) + sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer);
       memcpy(pSyn->zTerm, pToken, nToken);
       pSyn->pSynonym = pPhrase->aTerm[pPhrase->nTerm-1].pSynonym;
@@ -1723,7 +1723,7 @@ int sqlite3Fts5ExprClonePhrase(
       nByte = sizeof(Fts5Colset) + (pColsetOrig->nCol-1) * sizeof(int);
       pColset = (Fts5Colset*)sqlite3Fts5MallocZero(&rc, nByte);
       if( pColset ){ 
-        memcpy(pColset, pColsetOrig, nByte);
+        memcpy(pColset, pColsetOrig, (size_t)nByte);
       }
       pNew->pRoot->pNear->pColset = pColset;
     }
@@ -1940,7 +1940,7 @@ static Fts5Colset *fts5CloneColset(int *pRc, Fts5Colset *pOrig){
     sqlite3_int64 nByte = sizeof(Fts5Colset) + (pOrig->nCol-1) * sizeof(int);
     pRet = (Fts5Colset*)sqlite3Fts5MallocZero(pRc, nByte);
     if( pRet ){ 
-      memcpy(pRet, pOrig, nByte);
+      memcpy(pRet, pOrig, (size_t)nByte);
     }
   }else{
     pRet = 0;
",1,ext/fts5/fts5_expr.c,8,java,sqlite___sqlite,test
483,2291,cd7f9fb7751b0d59d5a74b12d971155caad5a792,"@@ -1245,6 +1245,11 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
         TIFFClose(tiff);
         ThrowReaderException(CorruptImageError,""UnsupportedBitsPerPixel"");
       }
+    if (samples_per_pixel > MaxPixelChannels)
+      {
+        TIFFClose(tiff);
+        ThrowReaderException(CorruptImageError,""MaximumChannelsExceeded"");
+      }
     if (sample_format == SAMPLEFORMAT_IEEEFP)
       (void) SetImageProperty(image,""quantum:format"",""floating-point"");
     switch (photometric)
@@ -1617,11 +1622,6 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
       }
     if (image->matte != MagickFalse)
       (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
-    if (samples_per_pixel > MaxPixelChannels)
-      {
-        TIFFClose(tiff);
-        ThrowReaderException(CorruptImageError,""MaximumChannelsExceeded"");
-      }
     method=ReadGenericMethod;
     rows_per_strip=(uint32) image->rows;
     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
",0,coders/tiff.c,10,java,imagemagick___imagemagick6,test
650,3026,0953736b7e97f6e121a0587a95434bf1857a27da,"@@ -84,7 +84,7 @@ const int16_t ff_nelly_delta_table[32] = {
 
 static inline int signed_shift(int i, int shift) {
     if (shift > 0)
-        return i << shift;
+        return (unsigned)i << shift;
     return i >> -shift;
 }
 
@@ -108,7 +108,7 @@ static int headroom(int *la)
         return 31;
     }
     l = 30 - av_log2(FFABS(*la));
-    *la <<= l;
+    *la *= 1<<l;
     return l;
 }
 
",0,libavcodec/nellymoser.c,4,java,ffmpeg___ffmpeg,test
9252,43967,1c40f9042ae2d6ee7483d72998aabb5e73b2ff60,"@@ -58,7 +58,7 @@ ResourceRequestBlockedReason BaseFetchContext::CanRequest(
   if (blocked_reason != ResourceRequestBlockedReason::kNone &&
       reporting_policy == SecurityViolationReportingPolicy::kReport) {
     DispatchDidBlockRequest(resource_request, options.initiator_info,
-                            blocked_reason);
+                            blocked_reason, type);
   }
   return blocked_reason;
 }
",0,third_party/WebKit/Source/core/loader/BaseFetchContext.cpp,2,java,chromium___chromium,test
8264,39045,d6a0f20592b4fd8f739c09f7d278f84499286430,"@@ -18,6 +18,7 @@ limitations under the License.
 #include <unordered_set>
 
 #include ""tensorflow/cc/saved_model/constants.h""
+#include ""tensorflow/cc/saved_model/loader_util.h""
 #include ""tensorflow/cc/saved_model/reader.h""
 #include ""tensorflow/core/framework/attr_value.pb.h""
 #include ""tensorflow/core/framework/node_def.pb.h""
@@ -29,7 +30,6 @@ limitations under the License.
 #include ""tensorflow/core/lib/strings/strcat.h""
 #include ""tensorflow/core/platform/env.h""
 #include ""tensorflow/core/platform/errors.h""
-#include ""tensorflow/core/platform/protobuf_internal.h""
 #include ""tensorflow/core/protobuf/graph_debug_info.pb.h""
 #include ""tensorflow/core/protobuf/saver.pb.h""
 #include ""tensorflow/core/public/session.h""
@@ -191,41 +191,6 @@ Status RunInitOp(const RunOptions& run_options, const string& export_dir,
   return Status::OK();
 }
 
-// A SavedModel may store the name of the initialization op to run in the
-// in the SignatureDef (v2) or a collection (v1). If an init_op collection
-// exists, then the collection must contain exactly one op.
-Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,
-                 string* init_op_name) {
-  const auto& sig_def_map = meta_graph_def.signature_def();
-  const auto& init_op_sig_it =
-      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);
-  if (init_op_sig_it != sig_def_map.end()) {
-    *init_op_name = init_op_sig_it->second.outputs()
-                        .find(kSavedModelInitOpSignatureKey)
-                        ->second.name();
-    return Status::OK();
-  }
-
-  const auto& collection_def_map = meta_graph_def.collection_def();
-  string init_op_collection_key;
-  if (collection_def_map.find(kSavedModelMainOpKey) !=
-      collection_def_map.end()) {
-    init_op_collection_key = kSavedModelMainOpKey;
-  } else {
-    init_op_collection_key = kSavedModelLegacyInitOpKey;
-  }
-
-  const auto init_op_it = collection_def_map.find(init_op_collection_key);
-  if (init_op_it != collection_def_map.end()) {
-    if (init_op_it->second.node_list().value_size() != 1) {
-      return errors::FailedPrecondition(
-          strings::StrCat(""Expected exactly one main op in : "", export_dir));
-    }
-    *init_op_name = init_op_it->second.node_list().value(0);
-  }
-  return Status::OK();
-}
-
 Status RunRestore(const RunOptions& run_options, const string& export_dir,
                   const StringPiece restore_op_name,
                   const StringPiece variable_filename_const_op_name,
@@ -263,32 +228,6 @@ Status RunRestore(const RunOptions& run_options, const string& export_dir,
                  nullptr /* outputs */, &run_metadata, session);
 }
 
-Status GetAssetFileDefs(const MetaGraphDef& meta_graph_def,
-                        std::vector<AssetFileDef>* asset_file_defs) {
-  // With SavedModel v2, we write asset file def into metagraph instead of
-  // collection, so read from metagraph first.
-  if (meta_graph_def.asset_file_def_size() > 0) {
-    for (const auto& asset : meta_graph_def.asset_file_def()) {
-      asset_file_defs->push_back(asset);
-    }
-    return Status::OK();
-  }
-  // Fall back to read from collection to be backward compatible with v1.
-  const auto& collection_def_map = meta_graph_def.collection_def();
-  const auto assets_it = collection_def_map.find(kSavedModelAssetsKey);
-  if (assets_it == collection_def_map.end()) {
-    return Status::OK();
-  }
-  const auto& any_assets = assets_it->second.any_list().value();
-  for (const auto& any_asset : any_assets) {
-    AssetFileDef asset_file_def;
-    TF_RETURN_IF_ERROR(
-        ParseAny(any_asset, &asset_file_def, ""tensorflow.AssetFileDef""));
-    asset_file_defs->push_back(asset_file_def);
-  }
-  return Status::OK();
-}
-
 Status ReadSavedModelDebugInfoIfPresent(
     const string& export_dir,
     std::unique_ptr<GraphDebugInfo>* debug_info_proto) {
@@ -322,7 +261,7 @@ Status LoadSavedModelInternal(const SessionOptions& session_options,
 
   std::vector<AssetFileDef> asset_file_defs;
   TF_RETURN_IF_ERROR(
-      GetAssetFileDefs(bundle->meta_graph_def, &asset_file_defs));
+      internal::GetAssetFileDefs(bundle->meta_graph_def, &asset_file_defs));
   TF_RETURN_IF_ERROR(
       RunRestore(run_options, export_dir,
                  bundle->meta_graph_def.saver_def().restore_op_name(),
@@ -336,7 +275,7 @@ Status LoadSavedModelInternal(const SessionOptions& session_options,
   const uint64 graph_init_start_microseconds = Env::Default()->NowMicros();
   string init_op_name;
   TF_RETURN_IF_ERROR(
-      GetInitOp(export_dir, bundle->meta_graph_def, &init_op_name));
+      internal::GetInitOp(export_dir, bundle->meta_graph_def, &init_op_name));
   TF_RETURN_IF_ERROR(RunInitOp(run_options, export_dir, bundle->meta_graph_def,
                                asset_file_defs, bundle->session.get(),
                                init_op_name));
",1,tensorflow/cc/saved_model/loader.cc,67,java,tensorflow___tensorflow,test
5697,26824,c6503be587e9c5c0aac4e2b45de982352f676a5b,"@@ -644,7 +644,7 @@ void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)
 	struct timespec64 ts64;
 	bool sig_none;
 
-	sig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE;
+	sig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;
 	iv = timr->it_interval;
 
 	/* interval timer ? */
",1,kernel/time/posix-timers.c,2,java,torvalds___linux,test
1211,5854,e8d5a25e4889e7d5006f6eba12d11ab1f6b69136,"@@ -222,7 +222,6 @@ static inline void crxFillBuffer(CrxBitstream *bitStrm)
 
 libraw_inline int crxBitstreamGetZeros(CrxBitstream *bitStrm)
 {
-  uint32_t bitData = bitStrm->bitData;
   uint32_t nonZeroBit = 0;
   uint64_t nextData = 0;
   int32_t result = 0;
@@ -2060,7 +2059,6 @@ int crxReadSubbandHeaders(crx_data_header_t *hdr, CrxImage *img, CrxTile *tile,
 
   if (!img->subbandCount)
     return 0;
-  int32_t curSubband = 0;
   int32_t subbandOffset = 0;
   band = comp->subBands;
   for (int curSubband = 0; curSubband < img->subbandCount; curSubband++, band++)
@@ -2074,7 +2072,7 @@ int crxReadSubbandHeaders(crx_data_header_t *hdr, CrxImage *img, CrxTile *tile,
     uint32_t bitData = LibRaw::sgetn(4, *subbandMdatPtr + 8);
     uint32_t subbandSize = LibRaw::sgetn(4, *subbandMdatPtr + 4);
 
-    if (curSubband != bitData >> 28)
+    if ((unsigned)curSubband != bitData >> 28)
     {
       band->dataSize = subbandSize;
       return -1;
@@ -2207,7 +2205,7 @@ int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,
 
     if (LibRaw::sgetn(2, dataPtr) != 0xFF01)
       return -1;
-    if (LibRaw::sgetn(2, dataPtr + 8) != curTile)
+    if (LibRaw::sgetn(2, dataPtr + 8) != (unsigned)curTile)
       return -1;
 
     dataSize -= 0xC;
@@ -2527,7 +2525,7 @@ int LibRaw::crxParseImageHeader(uchar *cmp1TagData, int nTrack)
       return -1;
   }
   else if (hdr->nPlanes != 4 || hdr->f_width & 1 || hdr->f_height & 1 ||
-           hdr->tileWidth & 1 || hdr->tileHeight & 1 || hdr->cfaLayout > 3u ||
+           hdr->tileWidth & 1 || hdr->tileHeight & 1 || hdr->cfaLayout > 3 ||
            (hdr->encType && hdr->encType != 1 && hdr->encType != 3) ||
            hdr->nBits == 8)
     return -1;
",1,src/decoders/crx.cpp,8,java,libraw___libraw,test
4046,18980,2ac67cb63b715989657cee97b3181455b1380b3f,"@@ -861,6 +861,64 @@ static enum ssh_variant determine_ssh_variant(const char *ssh_command,
 	return ssh_variant;
 }
 
+/*
+ * Open a connection using Git's native protocol.
+ *
+ * The caller is responsible for freeing hostandport, but this function may
+ * modify it (for example, to truncate it to remove the port part).
+ */
+static struct child_process *git_connect_git(int fd[2], char *hostandport,
+					     const char *path, const char *prog,
+					     int flags)
+{
+	struct child_process *conn;
+	struct strbuf request = STRBUF_INIT;
+	/*
+	 * Set up virtual host information based on where we will
+	 * connect, unless the user has overridden us in
+	 * the environment.
+	 */
+	char *target_host = getenv(""GIT_OVERRIDE_VIRTUAL_HOST"");
+	if (target_host)
+		target_host = xstrdup(target_host);
+	else
+		target_host = xstrdup(hostandport);
+
+	transport_check_allowed(""git"");
+
+	/* These underlying connection commands die() if they
+	 * cannot connect.
+	 */
+	if (git_use_proxy(hostandport))
+		conn = git_proxy_connect(fd, hostandport);
+	else
+		conn = git_tcp_connect(fd, hostandport, flags);
+	/*
+	 * Separate original protocol components prog and path
+	 * from extended host header with a NUL byte.
+	 *
+	 * Note: Do not add any other headers here!  Doing so
+	 * will cause older git-daemon servers to crash.
+	 */
+	strbuf_addf(&request,
+		    ""%s %s%chost=%s%c"",
+		    prog, path, 0,
+		    target_host, 0);
+
+	/* If using a new version put that stuff here after a second null byte */
+	if (get_protocol_version_config() > 0) {
+		strbuf_addch(&request, '\0');
+		strbuf_addf(&request, ""version=%d%c"",
+			    get_protocol_version_config(), '\0');
+	}
+
+	packet_write(fd[1], request.buf, request.len);
+
+	free(target_host);
+	strbuf_release(&request);
+	return conn;
+}
+
 /*
  * This returns the dummy child_process `no_fork` if the transport protocol
  * does not need fork(2), or a struct child_process object if it does.  Once
@@ -892,50 +950,7 @@ struct child_process *git_connect(int fd[2], const char *url,
 		printf(""Diag: path=%s\n"", path ? path : ""NULL"");
 		conn = NULL;
 	} else if (protocol == PROTO_GIT) {
-		struct strbuf request = STRBUF_INIT;
-		/*
-		 * Set up virtual host information based on where we will
-		 * connect, unless the user has overridden us in
-		 * the environment.
-		 */
-		char *target_host = getenv(""GIT_OVERRIDE_VIRTUAL_HOST"");
-		if (target_host)
-			target_host = xstrdup(target_host);
-		else
-			target_host = xstrdup(hostandport);
-
-		transport_check_allowed(""git"");
-
-		/* These underlying connection commands die() if they
-		 * cannot connect.
-		 */
-		if (git_use_proxy(hostandport))
-			conn = git_proxy_connect(fd, hostandport);
-		else
-			conn = git_tcp_connect(fd, hostandport, flags);
-		/*
-		 * Separate original protocol components prog and path
-		 * from extended host header with a NUL byte.
-		 *
-		 * Note: Do not add any other headers here!  Doing so
-		 * will cause older git-daemon servers to crash.
-		 */
-		strbuf_addf(&request,
-			    ""%s %s%chost=%s%c"",
-			    prog, path, 0,
-			    target_host, 0);
-
-		/* If using a new version put that stuff here after a second null byte */
-		if (get_protocol_version_config() > 0) {
-			strbuf_addch(&request, '\0');
-			strbuf_addf(&request, ""version=%d%c"",
-				    get_protocol_version_config(), '\0');
-		}
-
-		packet_write(fd[1], request.buf, request.len);
-
-		free(target_host);
-		strbuf_release(&request);
+		conn = git_connect_git(fd, hostandport, path, prog, flags);
 	} else {
 		struct strbuf cmd = STRBUF_INIT;
 		const char *const *var;
",1,connect.c,103,java,git___git,test
4571,21520,09ba3bc9dd150457c506e4661380a6183af651c1,"@@ -3835,7 +3835,7 @@ int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,
 		return PTR_ERR(sctx);
 
 	mutex_lock(&fs_info->fs_devices->device_list_mutex);
-	dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);
+	dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);
 	if (!dev || (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) &&
 		     !is_dev_replace)) {
 		mutex_unlock(&fs_info->fs_devices->device_list_mutex);
@@ -4012,7 +4012,7 @@ int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,
 	struct scrub_ctx *sctx = NULL;
 
 	mutex_lock(&fs_info->fs_devices->device_list_mutex);
-	dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);
+	dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);
 	if (dev)
 		sctx = dev->scrub_ctx;
 	if (sctx)
",0,fs/btrfs/scrub.c,4,java,torvalds___linux,test
346,1665,64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,"@@ -206,9 +206,8 @@ void test_checkout_nasty__dot_git_dot(void)
  */
 void test_checkout_nasty__git_tilde1(void)
 {
-#ifdef GIT_WIN32
 	test_checkout_fails(""refs/heads/git_tilde1"", "".git/foobar"");
-#endif
+	test_checkout_fails(""refs/heads/git_tilde1"", ""git~1/foobar"");
 }
 
 /* A tree that contains an entry ""git~2"", when we have forced the short
",0,tests/checkout/nasty.c,3,java,libgit2___libgit2,test
7969,37583,04f2d32871bb3b11d7dc024039952f2fe2750306,"@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)
 static void
 smtp_log_to_file(smtp_t *smtp)
 {
-	FILE *fp = fopen(""/tmp/smtp-alert.log"", ""a"");
+	FILE *fp = fopen_safe(""/tmp/smtp-alert.log"", ""a"");
 	time_t now;
 	struct tm tm;
 	char time_buf[25];
",0,keepalived/core/smtp.c,2,java,acassen___keepalived,test
342,1644,6686aa8acc85ae9a03cecdedc7c9d8b090e2b97b,"@@ -31,6 +31,7 @@
 #include ""source/common/config/grpc_mux_impl.h""
 #include ""source/common/config/new_grpc_mux_impl.h""
 #include ""source/common/config/utility.h""
+#include ""source/common/config/xds_mux/grpc_mux_impl.h""
 #include ""source/common/config/xds_resource.h""
 #include ""source/common/http/codes.h""
 #include ""source/common/http/headers.h""
@@ -849,6 +850,8 @@ void InstanceImpl::terminate() {
   // TODO: figure out the correct fix: https://github.com/envoyproxy/envoy/issues/15072.
   Config::GrpcMuxImpl::shutdownAll();
   Config::NewGrpcMuxImpl::shutdownAll();
+  Config::XdsMux::GrpcMuxSotw::shutdownAll();
+  Config::XdsMux::GrpcMuxDelta::shutdownAll();
 
   if (overload_manager_) {
     overload_manager_->stop();
",1,source/server/server.cc,3,java,envoyproxy___envoy,test
7372,34815,7f11636dbee89b0e4d03e9e2b96e14649a7db778,"@@ -5949,7 +5949,7 @@ void gen_intermediate_code(CPUState *cs, struct TranslationBlock *tb)
         } else if (use_exit_tb(&dc) || status == EXIT_PC_STALE_NOCHAIN) {
             tcg_gen_exit_tb(0);
         } else {
-            tcg_gen_lookup_and_goto_ptr(psw_addr);
+            tcg_gen_lookup_and_goto_ptr();
         }
         break;
     default:
",1,target/s390x/translate.c,2,java,qemu___qemu,test
5431,25616,e40e9d7f0decc799e3ccfe2c418632f8bb52031a,"@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
@@ -1837,8 +1837,9 @@ static CURLcode ssh_statemach_act(struct connectdata *conn, bool *block)
           /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */
           do {
             size_t readthisamountnow =
-              (data->state.resume_from - passed > CURL_OFF_T_C(BUFSIZE)) ?
-              BUFSIZE : curlx_sotouz(data->state.resume_from - passed);
+              (data->state.resume_from - passed > data->set.buffer_size) ?
+              data->set.buffer_size :
+              curlx_sotouz(data->state.resume_from - passed);
 
             size_t actuallyread =
               data->state.fread_func(data->state.buffer, 1,
",1,lib/ssh.c,7,java,curl___curl,test
106,509,1847fae7d3002db5ed1b9f51f408f48d0285a9c8,"@@ -207,9 +207,6 @@ static GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleN
 					if (!header_written) {
 						ref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);
 
-						if (!data_length)
-							data_length = ref_nalu_size + nal_unit_size_field;
-
 						assert(data_length>nal_unit_size_field);
 						data_length -= nal_unit_size_field;
 						if (data_length > gf_bs_available(mdia->extracted_bs)) {
",1,src/isomedia/avc_ext.c,3,java,gpac___gpac,test
9928,47155,1847fae7d3002db5ed1b9f51f408f48d0285a9c8,"@@ -7685,8 +7685,7 @@ GF_Err udta_on_child_box(GF_Box *s, GF_Box *a)
 	box_type = a->type;
 	if (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {
 		GF_UnknownBox* unkn = (GF_UnknownBox *)a;
-		if (unkn)
-			box_type = unkn->original_4cc;
+		box_type = unkn->original_4cc;
 	}
 
 	map = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);
",1,src/isomedia/box_code_base.c,3,java,gpac___gpac,test
7396,34948,e8d5a25e4889e7d5006f6eba12d11ab1f6b69136,"@@ -177,7 +177,7 @@ void LibRaw::parseLeicaMakernote(int base, int uptag, unsigned MakernoteTagType)
 {
   int c;
   uchar ci, cj;
-  unsigned offset = 0, entries, tag, type, len, save;
+  unsigned entries, tag, type, len, save;
   short morder, sorder = order;
   char buf[10];
   int LeicaMakernoteSignature = -1;
@@ -353,6 +353,5 @@ void LibRaw::parseLeicaMakernote(int base, int uptag, unsigned MakernoteTagType)
   next:
     fseek(ifp, save, SEEK_SET);
   }
-quit:
   order = sorder;
 }
",1,src/metadata/leica.cpp,3,java,libraw___libraw,test
2011,9739,66dc50f7057b9a0191f54e55764412202306858d,"@@ -218,8 +218,6 @@ void ioinst_handle_ssch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)
     SubchDev *sch;
     ORB orig_orb, orb;
     uint64_t addr;
-    int ret = -ENODEV;
-    int cc;
     CPUS390XState *env = &cpu->env;
     uint8_t ar;
 
@@ -239,33 +237,11 @@ void ioinst_handle_ssch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)
     }
     trace_ioinst_sch_id(""ssch"", cssid, ssid, schid);
     sch = css_find_subch(m, cssid, ssid, schid);
-    if (sch && css_subch_visible(sch)) {
-        ret = css_do_ssch(sch, &orb);
-    }
-    switch (ret) {
-    case -ENODEV:
-        cc = 3;
-        break;
-    case -EBUSY:
-        cc = 2;
-        break;
-    case -EFAULT:
-        /*
-         * TODO:
-         * I'm wondering whether there is something better
-         * to do for us here (like setting some device or
-         * subchannel status).
-         */
-        program_interrupt(env, PGM_ADDRESSING, 4);
+    if (!sch || !css_subch_visible(sch)) {
+        setcc(cpu, 3);
         return;
-    case 0:
-        cc = 0;
-        break;
-    default:
-        cc = 1;
-        break;
     }
-    setcc(cpu, cc);
+    setcc(cpu, css_do_ssch(sch, &orb));
 }
 
 void ioinst_handle_stcrw(S390CPU *cpu, uint32_t ipb)
@@ -784,8 +760,6 @@ void ioinst_handle_rsch(S390CPU *cpu, uint64_t reg1)
 {
     int cssid, ssid, schid, m;
     SubchDev *sch;
-    int ret = -ENODEV;
-    int cc;
 
     if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {
         program_interrupt(&cpu->env, PGM_OPERAND, 4);
@@ -793,24 +767,11 @@ void ioinst_handle_rsch(S390CPU *cpu, uint64_t reg1)
     }
     trace_ioinst_sch_id(""rsch"", cssid, ssid, schid);
     sch = css_find_subch(m, cssid, ssid, schid);
-    if (sch && css_subch_visible(sch)) {
-        ret = css_do_rsch(sch);
-    }
-    switch (ret) {
-    case -ENODEV:
-        cc = 3;
-        break;
-    case -EINVAL:
-        cc = 2;
-        break;
-    case 0:
-        cc = 0;
-        break;
-    default:
-        cc = 1;
-        break;
+    if (!sch || !css_subch_visible(sch)) {
+        setcc(cpu, 3);
+        return;
     }
-    setcc(cpu, cc);
+    setcc(cpu, css_do_rsch(sch));
 }
 
 #define RCHP_REG1_RES(_reg) (_reg & 0x00000000ff00ff00)
",0,target/s390x/ioinst.c,53,java,qemu___qemu,test
4786,22558,31f61b0d4f8d452becb44f044c739f9057900159,"@@ -1826,7 +1826,7 @@ static int get_cv_pixel_info(
 {
     VTEncContext *vtctx = avctx->priv_data;
     int av_format       = frame->format;
-    int av_color_range  = av_frame_get_color_range(frame);
+    int av_color_range  = frame->color_range;
     int i;
     int range_guessed;
     int status;
@@ -2073,7 +2073,7 @@ static int create_cv_pixel_buffer(AVCodecContext   *avctx,
             AV_LOG_ERROR,
             ""Error: Cannot convert format %d color_range %d: %d\n"",
             frame->format,
-            av_frame_get_color_range(frame),
+            frame->color_range,
             status
         );
 
@@ -2341,8 +2341,8 @@ static int vtenc_populate_extradata(AVCodecContext   *avctx,
     frame->format          = avctx->pix_fmt;
     frame->width           = avctx->width;
     frame->height          = avctx->height;
-    av_frame_set_colorspace(frame, avctx->colorspace);
-    av_frame_set_color_range(frame, avctx->color_range);
+    frame->colorspace      = avctx->colorspace;
+    frame->color_range     = avctx->color_range;
     frame->color_trc       = avctx->color_trc;
     frame->color_primaries = avctx->color_primaries;
 
",1,libavcodec/videotoolboxenc.c,8,java,ffmpeg___ffmpeg,test
4954,23376,ab3f0063c48c26c927851b6767824e35a716d878,"@@ -15,6 +15,7 @@
 #include <linux/err.h>
 #include <linux/rbtree_latch.h>
 #include <linux/numa.h>
+#include <linux/wait.h>
 
 struct perf_event;
 struct bpf_prog;
@@ -182,6 +183,16 @@ struct bpf_verifier_ops {
 				  struct bpf_prog *prog, u32 *target_size);
 };
 
+struct bpf_dev_offload {
+	struct bpf_prog		*prog;
+	struct net_device	*netdev;
+	void			*dev_priv;
+	struct list_head	offloads;
+	bool			dev_state;
+	bool			verifier_running;
+	wait_queue_head_t	verifier_done;
+};
+
 struct bpf_prog_aux {
 	atomic_t refcnt;
 	u32 used_map_cnt;
@@ -199,6 +210,7 @@ struct bpf_prog_aux {
 #ifdef CONFIG_SECURITY
 	void *security;
 #endif
+	struct bpf_dev_offload *offload;
 	union {
 		struct work_struct work;
 		struct rcu_head	rcu;
@@ -317,6 +329,7 @@ extern const struct file_operations bpf_prog_fops;
 #undef BPF_PROG_TYPE
 #undef BPF_MAP_TYPE
 
+extern const struct bpf_prog_ops bpf_offload_prog_ops;
 extern const struct bpf_verifier_ops tc_cls_act_analyzer_ops;
 extern const struct bpf_verifier_ops xdp_analyzer_ops;
 
@@ -491,6 +504,29 @@ static inline int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu,
 }
 #endif /* CONFIG_BPF_SYSCALL */
 
+int bpf_prog_offload_compile(struct bpf_prog *prog);
+void bpf_prog_offload_destroy(struct bpf_prog *prog);
+
+#if defined(CONFIG_NET) && defined(CONFIG_BPF_SYSCALL)
+int bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr);
+
+static inline bool bpf_prog_is_dev_bound(struct bpf_prog_aux *aux)
+{
+	return aux->offload;
+}
+#else
+static inline int bpf_prog_offload_init(struct bpf_prog *prog,
+					union bpf_attr *attr)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline bool bpf_prog_is_dev_bound(struct bpf_prog_aux *aux)
+{
+	return false;
+}
+#endif /* CONFIG_NET && CONFIG_BPF_SYSCALL */
+
 #if defined(CONFIG_STREAM_PARSER) && defined(CONFIG_BPF_SYSCALL)
 struct sock  *__sock_map_lookup_elem(struct bpf_map *map, u32 key);
 int sock_map_prog(struct bpf_map *map, struct bpf_prog *prog, u32 type);
",1,include/linux/bpf.h,36,java,torvalds___linux,test
5858,27571,bed844f109b6c222816740555068de2e101e8018,"@@ -713,6 +713,7 @@ void jslFunctionCharAsString(unsigned char ch, char *str, size_t len) {
 }
 
 void jslTokenAsString(int token, char *str, size_t len) {
+  assert(len>28); // size of largest string
   // see JS_ERROR_TOKEN_BUF_SIZE
   if (token>32 && token<128) {
     assert(len>=4);
@@ -723,18 +724,19 @@ void jslTokenAsString(int token, char *str, size_t len) {
     return;
   }
 
+
   switch (token) {
-  case LEX_EOF : strncpy(str, ""EOF"", len); return;
-  case LEX_ID : strncpy(str, ""ID"", len); return;
-  case LEX_INT : strncpy(str, ""INT"", len); return;
-  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
-  case LEX_STR : strncpy(str, ""STRING"", len); return;
-  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
-  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
-  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
-  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
-  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
-  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
+  case LEX_EOF : strcpy(str, ""EOF""); return;
+  case LEX_ID : strcpy(str, ""ID""); return;
+  case LEX_INT : strcpy(str, ""INT""); return;
+  case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
+  case LEX_STR : strcpy(str, ""STRING""); return;
+  case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
+  case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
+  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
+  case LEX_REGEX : strcpy(str, ""REGEX""); return;
+  case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
+  case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
@@ -809,11 +811,10 @@ void jslTokenAsString(int token, char *str, size_t len) {
       n--; // next token
     }
     assert(n==0);
-    strncpy(str, &tokenNames[p], len);
+    strcpy(str, &tokenNames[p]);
     return;
   }
 
-  assert(len>=10);
   espruino_snprintf(str, len, ""?[%d]"", token);
 }
 
",0,src/jslex.c,27,java,espruino___espruino,test
6507,30615,c363a37a450f925df76b88a87dc733bad75cc452,"@@ -9,6 +9,7 @@
 #include ""mmu-hash64.h""
 #include ""migration/cpu.h""
 #include ""qapi/error.h""
+#include ""kvm_ppc.h""
 
 static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)
 {
@@ -249,6 +250,27 @@ static int cpu_post_load(void *opaque, int version_id)
         }
     }
 
+    /*
+     * If we're running with KVM HV, there is a chance that the guest
+     * is running with KVM HV and its kernel does not have the
+     * capability of dealing with a different PVR other than this
+     * exact host PVR in KVM_SET_SREGS. If that happens, the
+     * guest freezes after migration.
+     *
+     * The function kvmppc_pvr_workaround_required does this verification
+     * by first checking if the kernel has the cap, returning true immediately
+     * if that is the case. Otherwise, it checks if we're running in KVM PR.
+     * If the guest kernel does not have the cap and we're not running KVM-PR
+     * (so, it is running KVM-HV), we need to ensure that KVM_SET_SREGS will
+     * receive the PVR it expects as a workaround.
+     *
+     */
+#if defined(CONFIG_KVM)
+    if (kvmppc_pvr_workaround_required(cpu)) {
+        env->spr[SPR_PVR] = env->spr_cb[SPR_PVR].default_value;
+    }
+#endif
+
     env->lr = env->spr[SPR_LR];
     env->ctr = env->spr[SPR_CTR];
     cpu_write_xer(env, env->spr[SPR_XER]);
",0,target/ppc/machine.c,22,java,qemu___qemu,test
374,1781,8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,"@@ -479,7 +479,7 @@ void M_LoadDefaults (void)
 	while (!feof(f))
 	{
 	    isstring = false;
-	    if (fscanf (f, ""%79s %[^\n]\n"", def, strparm) == 2)
+	    if (fscanf (f, ""%79s %99[^\n]\n"", def, strparm) == 2)
 	    {
 		if (strparm[0] == '""')
 		{
",0,m_misc.c,2,java,axdoomer___doom-vanille,test
8030,37966,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,"@@ -6,12 +6,14 @@
 
 #include <string.h>
 
+#include ""base/containers/span.h""
 #include ""base/logging.h""
 #include ""base/md5.h""
 #include ""base/strings/utf_string_conversions.h""
 #include ""net/ntlm/ntlm.h""
 #include ""net/ntlm/ntlm_buffer_reader.h""
 #include ""net/ntlm/ntlm_buffer_writer.h""
+#include ""net/ntlm/ntlm_constants.h""
 
 namespace net {
 namespace ntlm {
@@ -221,7 +223,8 @@ std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(
     uint8_t v2_hash[kNtlmHashLen];
     GenerateNtlmHashV2(domain, username, password, v2_hash);
     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);
-    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,
+    GenerateNtlmProofV2(v2_hash, server_challenge,
+                        base::make_span<kProofInputLenV2>(v2_proof_input),
                         updated_target_info, v2_proof);
     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);
   } else {
",0,net/ntlm/ntlm_client.cc,5,java,chromium___chromium,test
6146,28995,84ca8ae39b8d029fbe5113525c1e6d265de0e864,"@@ -146,7 +146,7 @@ NodeDef* AddScalarConstNode(int v, MutableGraphView* graph) {
 }
 
 template <>
-NodeDef* AddScalarConstNode(int64 v, MutableGraphView* graph) {
+NodeDef* AddScalarConstNode(int64_t v, MutableGraphView* graph) {
   return AddScalarConstNodeHelper(
       DT_INT64, [v](TensorProto* proto) { proto->add_int64_val(v); }, graph);
 }
@@ -275,7 +275,7 @@ NodeDef* GetInputNode(const NodeDef& node, const MutableGraphView& graph) {
 }
 
 NodeDef* GetInputNode(const NodeDef& node, const MutableGraphView& graph,
-                      int64 i) {
+                      int64_t i) {
   if (node.input_size() <= i) return nullptr;
   MutableGraphView::InputPort input_port = graph.GetInputPort(node.name(), i);
   return graph.GetRegularFanin(input_port).node;
",1,tensorflow/core/grappler/optimizers/data/graph_utils.cc,4,java,tensorflow___tensorflow,test
244,1215,dd739f5a45b3af3d1f65f00fe19af1dbfec7aea7,"@@ -2580,6 +2580,7 @@ static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek
 				cmd = sc + 1;
 				continue;
 			}
+			char op0 = 0;
 			if (*p) {
 				// workaround :D
 				if (p[0] == '@') {
@@ -2591,6 +2592,7 @@ static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek
 				if (p[1] == '@' || (p[1] && p[2] == '@')) {
 					char *q = strchr (p + 1, '""');
 					if (q) {
+						op0 = *q;
 						*q = 0;
 					}
 					haveQuote = q != NULL;
@@ -2644,9 +2646,9 @@ static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek
 					cmd = p + 1;
 				} else {
 					if (*p == '""') {
-						cmd = p + 1;
+						cmd = p;
 					} else {
-						*p = '""';
+						*p = op0;
 						cmd = p;
 					}
 				}
",0,libr/core/cmd.c,6,java,radareorg___radare2,test
9013,42843,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {
   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }
   WebString GetErrorMessage() const override;
   bool DidLoadingProgress() override { return false; }
-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }
-  bool HasSingleSecurityOrigin() const override { return true; }
-  bool DidPassCORSAccessCheck() const override { return true; }
+  bool WouldTaintOrigin() const override { return false; }
   double MediaTimeForTimeValue(double time_value) const override {
     return time_value;
   };
",0,third_party/blink/renderer/platform/testing/empty_web_media_player.h,4,java,chromium___chromium,test
7481,35294,050fad7c4534c13c8eb1d9c2ba66012e014773cb,"@@ -481,11 +481,18 @@ static int bpf_convert_filter(struct sock_filter *prog, int len,
 
 #define BPF_EMIT_JMP							\
 	do {								\
+		const s32 off_min = S16_MIN, off_max = S16_MAX;		\
+		s32 off;						\
+									\
 		if (target >= len || target < 0)			\
 			goto err;					\
-		insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0;	\
+		off = addrs ? addrs[target] - addrs[i] - 1 : 0;		\
 		/* Adjust pc relative offset for 2nd or 3rd insn. */	\
-		insn->off -= insn - tmp_insns;				\
+		off -= insn - tmp_insns;				\
+		/* Reject anything not fitting into insn->off. */	\
+		if (off < off_min || off > off_max)			\
+			goto err;					\
+		insn->off = off;					\
 	} while (0)
 
 		case BPF_JMP | BPF_JA:
",0,net/core/filter.c,11,java,torvalds___linux,test
1426,6846,3d5eecab4a5a00df897253dda5792411a1872732,"@@ -3125,6 +3125,7 @@ int main(int argc, char **argv, char **envp)
     Error *main_loop_err = NULL;
     Error *err = NULL;
     bool list_data_dirs = false;
+    char **dirs;
     typedef struct BlockdevOptions_queue {
         BlockdevOptions *bdo;
         Location loc;
@@ -4309,11 +4310,16 @@ int main(int argc, char **argv, char **envp)
         qemu_set_log(0);
     }
 
-    /* If no data_dir is specified then try to find it relative to the
-       executable path.  */
+    /* add configured firmware directories */
+    dirs = g_strsplit(CONFIG_QEMU_FIRMWAREPATH, G_SEARCHPATH_SEPARATOR_S, 0);
+    for (i = 0; dirs[i] != NULL; i++) {
+        qemu_add_data_dir(dirs[i]);
+    }
+
+    /* try to find datadir relative to the executable path */
     qemu_add_data_dir(os_find_datadir());
 
-    /* If all else fails use the install path specified when building. */
+    /* add the datadir specified when building */
     qemu_add_data_dir(CONFIG_QEMU_DATADIR);
 
     /* -L help lists the data directories and exits. */
",1,vl.c,12,java,qemu___qemu,test
3545,16771,5faf80cd53ecfd16b636d653483144cd12004f46,"@@ -458,7 +458,8 @@ int main(int argc, char *argv[])
 			if (unlikely(STDOUT))
 				failure(""Cannot specify an output filename when outputting to stdout\n"");
 			control->outname = optarg;
-			control->suffix = """";
+			dealloc(control->suffix);
+			control->suffix = strdup("""");
 			break;
 		case 'O':
 			if (control->outname)	/* can't mix -o and -O */
@@ -493,7 +494,8 @@ int main(int argc, char *argv[])
 				failure(""Specified output filename already, can't specify an extension.\n"");
 			if (unlikely(STDOUT))
 				failure(""Cannot specify a filename suffix when outputting to stdout\n"");
-			control->suffix = optarg;
+			dealloc(control->suffix);
+			control->suffix = strdup(optarg);
 			break;
 		case 't':
 			if (control->outname)
",0,main.c,6,java,ckolivas___lrzip,test
6267,29571,b4c915f4b3e15c3e787e319b961e4389762f6309,"@@ -0,0 +1,1230 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+static int FUNC(rbsp_trailing_bits)(CodedBitstreamContext *ctx, RWContext *rw)
+{
+    int err;
+    av_unused int one = 1, zero = 0;
+    xu(1, rbsp_stop_one_bit, one, 1, 1);
+    while (byte_alignment(rw) != 0)
+        xu(1, rbsp_alignment_zero_bit, zero, 0, 0);
+
+    return 0;
+}
+
+static int FUNC(nal_unit_header)(CodedBitstreamContext *ctx, RWContext *rw,
+                                 H264RawNALUnitHeader *current,
+                                 uint32_t valid_type_mask)
+{
+    int err;
+
+    u(1, forbidden_zero_bit, 0, 0);
+    u(2, nal_ref_idc,        0, 3);
+    u(5, nal_unit_type,      0, 31);
+
+    if (!(1 << current->nal_unit_type & valid_type_mask)) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid NAL unit type %d.\n"",
+               current->nal_unit_type);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (current->nal_unit_type == 14 ||
+        current->nal_unit_type == 20 ||
+        current->nal_unit_type == 21) {
+        if (current->nal_unit_type != 21)
+            flag(svc_extension_flag);
+        else
+            flag(avc_3d_extension_flag);
+
+        if (current->svc_extension_flag) {
+            av_log(ctx->log_ctx, AV_LOG_ERROR, ""SVC not supported.\n"");
+            return AVERROR_PATCHWELCOME;
+
+        } else if (current->avc_3d_extension_flag) {
+            av_log(ctx->log_ctx, AV_LOG_ERROR, ""3DAVC not supported.\n"");
+            return AVERROR_PATCHWELCOME;
+
+        } else {
+            av_log(ctx->log_ctx, AV_LOG_ERROR, ""MVC not supported.\n"");
+            return AVERROR_PATCHWELCOME;
+        }
+    }
+
+    return 0;
+}
+
+static int FUNC(scaling_list)(CodedBitstreamContext *ctx, RWContext *rw,
+                              H264RawScalingList *current,
+                              int size_of_scaling_list)
+{
+    int err, i, scale;
+
+    scale = 8;
+    for (i = 0; i < size_of_scaling_list; i++) {
+        xse(delta_scale, current->delta_scale[i], -128, +127);
+        scale = (scale + current->delta_scale[i] + 256) % 256;
+        if (scale == 0)
+            break;
+    }
+
+    return 0;
+}
+
+static int FUNC(hrd_parameters)(CodedBitstreamContext *ctx, RWContext *rw,
+                                H264RawHRD *current)
+{
+    int err, i;
+
+    ue(cpb_cnt_minus1, 0, 31);
+    u(4, bit_rate_scale, 0, 15);
+    u(4, cpb_size_scale, 0, 15);
+
+    for (i = 0; i <= current->cpb_cnt_minus1; i++) {
+        ue(bit_rate_value_minus1[i], 0, UINT32_MAX - 1);
+        ue(cpb_size_value_minus1[i], 0, UINT32_MAX - 1);
+        flag(cbr_flag[i]);
+    }
+
+    u(5, initial_cpb_removal_delay_length_minus1, 0, 31);
+    u(5, cpb_removal_delay_length_minus1,         0, 31);
+    u(5, dpb_output_delay_length_minus1,          0, 31);
+    u(5, time_offset_length,                      0, 31);
+
+    return 0;
+}
+
+static int FUNC(vui_parameters)(CodedBitstreamContext *ctx, RWContext *rw,
+                                H264RawVUI *current, H264RawSPS *sps)
+{
+    int err;
+
+    flag(aspect_ratio_info_present_flag);
+    if (current->aspect_ratio_info_present_flag) {
+        u(8, aspect_ratio_idc, 0, 255);
+        if (current->aspect_ratio_idc == 255) {
+            u(16, sar_width,  0, 65535);
+            u(16, sar_height, 0, 65535);
+        }
+    } else {
+        infer(aspect_ratio_idc, 0);
+    }
+
+    flag(overscan_info_present_flag);
+    if (current->overscan_info_present_flag)
+        flag(overscan_appropriate_flag);
+
+    flag(video_signal_type_present_flag);
+    if (current->video_signal_type_present_flag) {
+        u(3, video_format, 0, 7);
+        flag(video_full_range_flag);
+        flag(colour_description_present_flag);
+        if (current->colour_description_present_flag) {
+            u(8, colour_primaries,         0, 255);
+            u(8, transfer_characteristics, 0, 255);
+            u(8, matrix_coefficients,      0, 255);
+        }
+    } else {
+        infer(video_format,             5);
+        infer(video_full_range_flag,    0);
+        infer(colour_primaries,         2);
+        infer(transfer_characteristics, 2);
+        infer(matrix_coefficients,      2);
+    }
+
+    flag(chroma_loc_info_present_flag);
+    if (current->chroma_loc_info_present_flag) {
+        ue(chroma_sample_loc_type_top_field,    0, 5);
+        ue(chroma_sample_loc_type_bottom_field, 0, 5);
+    } else {
+        infer(chroma_sample_loc_type_top_field,    0);
+        infer(chroma_sample_loc_type_bottom_field, 0);
+    }
+
+    flag(timing_info_present_flag);
+    if (current->timing_info_present_flag) {
+        u(32, num_units_in_tick, 1, UINT32_MAX);
+        u(32, time_scale,        1, UINT32_MAX);
+        flag(fixed_frame_rate_flag);
+    } else {
+        infer(fixed_frame_rate_flag, 0);
+    }
+
+    flag(nal_hrd_parameters_present_flag);
+    if (current->nal_hrd_parameters_present_flag)
+        CHECK(FUNC(hrd_parameters)(ctx, rw, &current->nal_hrd_parameters));
+
+    flag(vcl_hrd_parameters_present_flag);
+    if (current->vcl_hrd_parameters_present_flag)
+        CHECK(FUNC(hrd_parameters)(ctx, rw, &current->vcl_hrd_parameters));
+
+    if (current->nal_hrd_parameters_present_flag ||
+        current->vcl_hrd_parameters_present_flag)
+        flag(low_delay_hrd_flag);
+    else
+        infer(low_delay_hrd_flag, 1 - current->fixed_frame_rate_flag);
+
+    flag(pic_struct_present_flag);
+
+    flag(bitstream_restriction_flag);
+    if (current->bitstream_restriction_flag) {
+        flag(motion_vectors_over_pic_boundaries_flag);
+        ue(max_bytes_per_pic_denom, 0, 16);
+        ue(max_bits_per_mb_denom,   0, 16);
+        ue(log2_max_mv_length_horizontal, 0, 16);
+        ue(log2_max_mv_length_vertical,   0, 16);
+        ue(max_num_reorder_frames,  0, H264_MAX_DPB_FRAMES);
+        ue(max_dec_frame_buffering, 0, H264_MAX_DPB_FRAMES);
+    } else {
+        infer(motion_vectors_over_pic_boundaries_flag, 1);
+        infer(max_bytes_per_pic_denom, 2);
+        infer(max_bits_per_mb_denom,   1);
+        infer(log2_max_mv_length_horizontal, 16);
+        infer(log2_max_mv_length_vertical,   16);
+
+        if ((sps->profile_idc ==  44 || sps->profile_idc ==  86 ||
+             sps->profile_idc == 110 || sps->profile_idc == 110 ||
+             sps->profile_idc == 122 || sps->profile_idc == 244) &&
+            sps->constraint_set3_flag) {
+            infer(max_num_reorder_frames,  0);
+            infer(max_dec_frame_buffering, 0);
+        } else {
+            infer(max_num_reorder_frames,  H264_MAX_DPB_FRAMES);
+            infer(max_dec_frame_buffering, H264_MAX_DPB_FRAMES);
+        }
+    }
+
+    return 0;
+}
+
+static int FUNC(sps)(CodedBitstreamContext *ctx, RWContext *rw,
+                     H264RawSPS *current)
+{
+    int err, i;
+
+    HEADER(""Sequence Parameter Set"");
+
+    CHECK(FUNC(nal_unit_header)(ctx, rw, &current->nal_unit_header,
+                                1 << H264_NAL_SPS));
+
+    u(8, profile_idc, 0, 255);
+
+    flag(constraint_set0_flag);
+    flag(constraint_set1_flag);
+    flag(constraint_set2_flag);
+    flag(constraint_set3_flag);
+    flag(constraint_set4_flag);
+    flag(constraint_set5_flag);
+
+    u(2, reserved_zero_2bits,  0, 0);
+
+    u(8, level_idc, 0, 255);
+
+    ue(seq_parameter_set_id, 0, 31);
+
+    if (current->profile_idc == 100 || current->profile_idc == 110 ||
+        current->profile_idc == 122 || current->profile_idc == 244 ||
+        current->profile_idc ==  44 || current->profile_idc ==  83 ||
+        current->profile_idc ==  86 || current->profile_idc == 118 ||
+        current->profile_idc == 128 || current->profile_idc == 138) {
+        ue(chroma_format_idc, 0, 3);
+
+        if (current->chroma_format_idc == 3)
+            flag(separate_colour_plane_flag);
+        else
+            infer(separate_colour_plane_flag, 0);
+
+        ue(bit_depth_luma_minus8,   0, 6);
+        ue(bit_depth_chroma_minus8, 0, 6);
+
+        flag(qpprime_y_zero_transform_bypass_flag);
+
+        flag(seq_scaling_matrix_present_flag);
+        if (current->seq_scaling_matrix_present_flag) {
+            for (i = 0; i < ((current->chroma_format_idc != 3) ? 8 : 12); i++) {
+                flag(seq_scaling_list_present_flag[i]);
+                if (current->seq_scaling_list_present_flag[i]) {
+                    if (i < 6)
+                        CHECK(FUNC(scaling_list)(ctx, rw,
+                                                 &current->scaling_list_4x4[i],
+                                                 16));
+                    else
+                        CHECK(FUNC(scaling_list)(ctx, rw,
+                                                 &current->scaling_list_8x8[i - 6],
+                                                 64));
+                }
+            }
+        }
+    } else {
+        infer(chroma_format_idc, current->profile_idc == 183 ? 0 : 1);
+
+        infer(separate_colour_plane_flag, 0);
+        infer(bit_depth_luma_minus8,      0);
+        infer(bit_depth_chroma_minus8,    0);
+    }
+
+    ue(log2_max_frame_num_minus4, 0, 12);
+    ue(pic_order_cnt_type, 0, 2);
+
+    if (current->pic_order_cnt_type == 0) {
+        ue(log2_max_pic_order_cnt_lsb_minus4, 0, 12);
+    } else if (current->pic_order_cnt_type == 1) {
+        flag(delta_pic_order_always_zero_flag);
+        se(offset_for_non_ref_pic,         INT32_MIN + 1, INT32_MAX);
+        se(offset_for_top_to_bottom_field, INT32_MIN + 1, INT32_MAX);
+        ue(num_ref_frames_in_pic_order_cnt_cycle, 0, 255);
+
+        for (i = 0; i < current->num_ref_frames_in_pic_order_cnt_cycle; i++)
+            se(offset_for_ref_frame[i], INT32_MIN + 1, INT32_MAX);
+    }
+
+    ue(max_num_ref_frames, 0, H264_MAX_DPB_FRAMES);
+    flag(gaps_in_frame_num_allowed_flag);
+
+    ue(pic_width_in_mbs_minus1,        0, H264_MAX_MB_WIDTH);
+    ue(pic_height_in_map_units_minus1, 0, H264_MAX_MB_HEIGHT);
+
+    flag(frame_mbs_only_flag);
+    if (!current->frame_mbs_only_flag)
+        flag(mb_adaptive_frame_field_flag);
+
+    flag(direct_8x8_inference_flag);
+
+    flag(frame_cropping_flag);
+    if (current->frame_cropping_flag) {
+        ue(frame_crop_left_offset,   0, H264_MAX_WIDTH);
+        ue(frame_crop_right_offset,  0, H264_MAX_WIDTH);
+        ue(frame_crop_top_offset,    0, H264_MAX_HEIGHT);
+        ue(frame_crop_bottom_offset, 0, H264_MAX_HEIGHT);
+    }
+
+    flag(vui_parameters_present_flag);
+    if (current->vui_parameters_present_flag)
+        CHECK(FUNC(vui_parameters)(ctx, rw, &current->vui, current));
+
+    CHECK(FUNC(rbsp_trailing_bits)(ctx, rw));
+
+    return 0;
+}
+
+static int FUNC(sps_extension)(CodedBitstreamContext *ctx, RWContext *rw,
+                               H264RawSPSExtension *current)
+{
+    int err;
+
+    HEADER(""Sequence Parameter Set Extension"");
+
+    CHECK(FUNC(nal_unit_header)(ctx, rw, &current->nal_unit_header,
+                                1 << H264_NAL_SPS_EXT));
+
+    ue(seq_parameter_set_id, 0, 31);
+
+    ue(aux_format_idc, 0, 3);
+
+    if (current->aux_format_idc != 0) {
+        int bits;
+
+        ue(bit_depth_aux_minus8, 0, 4);
+        flag(alpha_incr_flag);
+
+        bits = current->bit_depth_aux_minus8 + 9;
+        u(bits, alpha_opaque_value,      0, (1 << bits) - 1);
+        u(bits, alpha_transparent_value, 0, (1 << bits) - 1);
+    }
+
+    flag(additional_extension_flag);
+
+    CHECK(FUNC(rbsp_trailing_bits)(ctx, rw));
+
+    return 0;
+}
+
+static int FUNC(pps)(CodedBitstreamContext *ctx, RWContext *rw,
+                     H264RawPPS *current)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps;
+    int err, i;
+
+    HEADER(""Picture Parameter Set"");
+
+    CHECK(FUNC(nal_unit_header)(ctx, rw, &current->nal_unit_header,
+                                1 << H264_NAL_PPS));
+
+    ue(pic_parameter_set_id, 0, 255);
+    ue(seq_parameter_set_id, 0, 31);
+
+    sps = h264->sps[current->seq_parameter_set_id];
+    if (!sps) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""SPS id %d not available.\n"",
+               current->seq_parameter_set_id);
+        return AVERROR_INVALIDDATA;
+    }
+
+    flag(entropy_coding_mode_flag);
+    flag(bottom_field_pic_order_in_frame_present_flag);
+
+    ue(num_slice_groups_minus1, 0, 7);
+    if (current->num_slice_groups_minus1 > 0) {
+        unsigned int pic_size;
+        int iGroup;
+
+        pic_size = (sps->pic_width_in_mbs_minus1 + 1) *
+                   (sps->pic_height_in_map_units_minus1 + 1);
+
+        ue(slice_group_map_type, 0, 6);
+
+        if (current->slice_group_map_type == 0) {
+            for (iGroup = 0; iGroup <= current->num_slice_groups_minus1; iGroup++)
+                ue(run_length_minus1[iGroup], 0, pic_size - 1);
+
+        } else if (current->slice_group_map_type == 2) {
+            for (iGroup = 0; iGroup < current->num_slice_groups_minus1; iGroup++) {
+                ue(top_left[iGroup],     0,                         pic_size - 1);
+                ue(bottom_right[iGroup], current->top_left[iGroup], pic_size - 1);
+            }
+        } else if (current->slice_group_map_type == 3 ||
+                   current->slice_group_map_type == 4 ||
+                   current->slice_group_map_type == 5) {
+            flag(slice_group_change_direction_flag);
+            ue(slice_group_change_rate_minus1, 0, pic_size - 1);
+        } else if (current->slice_group_map_type == 6) {
+            ue(pic_size_in_map_units_minus1, pic_size - 1, pic_size - 1);
+            for (i = 0; i <= current->pic_size_in_map_units_minus1; i++)
+                u(av_log2(2 * current->num_slice_groups_minus1 + 1),
+                  slice_group_id[i], 0, current->num_slice_groups_minus1);
+        }
+    }
+
+    ue(num_ref_idx_l0_default_active_minus1, 0, 31);
+    ue(num_ref_idx_l1_default_active_minus1, 0, 31);
+
+    flag(weighted_pred_flag);
+    u(2, weighted_bipred_idc, 0, 2);
+
+    se(pic_init_qp_minus26, -26 - 6 * sps->bit_depth_luma_minus8, +25);
+    se(pic_init_qs_minus26, -26, +25);
+    se(chroma_qp_index_offset, -12, +12);
+
+    flag(deblocking_filter_control_present_flag);
+    flag(constrained_intra_pred_flag);
+    flag(redundant_pic_cnt_present_flag);
+
+    if (more_rbsp_data(current->more_rbsp_data))
+    {
+        flag(transform_8x8_mode_flag);
+
+        flag(pic_scaling_matrix_present_flag);
+        if (current->pic_scaling_matrix_present_flag) {
+            for (i = 0; i < 6 + (((sps->chroma_format_idc != 3) ? 2 : 6) *
+                                 current->transform_8x8_mode_flag); i++) {
+                flag(pic_scaling_list_present_flag[i]);
+                if (current->pic_scaling_list_present_flag[i]) {
+                    if (i < 6)
+                        CHECK(FUNC(scaling_list)(ctx, rw,
+                                                 &current->scaling_list_4x4[i],
+                                                 16));
+                    else
+                        CHECK(FUNC(scaling_list)(ctx, rw,
+                                                 &current->scaling_list_8x8[i - 6],
+                                                 64));
+                }
+            }
+        }
+
+        se(second_chroma_qp_index_offset, -12, +12);
+    } else {
+        infer(transform_8x8_mode_flag, 0);
+        infer(pic_scaling_matrix_present_flag, 0);
+        infer(second_chroma_qp_index_offset, current->chroma_qp_index_offset);
+    }
+
+    CHECK(FUNC(rbsp_trailing_bits)(ctx, rw));
+
+    return 0;
+}
+
+static int FUNC(sei_buffering_period)(CodedBitstreamContext *ctx, RWContext *rw,
+                                      H264RawSEIBufferingPeriod *current)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps;
+    int err, i, length;
+
+    ue(seq_parameter_set_id, 0, 31);
+
+    sps = h264->sps[current->seq_parameter_set_id];
+    if (!sps) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""SPS id %d not available.\n"",
+               current->seq_parameter_set_id);
+        return AVERROR_INVALIDDATA;
+    }
+    h264->active_sps = sps;
+
+    if (sps->vui.nal_hrd_parameters_present_flag) {
+        for (i = 0; i <= sps->vui.nal_hrd_parameters.cpb_cnt_minus1; i++) {
+            length = sps->vui.nal_hrd_parameters.initial_cpb_removal_delay_length_minus1 + 1;
+            xu(length, initial_cpb_removal_delay[SchedSelIdx],
+               current->nal.initial_cpb_removal_delay[i],
+               0, (1 << (uint64_t)length) - 1);
+            xu(length, initial_cpb_removal_delay_offset[SchedSelIdx],
+               current->nal.initial_cpb_removal_delay_offset[i],
+               0, (1 << (uint64_t)length) - 1);
+        }
+    }
+
+    if (sps->vui.vcl_hrd_parameters_present_flag) {
+        for (i = 0; i <= sps->vui.vcl_hrd_parameters.cpb_cnt_minus1; i++) {
+            length = sps->vui.vcl_hrd_parameters.initial_cpb_removal_delay_length_minus1 + 1;
+            xu(length, initial_cpb_removal_delay[SchedSelIdx],
+               current->vcl.initial_cpb_removal_delay[i],
+               0, (1 << (uint64_t)length) - 1);
+            xu(length, initial_cpb_removal_delay_offset[SchedSelIdx],
+               current->vcl.initial_cpb_removal_delay_offset[i],
+               0, (1 << (uint64_t)length) - 1);
+        }
+    }
+
+    return 0;
+}
+
+static int FUNC(sei_pic_timestamp)(CodedBitstreamContext *ctx, RWContext *rw,
+                                   H264RawSEIPicTimestamp *current)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps;
+    uint8_t time_offset_length;
+    int err;
+
+    u(2, ct_type, 0, 2);
+    flag(nuit_field_based_flag);
+    u(5, counting_type, 0, 6);
+    flag(full_timestamp_flag);
+    flag(discontinuity_flag);
+    flag(cnt_dropped_flag);
+    u(8, n_frames, 0, 255);
+    if (current->full_timestamp_flag) {
+            u(6, seconds_value, 0, 59);
+            u(6, minutes_value, 0, 59);
+            u(5, hours_value,   0, 23);
+    } else {
+        flag(seconds_flag);
+        if (current->seconds_flag) {
+            u(6, seconds_value, 0, 59);
+            flag(minutes_flag);
+            if (current->minutes_flag) {
+                u(6, minutes_value, 0, 59);
+                flag(hours_flag);
+                if (current->hours_flag)
+                    u(5, hours_value, 0, 23);
+            }
+        }
+    }
+
+    sps = h264->active_sps;
+    if (sps->vui.nal_hrd_parameters_present_flag)
+        time_offset_length = sps->vui.nal_hrd_parameters.time_offset_length;
+    else if (sps->vui.vcl_hrd_parameters_present_flag)
+        time_offset_length = sps->vui.vcl_hrd_parameters.time_offset_length;
+    else
+        time_offset_length = 24;
+
+    if (time_offset_length > 0)
+        u(time_offset_length, time_offset,
+          0, (1 << (uint64_t)time_offset_length) - 1);
+    else
+        infer(time_offset, 0);
+
+    return 0;
+}
+
+static int FUNC(sei_pic_timing)(CodedBitstreamContext *ctx, RWContext *rw,
+                                H264RawSEIPicTiming *current)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps;
+    int err;
+
+    sps = h264->active_sps;
+    if (!sps) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR,
+               ""No active SPS for pic_timing.\n"");
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (sps->vui.nal_hrd_parameters_present_flag ||
+        sps->vui.vcl_hrd_parameters_present_flag) {
+        const H264RawHRD *hrd;
+
+        if (sps->vui.nal_hrd_parameters_present_flag)
+            hrd = &sps->vui.nal_hrd_parameters;
+        else if (sps->vui.vcl_hrd_parameters_present_flag)
+            hrd = &sps->vui.vcl_hrd_parameters;
+        else {
+            av_log(ctx->log_ctx, AV_LOG_ERROR,
+                   ""No HRD parameters for pic_timing.\n"");
+            return AVERROR_INVALIDDATA;
+        }
+
+        u(hrd->cpb_removal_delay_length_minus1 + 1, cpb_removal_delay,
+          0, (1 << (uint64_t)hrd->cpb_removal_delay_length_minus1) + 1);
+        u(hrd->dpb_output_delay_length_minus1 + 1, dpb_output_delay,
+          0, (1 << (uint64_t)hrd->dpb_output_delay_length_minus1) + 1);
+    }
+
+    if (sps->vui.pic_struct_present_flag) {
+        static const int num_clock_ts[9] = {
+            1, 1, 1, 2, 2, 3, 3, 2, 3
+        };
+        int i;
+
+        u(4, pic_struct, 0, 8);
+        if (current->pic_struct > 8)
+            return AVERROR_INVALIDDATA;
+
+        for (i = 0; i < num_clock_ts[current->pic_struct]; i++) {
+            flag(clock_timestamp_flag[i]);
+            if (current->clock_timestamp_flag[i])
+                CHECK(FUNC(sei_pic_timestamp)(ctx, rw, &current->timestamp[i]));
+        }
+    }
+
+    return 0;
+}
+
+static int FUNC(sei_user_data_registered)(CodedBitstreamContext *ctx, RWContext *rw,
+                                          H264RawSEIUserDataRegistered *current,
+                                          uint32_t *payload_size)
+{
+    int err, i, j;
+
+    u(8, itu_t_t35_country_code, 0x00, 0xff);
+    if (current->itu_t_t35_country_code != 0xff)
+        i = 1;
+    else {
+        u(8, itu_t_t35_country_code_extension_byte, 0x00, 0xff);
+        i = 2;
+    }
+
+#ifdef READ
+    if (*payload_size < i) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR,
+               ""Invalid SEI user data registered payload.\n"");
+        return AVERROR_INVALIDDATA;
+    }
+    current->data_length = *payload_size - i;
+#else
+    *payload_size = i + current->data_length;
+#endif
+
+    allocate(current->data, current->data_length);
+    for (j = 0; j < current->data_length; j++)
+        xu(8, itu_t_t35_payload_byte, current->data[j], 0x00, 0xff);
+
+    return 0;
+}
+
+static int FUNC(sei_user_data_unregistered)(CodedBitstreamContext *ctx, RWContext *rw,
+                                            H264RawSEIUserDataUnregistered *current,
+                                            uint32_t *payload_size)
+{
+    int err, i;
+
+#ifdef READ
+    if (*payload_size < 16) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR,
+               ""Invalid SEI user data unregistered payload.\n"");
+        return AVERROR_INVALIDDATA;
+    }
+    current->data_length = *payload_size - 16;
+#else
+    *payload_size = 16 + current->data_length;
+#endif
+
+    for (i = 0; i < 16; i++) {
+        xu(8, uuid_iso_iec_11578,
+           current->uuid_iso_iec_11578[i], 0x00, 0xff);
+    }
+
+    allocate(current->data, current->data_length);
+
+    for (i = 0; i < current->data_length; i++)
+        xu(8, user_data_payload_byte, current->data[i], 0x00, 0xff);
+
+    return 0;
+}
+
+static int FUNC(sei_recovery_point)(CodedBitstreamContext *ctx, RWContext *rw,
+                                    H264RawSEIRecoveryPoint *current)
+{
+    int err;
+
+    ue(recovery_frame_cnt, 0, 65535);
+    flag(exact_match_flag);
+    flag(broken_link_flag);
+    u(2, changing_slice_group_idc, 0, 2);
+
+    return 0;
+}
+
+static int FUNC(sei_display_orientation)(CodedBitstreamContext *ctx, RWContext *rw,
+                                         H264RawSEIDisplayOrientation *current)
+{
+    int err;
+
+    flag(display_orientation_cancel_flag);
+    if (!current->display_orientation_cancel_flag) {
+        flag(hor_flip);
+        flag(ver_flip);
+        u(16, anticlockwise_rotation, 0, 65535);
+        ue(display_orientation_repetition_period, 0, 16384);
+        flag(display_orientation_extension_flag);
+    }
+
+    return 0;
+}
+
+static int FUNC(sei_payload)(CodedBitstreamContext *ctx, RWContext *rw,
+                             H264RawSEIPayload *current)
+{
+    int err, i;
+    int start_position, end_position;
+
+#ifdef READ
+    start_position = get_bits_count(rw);
+#else
+    start_position = put_bits_count(rw);
+#endif
+
+    switch (current->payload_type) {
+    case H264_SEI_TYPE_BUFFERING_PERIOD:
+        CHECK(FUNC(sei_buffering_period)
+              (ctx, rw, &current->payload.buffering_period));
+        break;
+    case H264_SEI_TYPE_PIC_TIMING:
+        CHECK(FUNC(sei_pic_timing)
+              (ctx, rw, &current->payload.pic_timing));
+        break;
+    case H264_SEI_TYPE_FILLER_PAYLOAD:
+        {
+            av_unused int ff_byte = 0xff;
+            for (i = 0; i  < current->payload_size; i++)
+                xu(8, ff_byte, ff_byte, 0xff, 0xff);
+        }
+        break;
+    case H264_SEI_TYPE_USER_DATA_REGISTERED:
+        CHECK(FUNC(sei_user_data_registered)
+              (ctx, rw, &current->payload.user_data_registered, &current->payload_size));
+        break;
+    case H264_SEI_TYPE_USER_DATA_UNREGISTERED:
+        CHECK(FUNC(sei_user_data_unregistered)
+              (ctx, rw, &current->payload.user_data_unregistered, &current->payload_size));
+        break;
+    case H264_SEI_TYPE_RECOVERY_POINT:
+        CHECK(FUNC(sei_recovery_point)
+              (ctx, rw, &current->payload.recovery_point));
+        break;
+    case H264_SEI_TYPE_DISPLAY_ORIENTATION:
+        CHECK(FUNC(sei_display_orientation)
+              (ctx, rw, &current->payload.display_orientation));
+        break;
+    default:
+        {
+            allocate(current->payload.other.data, current->payload_size);
+            for (i = 0; i < current->payload_size; i++)
+                xu(8, payload_byte, current->payload.other.data[i], 0, 255);
+        }
+    }
+
+    if (byte_alignment(rw)) {
+        av_unused int one = 1, zero = 0;
+        xu(1, bit_equal_to_one, one, 1, 1);
+        while (byte_alignment(rw))
+            xu(1, bit_equal_to_zero, zero, 0, 0);
+    }
+
+#ifdef READ
+    end_position = get_bits_count(rw);
+    if (end_position < start_position + 8 * current->payload_size) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Incorrect SEI payload length: ""
+               ""header %d bits, actually %d bits.\n"",
+               8 * current->payload_size,
+               end_position - start_position);
+        return AVERROR_INVALIDDATA;
+    }
+#else
+    end_position = put_bits_count(rw);
+    current->payload_size = (end_position - start_position) / 8;
+#endif
+
+    return 0;
+}
+
+static int FUNC(sei)(CodedBitstreamContext *ctx, RWContext *rw,
+                     H264RawSEI *current)
+{
+    int err, k;
+
+    HEADER(""Supplemental Enhancement Information"");
+
+    CHECK(FUNC(nal_unit_header)(ctx, rw, &current->nal_unit_header,
+                                1 << H264_NAL_SEI));
+
+#ifdef READ
+    for (k = 0; k < H264_MAX_SEI_PAYLOADS; k++) {
+        uint32_t payload_type = 0;
+        uint32_t payload_size = 0;
+        uint32_t tmp;
+
+        while (show_bits(rw, 8) == 0xff) {
+            xu(8, ff_byte, tmp, 0xff, 0xff);
+            payload_type += 255;
+        }
+        xu(8, last_payload_type_byte, tmp, 0, 254);
+        payload_type += tmp;
+
+        while (show_bits(rw, 8) == 0xff) {
+            xu(8, ff_byte, tmp, 0xff, 0xff);
+            payload_size += 255;
+        }
+        xu(8, last_payload_size_byte, tmp, 0, 254);
+        payload_size += tmp;
+
+        current->payload[k].payload_type = payload_type;
+        current->payload[k].payload_size = payload_size;
+
+        CHECK(FUNC(sei_payload)(ctx, rw, &current->payload[k]));
+
+        if (!cbs_h2645_read_more_rbsp_data(rw))
+            break;
+    }
+    if (k >= H264_MAX_SEI_PAYLOADS) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Too many payloads in ""
+               ""SEI message: found %d.\n"", k);
+        return AVERROR_INVALIDDATA;
+    }
+    current->payload_count = k + 1;
+#else
+    for (k = 0; k < current->payload_count; k++) {
+        PutBitContext start_state;
+        uint32_t tmp;
+        int need_size, i;
+
+        // Somewhat clumsy: we write the payload twice when
+        // we don't know the size in advance.  This will mess
+        // with trace output, but is otherwise harmless.
+        start_state = *rw;
+        need_size = !current->payload[k].payload_size;
+        for (i = 0; i < 1 + need_size; i++) {
+            *rw = start_state;
+
+            tmp = current->payload[k].payload_type;
+            while (tmp >= 255) {
+                xu(8, ff_byte, 0xff, 0xff, 0xff);
+                tmp -= 255;
+            }
+            xu(8, last_payload_type_byte, tmp, 0, 254);
+
+            tmp = current->payload[k].payload_size;
+            while (tmp >= 255) {
+                xu(8, ff_byte, 0xff, 0xff, 0xff);
+                tmp -= 255;
+            }
+            xu(8, last_payload_size_byte, tmp, 0, 254);
+
+            CHECK(FUNC(sei_payload)(ctx, rw, &current->payload[k]));
+        }
+    }
+#endif
+
+    CHECK(FUNC(rbsp_trailing_bits)(ctx, rw));
+
+    return 0;
+}
+
+static int FUNC(aud)(CodedBitstreamContext *ctx, RWContext *rw,
+                     H264RawAUD *current)
+{
+    int err;
+
+    HEADER(""Access Unit Delimiter"");
+
+    CHECK(FUNC(nal_unit_header)(ctx, rw, &current->nal_unit_header,
+                                1 << H264_NAL_AUD));
+
+    u(3, primary_pic_type, 0, 7);
+
+    CHECK(FUNC(rbsp_trailing_bits)(ctx, rw));
+
+    return 0;
+}
+
+static int FUNC(ref_pic_list_modification)(CodedBitstreamContext *ctx, RWContext *rw,
+                                           H264RawSliceHeader *current)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps = h264->active_sps;
+    int err, i, mopn;
+
+    if (current->slice_type % 5 != 2 &&
+        current->slice_type % 5 != 4) {
+        flag(ref_pic_list_modification_flag_l0);
+        if (current->ref_pic_list_modification_flag_l0) {
+            for (i = 0; i < H264_MAX_RPLM_COUNT; i++) {
+                xue(modification_of_pic_nums_idc,
+                    current->rplm_l0[i].modification_of_pic_nums_idc, 0, 3);
+
+                mopn = current->rplm_l0[i].modification_of_pic_nums_idc;
+                if (mopn == 3)
+                    break;
+
+                if (mopn == 0 || mopn == 1)
+                    xue(abs_diff_pic_num_minus1,
+                        current->rplm_l0[i].abs_diff_pic_num_minus1,
+                        0, (1 + current->field_pic_flag) *
+                        (1 << (sps->log2_max_frame_num_minus4 + 4)));
+                else if (mopn == 2)
+                    xue(long_term_pic_num,
+                        current->rplm_l0[i].long_term_pic_num,
+                        0, sps->max_num_ref_frames - 1);
+            }
+        }
+    }
+
+    if (current->slice_type % 5 == 1) {
+        flag(ref_pic_list_modification_flag_l1);
+        if (current->ref_pic_list_modification_flag_l1) {
+            for (i = 0; i < H264_MAX_RPLM_COUNT; i++) {
+                xue(modification_of_pic_nums_idc,
+                    current->rplm_l1[i].modification_of_pic_nums_idc, 0, 3);
+
+                mopn = current->rplm_l1[i].modification_of_pic_nums_idc;
+                if (mopn == 3)
+                    break;
+
+                if (mopn == 0 || mopn == 1)
+                    xue(abs_diff_pic_num_minus1,
+                        current->rplm_l1[i].abs_diff_pic_num_minus1,
+                        0, (1 + current->field_pic_flag) *
+                        (1 << (sps->log2_max_frame_num_minus4 + 4)));
+                else if (mopn == 2)
+                    xue(long_term_pic_num,
+                        current->rplm_l1[i].long_term_pic_num,
+                        0, sps->max_num_ref_frames - 1);
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int FUNC(pred_weight_table)(CodedBitstreamContext *ctx, RWContext *rw,
+                                   H264RawSliceHeader *current)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps = h264->active_sps;
+    int chroma;
+    int err, i, j;
+
+    ue(luma_log2_weight_denom, 0, 7);
+
+    chroma = !sps->separate_colour_plane_flag && sps->chroma_format_idc != 0;
+    if (chroma)
+        ue(chroma_log2_weight_denom, 0, 7);
+
+    for (i = 0; i <= current->num_ref_idx_l0_active_minus1; i++) {
+        flag(luma_weight_l0_flag[i]);
+        if (current->luma_weight_l0_flag[i]) {
+            se(luma_weight_l0[i], -128, +127);
+            se(luma_offset_l0[i], -128, +127);
+        }
+        if (chroma) {
+            flag(chroma_weight_l0_flag[i]);
+            if (current->chroma_weight_l0_flag[i]) {
+                for (j = 0; j < 2; j++) {
+                    se(chroma_weight_l0[i][j], -128, +127);
+                    se(chroma_offset_l0[i][j], -128, +127);
+                }
+            }
+        }
+    }
+
+    if (current->slice_type % 5 == 1) {
+        for (i = 0; i <= current->num_ref_idx_l1_active_minus1; i++) {
+            flag(luma_weight_l1_flag[i]);
+            if (current->luma_weight_l1_flag[i]) {
+                se(luma_weight_l1[i], -128, +127);
+                se(luma_offset_l1[i], -128, +127);
+            }
+            if (chroma) {
+                flag(chroma_weight_l1_flag[i]);
+                if (current->chroma_weight_l1_flag[i]) {
+                    for (j = 0; j < 2; j++) {
+                        se(chroma_weight_l1[i][j], -128, +127);
+                        se(chroma_offset_l1[i][j], -128, +127);
+                    }
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int FUNC(dec_ref_pic_marking)(CodedBitstreamContext *ctx, RWContext *rw,
+                                     H264RawSliceHeader *current, int idr_pic_flag)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps = h264->active_sps;
+    int err, i;
+    uint32_t mmco;
+
+    if (idr_pic_flag) {
+        flag(no_output_of_prior_pics_flag);
+        flag(long_term_reference_flag);
+    } else {
+        flag(adaptive_ref_pic_marking_mode_flag);
+        if (current->adaptive_ref_pic_marking_mode_flag) {
+            for (i = 0; i < H264_MAX_MMCO_COUNT; i++) {
+                xue(memory_management_control_operation,
+                    current->mmco[i].memory_management_control_operation,
+                    0, 6);
+
+                mmco = current->mmco[i].memory_management_control_operation;
+                if (mmco == 0)
+                    break;
+
+                if (mmco == 1 || mmco == 3)
+                    xue(difference_of_pic_nums_minus1,
+                        current->mmco[i].difference_of_pic_nums_minus1,
+                        0, INT32_MAX);
+                if (mmco == 2)
+                    xue(long_term_pic_num,
+                        current->mmco[i].long_term_pic_num,
+                        0, sps->max_num_ref_frames - 1);
+                if (mmco == 3 || mmco == 6)
+                    xue(long_term_frame_idx,
+                        current->mmco[i].long_term_frame_idx,
+                        0, sps->max_num_ref_frames - 1);
+                if (mmco == 4)
+                    xue(max_long_term_frame_idx_plus1,
+                        current->mmco[i].max_long_term_frame_idx_plus1,
+                        0, sps->max_num_ref_frames);
+            }
+            if (i == H264_MAX_MMCO_COUNT) {
+                av_log(ctx->log_ctx, AV_LOG_ERROR, ""Too many ""
+                       ""memory management control operations.\n"");
+                return AVERROR_INVALIDDATA;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int FUNC(slice_header)(CodedBitstreamContext *ctx, RWContext *rw,
+                              H264RawSliceHeader *current)
+{
+    CodedBitstreamH264Context *h264 = ctx->priv_data;
+    const H264RawSPS *sps;
+    const H264RawPPS *pps;
+    int err;
+    int idr_pic_flag;
+    int slice_type_i, slice_type_p, slice_type_b;
+    int slice_type_si, slice_type_sp;
+
+    HEADER(""Slice Header"");
+
+    CHECK(FUNC(nal_unit_header)(ctx, rw, &current->nal_unit_header,
+                                1 << H264_NAL_SLICE     |
+                                1 << H264_NAL_IDR_SLICE |
+                                1 << H264_NAL_AUXILIARY_SLICE));
+
+    if (current->nal_unit_header.nal_unit_type == H264_NAL_AUXILIARY_SLICE) {
+        if (!h264->last_slice_nal_unit_type) {
+            av_log(ctx->log_ctx, AV_LOG_ERROR, ""Auxiliary slice ""
+                   ""is not decodable without the main picture ""
+                   ""in the same access unit.\n"");
+            return AVERROR_INVALIDDATA;
+        }
+    } else {
+        h264->last_slice_nal_unit_type =
+            current->nal_unit_header.nal_unit_type;
+    }
+    idr_pic_flag = h264->last_slice_nal_unit_type == H264_NAL_IDR_SLICE;
+
+    ue(first_mb_in_slice, 0, H264_MAX_MB_PIC_SIZE - 1);
+    ue(slice_type, 0, 9);
+
+    slice_type_i  = current->slice_type % 5 == 2;
+    slice_type_p  = current->slice_type % 5 == 0;
+    slice_type_b  = current->slice_type % 5 == 1;
+    slice_type_si = current->slice_type % 5 == 4;
+    slice_type_sp = current->slice_type % 5 == 3;
+
+    if (idr_pic_flag && !(slice_type_i || slice_type_si)) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid slice type %d ""
+               ""for IDR picture.\n"", current->slice_type);
+        return AVERROR_INVALIDDATA;
+    }
+
+    ue(pic_parameter_set_id, 0, 255);
+
+    pps = h264->pps[current->pic_parameter_set_id];
+    if (!pps) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""PPS id %d not available.\n"",
+               current->pic_parameter_set_id);
+        return AVERROR_INVALIDDATA;
+    }
+    h264->active_pps = pps;
+
+    sps = h264->sps[pps->seq_parameter_set_id];
+    if (!sps) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""SPS id %d not available.\n"",
+               pps->seq_parameter_set_id);
+        return AVERROR_INVALIDDATA;
+    }
+    h264->active_sps = sps;
+
+    if (sps->separate_colour_plane_flag)
+        u(2, colour_plane_id, 0, 2);
+
+    u(sps->log2_max_frame_num_minus4 + 4, frame_num,
+      0, (1 << (sps->log2_max_frame_num_minus4 + 4)) - 1);
+
+    if (!sps->frame_mbs_only_flag) {
+        flag(field_pic_flag);
+        if (current->field_pic_flag)
+            flag(bottom_field_flag);
+        else
+            infer(bottom_field_flag, 0);
+    } else {
+        infer(field_pic_flag,    0);
+        infer(bottom_field_flag, 0);
+    }
+
+    if (idr_pic_flag)
+        ue(idr_pic_id, 0, 65535);
+
+    if (sps->pic_order_cnt_type == 0) {
+        u(sps->log2_max_pic_order_cnt_lsb_minus4 + 4, pic_order_cnt_lsb,
+          0, (1 << (sps->log2_max_pic_order_cnt_lsb_minus4 + 4)) - 1);
+        if (pps->bottom_field_pic_order_in_frame_present_flag &&
+            !current->field_pic_flag)
+            se(delta_pic_order_cnt_bottom, INT32_MIN + 1, INT32_MAX);
+
+    } else if (sps->pic_order_cnt_type == 1) {
+        if (!sps->delta_pic_order_always_zero_flag) {
+            se(delta_pic_order_cnt[0], INT32_MIN + 1, INT32_MAX);
+            if (pps->bottom_field_pic_order_in_frame_present_flag &&
+                !current->field_pic_flag)
+                se(delta_pic_order_cnt[1], INT32_MIN + 1, INT32_MAX);
+            else
+                infer(delta_pic_order_cnt[1], 0);
+        } else {
+            infer(delta_pic_order_cnt[0], 0);
+            infer(delta_pic_order_cnt[1], 0);
+        }
+    }
+
+    if (pps->redundant_pic_cnt_present_flag)
+        ue(redundant_pic_cnt, 0, 127);
+
+    if (slice_type_b)
+        flag(direct_spatial_mv_pred_flag);
+
+    if (slice_type_p || slice_type_sp || slice_type_b) {
+        flag(num_ref_idx_active_override_flag);
+        if (current->num_ref_idx_active_override_flag) {
+            ue(num_ref_idx_l0_active_minus1, 0, 31);
+            if (slice_type_b)
+                ue(num_ref_idx_l1_active_minus1, 0, 31);
+        } else {
+            infer(num_ref_idx_l0_active_minus1,
+                  pps->num_ref_idx_l0_default_active_minus1);
+            infer(num_ref_idx_l1_active_minus1,
+                  pps->num_ref_idx_l1_default_active_minus1);
+        }
+    }
+
+    if (current->nal_unit_header.nal_unit_type == 20 ||
+        current->nal_unit_header.nal_unit_type == 21) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, ""MVC / 3DAVC not supported.\n"");
+        return AVERROR_PATCHWELCOME;
+    } else {
+        CHECK(FUNC(ref_pic_list_modification)(ctx, rw, current));
+    }
+
+    if ((pps->weighted_pred_flag && (slice_type_p || slice_type_sp)) ||
+        (pps->weighted_bipred_idc == 1 && slice_type_b)) {
+        CHECK(FUNC(pred_weight_table)(ctx, rw, current));
+    }
+
+    if (current->nal_unit_header.nal_ref_idc != 0) {
+        CHECK(FUNC(dec_ref_pic_marking)(ctx, rw, current, idr_pic_flag));
+    }
+
+    if (pps->entropy_coding_mode_flag &&
+        !slice_type_i && !slice_type_si) {
+        ue(cabac_init_idc, 0, 2);
+    }
+
+    se(slice_qp_delta, - 51 - 6 * sps->bit_depth_luma_minus8,
+                       + 51 + 6 * sps->bit_depth_luma_minus8);
+    if (slice_type_sp || slice_type_si) {
+        if (slice_type_sp)
+            flag(sp_for_switch_flag);
+        se(slice_qs_delta, -51, +51);
+    }
+
+    if (pps->deblocking_filter_control_present_flag) {
+        ue(disable_deblocking_filter_idc, 0, 2);
+        if (current->disable_deblocking_filter_idc != 1) {
+            se(slice_alpha_c0_offset_div2, -6, +6);
+            se(slice_beta_offset_div2,     -6, +6);
+        } else {
+            infer(slice_alpha_c0_offset_div2, 0);
+            infer(slice_beta_offset_div2,     0);
+        }
+    } else {
+        infer(disable_deblocking_filter_idc, 0);
+        infer(slice_alpha_c0_offset_div2,    0);
+        infer(slice_beta_offset_div2,        0);
+    }
+
+    if (pps->num_slice_groups_minus1 > 0 &&
+        pps->slice_group_map_type >= 3 &&
+        pps->slice_group_map_type <= 5) {
+        unsigned int pic_size, max, bits;
+
+        pic_size = (sps->pic_width_in_mbs_minus1 + 1) *
+                   (sps->pic_height_in_map_units_minus1 + 1);
+        max = (pic_size + pps->slice_group_change_rate_minus1) /
+              (pps->slice_group_change_rate_minus1 + 1);
+        bits = av_log2(2 * max - 1);
+
+        u(bits, slice_group_change_cycle, 0, max);
+    }
+
+    if (pps->entropy_coding_mode_flag) {
+        av_unused int one = 1;
+        while (byte_alignment(rw))
+            xu(1, cabac_alignment_one_bit, one, 1, 1);
+    }
+
+    return 0;
+}
",1,libavcodec/cbs_h264_syntax_template.c,1230,java,ffmpeg___ffmpeg,test
4551,21448,6686aa8acc85ae9a03cecdedc7c9d8b090e2b97b,"@@ -61,8 +61,7 @@ public:
           std::unique_ptr<Grpc::MockAsyncClient>(async_client_), dispatcher_,
           *Protobuf::DescriptorPool::generated_pool()->FindMethodByName(
               ""envoy.service.discovery.v2.AggregatedDiscoveryService.StreamAggregatedResources""),
-          envoy::config::core::v3::ApiVersion::AUTO, random_, stats_, rate_limit_settings_,
-          local_info_, false);
+          random_, stats_, rate_limit_settings_, local_info_, false);
       return;
     }
     grpc_mux_ = std::make_unique<NewGrpcMuxImpl>(
",1,test/common/config/new_grpc_mux_impl_test.cc,3,java,envoyproxy___envoy,test
9411,44775,46fa893355e0bd88f3c59b886f0d75cbd5f0bbbe,"@@ -116,7 +116,7 @@ static void kvm_s390_stattrib_synchronize(S390StAttribState *sa)
         for (cx = 0; cx + len <= max; cx += len) {
             clog.start_gfn = cx;
             clog.count = len;
-            clog.values = (uint64_t)(sas->incoming_buffer + cx * len);
+            clog.values = (uint64_t)(sas->incoming_buffer + cx);
             r = kvm_vm_ioctl(kvm_state, KVM_S390_SET_CMMA_BITS, &clog);
             if (r) {
                 error_report(""KVM_S390_SET_CMMA_BITS failed: %s"", strerror(-r));
@@ -126,7 +126,7 @@ static void kvm_s390_stattrib_synchronize(S390StAttribState *sa)
         if (cx < max) {
             clog.start_gfn = cx;
             clog.count = max - cx;
-            clog.values = (uint64_t)(sas->incoming_buffer + cx * len);
+            clog.values = (uint64_t)(sas->incoming_buffer + cx);
             r = kvm_vm_ioctl(kvm_state, KVM_S390_SET_CMMA_BITS, &clog);
             if (r) {
                 error_report(""KVM_S390_SET_CMMA_BITS failed: %s"", strerror(-r));
",0,hw/s390x/s390-stattrib-kvm.c,4,java,qemu___qemu,test
6434,30264,7ed4e6352c16fe018864bc4e626c48e27a0cefee,"@@ -46,6 +46,9 @@
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include ""dcn10/dcn10_resource.h""
 #endif
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+#include ""dcn20/dcn20_resource.h""
+#endif
 #include ""dce120/dce120_resource.h""
 
 #define DC_LOGGER_INIT(logger)
@@ -97,6 +100,12 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 			dc_version = DCN_VERSION_1_01;
 		break;
 #endif
+
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	case FAMILY_NV:
+		dc_version = DCN_VERSION_2_0;
+		break;
+#endif
 	default:
 		dc_version = DCE_VERSION_UNKNOWN;
 		break;
@@ -151,6 +160,12 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 #endif
 
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	case DCN_VERSION_2_0:
+		res_pool = dcn20_create_resource_pool(init_data, dc);
+		break;
+#endif
+
 	default:
 		break;
 	}
",1,drivers/gpu/drm/amd/display/dc/core/dc_resource.c,15,java,torvalds___linux,test
3892,18253,f58aab9d6a57e48bdc60e15dd373c24de74719a9,"@@ -674,7 +674,7 @@ OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)
     if ((l_tilec->data == 00) ||
             ((l_tilec->data_size_needed > l_tilec->data_size) &&
              (l_tilec->ownsData == OPJ_FALSE))) {
-        l_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);
+        l_tilec->data = (OPJ_INT32 *) opj_image_data_alloc(l_tilec->data_size_needed);
         if (! l_tilec->data) {
             return OPJ_FALSE;
         }
@@ -683,8 +683,8 @@ OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)
         l_tilec->ownsData = OPJ_TRUE;
     } else if (l_tilec->data_size_needed > l_tilec->data_size) {
         /* We don't need to keep old data */
-        opj_aligned_free(l_tilec->data);
-        l_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);
+        opj_image_data_free(l_tilec->data);
+        l_tilec->data = (OPJ_INT32 *) opj_image_data_alloc(l_tilec->data_size_needed);
         if (! l_tilec->data) {
             l_tilec->data_size = 0;
             l_tilec->data_size_needed = 0;
@@ -1645,7 +1645,7 @@ static void opj_tcd_free_tile(opj_tcd_t *p_tcd)
         }
 
         if (l_tile_comp->ownsData && l_tile_comp->data) {
-            opj_aligned_free(l_tile_comp->data);
+            opj_image_data_free(l_tile_comp->data);
             l_tile_comp->data = 00;
             l_tile_comp->ownsData = 0;
             l_tile_comp->data_size = 0;
",1,src/lib/openjp2/tcd.c,8,java,uclouvain___openjpeg,test
6208,29295,cd30663c40a8f50e4adb671aa18e129684c38348,"@@ -73,7 +73,7 @@ typedef struct
 
 GF_Err writegen_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)
 {
-	u32 cid, chan, sr, w, h, stype, pf, sfmt, av1mode;
+	u32 cid, chan, sr, w, h, stype, pf, sfmt, av1mode, nb_bps;
 	const char *name, *mimetype;
 	char szExt[10], szCodecExt[30], *sep;
 	const GF_PropertyValue *p;
@@ -113,6 +113,10 @@ GF_Err writegen_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remo
 	chan = p ? p->value.uint : 0;
 	p = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);
 	sfmt = p ? p->value.uint : GF_AUDIO_FMT_S16;
+	p = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_BPS);
+	nb_bps = p ? p->value.uint : 0;
+
+
 	p = gf_filter_pid_get_property(pid, GF_PROP_PID_WIDTH);
 	ctx->w = w = p ? p->value.uint : 0;
 	p = gf_filter_pid_get_property(pid, GF_PROP_PID_HEIGHT);
@@ -191,6 +195,12 @@ GF_Err writegen_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remo
 		ctx->decinfo = DECINFO_FIRST;
 		break;
 
+	case GF_CODECID_FLAC:
+		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_MIME, &PROP_STRING(mimetype) );
+		ctx->decinfo = DECINFO_FIRST;
+		break;
+
+
 	case GF_CODECID_SIMPLE_TEXT:
 		if (!gf_filter_pid_get_property(pid, GF_PROP_PID_MIME))
 			gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_MIME, &PROP_STRING(mimetype) );
@@ -359,7 +369,10 @@ GF_Err writegen_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remo
 			if (cid==GF_CODECID_RAW) {
 				GF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (""Exporting PCM %s SampleRate %d %d channels %d bits per sample\n"", gf_audio_fmt_name(sfmt), sr, chan, gf_audio_fmt_bit_depth(sfmt) ));
 			} else {
-				GF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (""Exporting %s - SampleRate %d %d channels %d bits per sample\n"", name, sr, chan, gf_audio_fmt_bit_depth(sfmt) ));
+				if (!nb_bps)
+					nb_bps = gf_audio_fmt_bit_depth(sfmt);
+
+				GF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (""Exporting %s - SampleRate %d %d channels %d bits per sample\n"", name, sr, chan, nb_bps ));
 			}
 		} else {
 			GF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (""Exporting %s\n"", name));
",1,src/filters/write_generic.c,17,java,gpac___gpac,test
4076,19115,6c3a63fc3d1be7ac947e38a165a299c9e5d37764,"@@ -370,7 +370,9 @@ static void apply_dependent_coupling_fixed(AACContext *ac,
                     shift = (gain-1024) >> 3;
                 }
 
-                if (shift < 0) {
+                if (shift < -31) {
+                    // Nothing to do
+                } else if (shift < 0) {
                     shift = -shift;
                     round = 1 << (shift - 1);
 
",0,libavcodec/aacdec_fixed.c,4,java,ffmpeg___ffmpeg,test
4132,19390,e56aee6473486fdfac0429747284fda7cdd3aae5,"@@ -23,6 +23,8 @@
 #include ""core/loader/ImageLoader.h""
 
 #include <memory>
+#include <utility>
+
 #include ""bindings/core/v8/ExceptionState.h""
 #include ""bindings/core/v8/ScriptController.h""
 #include ""bindings/core/v8/V8BindingForCore.h""
@@ -391,10 +393,16 @@ void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,
           referrer_policy, url, document.OutgoingReferrer()));
     }
 
+    // Correct the RequestContext if necessary.
     if (IsHTMLPictureElement(GetElement()->parentNode()) ||
-        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull())
+        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull()) {
       resource_request.SetRequestContext(
           WebURLRequest::kRequestContextImageSet);
+    } else if (IsHTMLObjectElement(GetElement())) {
+      resource_request.SetRequestContext(WebURLRequest::kRequestContextObject);
+    } else if (IsHTMLEmbedElement(GetElement())) {
+      resource_request.SetRequestContext(WebURLRequest::kRequestContextEmbed);
+    }
 
     bool page_is_being_dismissed =
         document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;
",0,third_party/WebKit/Source/core/loader/ImageLoader.cpp,10,java,chromium___chromium,test
7805,36849,3dabb9c69db114b1f30c30e0a2788cffc50bac40,"@@ -486,10 +486,10 @@ static int decode_subframe(TAKDecContext *s, int32_t *decoded,
                 v += (unsigned)s->adsp.scalarproduct_int16(&s->residues[i], s->filter,
                                                  filter_order & -16);
             for (j = filter_order & -16; j < filter_order; j += 4) {
-                v += s->residues[i + j + 3] * s->filter[j + 3] +
-                     s->residues[i + j + 2] * s->filter[j + 2] +
-                     s->residues[i + j + 1] * s->filter[j + 1] +
-                     s->residues[i + j    ] * s->filter[j    ];
+                v += s->residues[i + j + 3] * (unsigned)s->filter[j + 3] +
+                     s->residues[i + j + 2] * (unsigned)s->filter[j + 2] +
+                     s->residues[i + j + 1] * (unsigned)s->filter[j + 1] +
+                     s->residues[i + j    ] * (unsigned)s->filter[j    ];
             }
             v = (av_clip_intp2(v >> filter_quant, 13) * (1 << dshift)) - (unsigned)*decoded;
             *decoded++ = v;
",0,libavcodec/takdec.c,8,java,ffmpeg___ffmpeg,test
